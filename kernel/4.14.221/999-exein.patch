--- a/kernel/exit.c
+++ b/kernel/exit.c
@@ -67,6 +67,9 @@
 #include <asm/unistd.h>
 #include <asm/pgtable.h>
 #include <asm/mmu_context.h>
+#ifdef CONFIG_SECURITY_EXEIN
+#include <exein.h>
+#endif
 
 static void __unhash_process(struct task_struct *p, bool group_dead)
 {
@@ -915,6 +918,13 @@
 	exit_rcu();
 	exit_tasks_rcu_finish();
 
+#ifdef CONFIG_SECURITY_EXEIN
+        if (tsk->process_tag) {
+                exein_delete_pids();
+                }
+#endif
+
+
 	lockdep_free_task(tsk);
 	do_task_dead();
 }
--- a/include/exein.h
+++ b/include/exein.h
@@ -0,0 +1,3 @@
+void exein_delete_pids(void);
+void do_exit_push_pid(pid_t pid);
+void do_fork_push_pid(pid_t pid, void *addr);
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -598,6 +598,9 @@
 	int				static_prio;
 	int				normal_prio;
 	unsigned int			rt_priority;
+#ifdef CONFIG_SECURITY_EXEIN
+        uint16_t                        process_tag;
+#endif
 
 	const struct sched_class	*sched_class;
 	struct sched_entity		se;
--- a/fs/binfmt_elf.c
+++ b/fs/binfmt_elf.c
@@ -699,6 +699,12 @@
 	} *loc;
 	struct arch_elf_state arch_state = INIT_ARCH_ELF_STATE;
 	loff_t pos;
+#ifdef CONFIG_SECURITY_EXEIN
+        loff_t shdrpos,tmppos;
+        struct elf_shdr *shdr;
+        char *strtb;
+        void *tmp;
+#endif
 
 	loc = kmalloc(sizeof(*loc), GFP_KERNEL);
 	if (!loc) {
@@ -721,6 +727,30 @@
 	if (!bprm->file->f_op->mmap)
 		goto out;
 
+#ifdef CONFIG_SECURITY_EXEIN
+        if (current->process_tag==0){
+                if (loc->elf_ex.e_shentsize != 0) {
+                        shdrpos=(loff_t) loc->elf_ex.e_shoff;
+                        shdr  = kmalloc(loc->elf_ex.e_shentsize * loc->elf_ex.e_shnum, GFP_KERNEL);
+                        kernel_read(bprm->file, shdr, loc->elf_ex.e_shentsize * loc->elf_ex.e_shnum, &shdrpos);
+                        strtb = kmalloc(shdr[loc->elf_ex.e_shstrndx].sh_size, GFP_KERNEL);
+                        shdrpos=(loff_t) shdr[loc->elf_ex.e_shstrndx].sh_offset;
+                        kernel_read(bprm->file, strtb, shdr[loc->elf_ex.e_shstrndx].sh_size, &shdrpos);
+                        for (i=0; i< loc->elf_ex.e_shnum; i++){
+                                if (strcmp((strtb+ (shdr + i)->sh_name),".exein")==0){
+                                        tmp=kmalloc(shdr[i].sh_size, GFP_KERNEL);
+                                        tmppos=(loff_t) shdr[i].sh_offset;
+                                        kernel_read(bprm->file, tmp, shdr[i].sh_size, &tmppos);
+                                        current->process_tag=*((uint16_t *) tmp);
+                                        kfree(tmp);
+                                        }
+                                }
+                        kfree(shdr);
+                        kfree(strtb);
+                        }
+                }
+#endif
+
 	elf_phdata = load_elf_phdrs(&loc->elf_ex, bprm->file);
 	if (!elf_phdata)
 		goto out;
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -209,4 +209,6 @@
 
 source "drivers/mux/Kconfig"
 
+source "drivers/exein_interface/Kconfig"
+
 endmenu
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -66,6 +66,9 @@
 
 obj-$(CONFIG_CONNECTOR)		+= connector/
 
+#exein
+obj-$(CONFIG_EXEIN_INTERFACE)   += exein_interface/
+
 # i810fb and intelfb depend on char/agp/
 obj-$(CONFIG_FB_I810)           += video/fbdev/i810/
 obj-$(CONFIG_FB_INTEL)          += video/fbdev/intelfb/
--- a/drivers/exein_interface/Kconfig
+++ b/drivers/exein_interface/Kconfig
@@ -0,0 +1,4 @@
+config EXEIN_INTERFACE
+        tristate "Exein userspace interface support"
+        help
+        This driver provides Exein proc interface
--- a/drivers/exein_interface/Makefile
+++ b/drivers/exein_interface/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_EXEIN_INTERFACE)			+= exein_interface.o
+
--- a/drivers/exein_interface/exein_interface.c
+++ b/drivers/exein_interface/exein_interface.c
@@ -0,0 +1,169 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+//#include <asm/uaccess.h>
+#include <linux/module.h>
+#include <net/sock.h>
+#include <linux/netlink.h>
+#include <linux/skbuff.h>
+
+
+#define NETLINK_USER 			31
+//#define EXEIN_PRINT_DEBUG
+#define BUFFLEN 			4096
+#define EXEIN_ONREQUEST                 0x80
+#define EXEIN_LIVE                      0x81
+
+
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_AUTHOR("Exein");
+
+extern int exein_mode;
+extern void *exein_payload_process_ptr;
+extern void *exein_register_status_get_ptr;
+extern void *exein_pid_status_get_ptr;
+extern int exein_interface_ready;
+extern struct sock *exein_nl_sk_lsm;
+extern int exein_rndkey;
+
+static struct proc_dir_entry *ent;
+
+struct sock *nl_sk = NULL;
+
+
+static void nl_recv_msg(struct sk_buff *skb) {
+	struct nlmsghdr *nlh;
+	int pid;
+	struct sk_buff *skb_out;
+	int msg_size;
+	char *msg_ok="ACK";
+	char *strout;
+	int res;
+	int (*exein_payload_process)(void *,int)=exein_payload_process_ptr;
+
+	nlh=(struct nlmsghdr*)skb->data;
+	pid = nlh->nlmsg_pid; /*pid of sending process */
+	#ifdef EXEIN_PRINT_DEBUG
+	printk(KERN_INFO "ExeinLKM - Netlink received from %d\n", pid);
+	#endif
+
+	if ((*exein_payload_process)(nlmsg_data(nlh),pid)) {
+		skb_out = nlmsg_new(strlen(msg_ok),0);
+		if(!skb_out)
+			{
+			printk(KERN_INFO "ExeinLKM - Failed to allocate new skb\n");
+			return;
+			}
+		nlh=nlmsg_put(skb_out,0,0,NLMSG_DONE,strlen(msg_ok),0);
+		NETLINK_CB(skb_out).dst_group = 0; /* not in mcast group */
+		strncpy(nlmsg_data(nlh),msg_ok,strlen(msg_ok));
+		res=nlmsg_unicast(nl_sk,skb_out,pid);
+		if(res<0) printk(KERN_INFO "Error while sending back to user\n");
+		}
+}
+
+static ssize_t exeinwrite(struct file *file, const char __user *ubuf,size_t count, loff_t *ppos)
+{
+	// data=PDE_DATA(file_inode(file)); //takes the data sent to the 
+	if (exein_mode==EXEIN_ONREQUEST){
+		exein_mode=EXEIN_LIVE;
+	        printk( KERN_INFO "ExeinLKM - LSM mode switched in live\n");
+	}else{
+		exein_mode=EXEIN_ONREQUEST;
+		printk( KERN_INFO "ExeinLKM - LSM mode switched in on request\n");
+	}
+	*ppos = count;
+	return count;
+}
+
+static ssize_t exeinread(struct file *file, char __user *ubuf, size_t count, loff_t *ppos)
+{
+	int len=0;
+	char buff[BUFFLEN];
+	char *fn;
+	int (*exein_register_status_get)(char *,int)=exein_register_status_get_ptr;
+	int (*exein_pid_status_get)(char *,int)=exein_pid_status_get_ptr;
+
+	fn=dentry_path_raw(file->f_path.dentry,buff,BUFFLEN);
+
+#ifdef EXEIN_PRINT_DEBUG
+        if (strcmp(fn, "/exein/rndkey")==0){
+		if (*ppos==0){
+			len+=snprintf(buff,BUFFLEN,"%d\n",exein_rndkey);
+			if(copy_to_user(ubuf,buff,len+1)) {
+				return -EFAULT;
+				}
+			*ppos = len;
+			}
+		}
+#endif
+
+        if (strcmp(fn, "/exein/regs")==0){
+                if (*ppos==0){
+			len=exein_register_status_get(buff, BUFFLEN);
+                        if(copy_to_user(ubuf,buff,len+1)) {
+                                return -EFAULT;
+                                }
+                        *ppos = len;
+                        }
+                }
+
+
+	if (strcmp(fn, "/exein/pids")==0){
+		if (*ppos==0){
+			len=exein_pid_status_get(buff, BUFFLEN);
+			if(copy_to_user(ubuf,buff,len+1)) {
+				EFAULT;
+				}
+			*ppos = len;
+			}
+		}
+        return len;
+}
+
+static struct file_operations ops =
+{
+        .owner = THIS_MODULE,
+        .read = exeinread,
+        .write = exeinwrite,
+};
+
+static int init(void)
+{
+	struct netlink_kernel_cfg cfg = {
+		.input = nl_recv_msg,
+		};
+	nl_sk = netlink_kernel_create(&init_net, NETLINK_USER, &cfg);
+	if(!nl_sk)
+		{
+		 printk(KERN_ALERT "ExeinLKM - Error creating socket.\n");
+		 return -10;
+		}
+	exein_nl_sk_lsm=nl_sk ;
+	char *dirname="exein";
+	struct proc_dir_entry *parent;
+	parent=proc_mkdir(dirname,NULL);
+	ent=proc_create("mode_ctl",0660,parent,&ops);
+#ifdef EXEIN_PRINT_DEBUG
+        ent=proc_create("rndkey",0660,parent,&ops);
+#endif
+	ent=proc_create("regs",0660,parent,&ops);
+	exein_interface_ready=1;
+	ent=proc_create("pids",0660,parent,&ops);
+        exein_interface_ready=1;
+
+	printk(KERN_INFO "ExeinLKM - Interface module load complete. Interface ready.\n");
+	return 0;
+}
+
+static void cleanup(void)
+{
+	exein_interface_ready=0;
+        proc_remove(ent);
+}
+
+module_init(init);
+module_exit(cleanup);
+
--- a/security/Kconfig
+++ b/security/Kconfig
@@ -223,6 +223,7 @@
 source security/apparmor/Kconfig
 source security/loadpin/Kconfig
 source security/yama/Kconfig
+source security/exein/Kconfig
 
 source security/integrity/Kconfig
 
--- a/security/Makefile
+++ b/security/Makefile
@@ -9,6 +9,7 @@
 subdir-$(CONFIG_SECURITY_TOMOYO)        += tomoyo
 subdir-$(CONFIG_SECURITY_APPARMOR)	+= apparmor
 subdir-$(CONFIG_SECURITY_YAMA)		+= yama
+subdir-$(CONFIG_SECURITY_EXEIN)		+= exein
 subdir-$(CONFIG_SECURITY_LOADPIN)	+= loadpin
 
 # always enable default capabilities
@@ -24,6 +25,7 @@
 obj-$(CONFIG_SECURITY_TOMOYO)		+= tomoyo/
 obj-$(CONFIG_SECURITY_APPARMOR)		+= apparmor/
 obj-$(CONFIG_SECURITY_YAMA)		+= yama/
+obj-$(CONFIG_SECURITY_EXEIN)		+= exein/
 obj-$(CONFIG_SECURITY_LOADPIN)		+= loadpin/
 obj-$(CONFIG_CGROUP_DEVICE)		+= device_cgroup.o
 
--- a/security/exein/exein_types.h
+++ b/security/exein/exein_types.h
@@ -0,0 +1,19 @@
+#include <linux/types.h>
+#include <linux/list.h>
+
+#ifndef EXEIN_TYPES_INCLUDED
+#define EXEIN_TYPES_INCLUDED
+
+#define NNINPUT_SIZE 2
+typedef u16 exein_feature_t;
+
+
+// define struct
+typedef struct {
+    uint16_t tag;
+    pid_t pid;
+    int val;
+    struct list_head list;
+} exein_trust_t;
+
+#endif
--- a/security/exein/exein_trust.h
+++ b/security/exein/exein_trust.h
@@ -0,0 +1,6 @@
+#include <linux/list.h>
+
+#include "exein_types.h"
+#include "exein_print_level.h"
+
+void exein_mark_not_trusted(uint16_t tag, pid_t pid);
--- a/security/exein/Kconfig
+++ b/security/exein/Kconfig
@@ -0,0 +1,32 @@
+config SECURITY_EXEIN
+	bool "Exein Linux Security Module"
+	depends on SECURITY
+	default n
+	help
+	  This selects exein, bla bla bla
+
+config SECURITY_EXEIN_RANDOMFOREST
+        bool "Implement Machine learning engine using random forest"
+        depends on SECURITY_EXEIN
+        default n
+        select SIGNATURE
+        help
+          Bla Bla.
+
+
+config SECURITY_EXEIN_NEURALNETWORK
+        bool "Implement Machine learning engine using Recurrent neural network"
+        depends on SECURITY_EXEIN
+        default n
+        select SIGNATURE
+        help
+          Bla Bla.
+
+config SECURITY_EXEIN_SQUEEZE
+        bool "Optimization needed to squueze the LSM into small boxes"
+        depends on SECURITY_EXEIN
+        default n
+        select SIGNATURE
+        help
+          Bla Bla.
+
--- a/security/exein/exein_nn_main.c
+++ b/security/exein/exein_nn_main.c
@@ -0,0 +1,9 @@
+#include "exein_nn_main.h"
+#include <linux/string.h> 
+#include "exein_lsm.h"
+
+int playnn(exein_feature_t *NNInput)
+{
+	exein_delete_expired_regs();
+	return 0;
+}
--- a/security/exein/exein_lsm.c
+++ b/security/exein/exein_lsm.c
@@ -0,0 +1,3274 @@
+/*
+ * exein Linux Security Module
+ *
+ * Author: Alessandro Carminati <alessandro@exein.io>
+ *
+ * Copyright (C) 2019 Exein, SpA.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation.
+ *
+ */
+
+/********************************************************************************************************************************************/
+//#define EXEIN_PRINT_DEBUG
+#define EXEIN_STUFF_DEBUG
+/********************************************************************************************************************************************/
+
+#include "exein_nn_main.h"
+#include "exein_struct_mappings.h"
+#include "exein_nn_defs_comp.h"
+#include "exein_print_level.h"
+#include "exein_lsm.h"
+#include "exein_trust.h"
+
+#include <linux/lsm_hooks.h>
+#include <linux/binfmts.h>
+#include <net/sock.h>
+#include <linux/netlink.h>
+#include <linux/skbuff.h>
+#include <linux/delay.h>
+
+#if NNINPUT_SIZE ==4
+ #define EXEIN_PROT_TAG_POS 4
+#else
+ #define EXEIN_PROT_TAG_POS 3
+#endif
+
+
+#define NN_DEBUG 1
+#define CURRENT_PROCESS_FEATURES 1 // Took as a duplicate from exein_struct_mappings.c as a temporal solution
+#undef EXEIN_FS_CONTEXT_PARSE_PARAM_SWITCH   //this hook, newly implemented, generates some issues / not available on 4.14.151
+#undef EXEIN_FS_CONTEXT_DUP_SWITCH           //not available on 4.14.151
+#undef EXEIN_INODE_GETSECURITY_SWITCH
+#undef EXEIN_TASK_FREE_SWITCH
+#undef EXEIN_SOCKET_SOCK_RCV_SKB_SWITCH
+
+//#ifdef CONFIG_DUP_TS_FIND_IN_LSM
+//extern int do_dup_td_find(int hook);
+//#endif
+
+//int	exein_debug=0;
+int	exein_mode=EXEIN_ONREQUEST;
+void	*exein_payload_process_ptr;
+void	*exein_register_status_get_ptr, *exein_pid_status_get_ptr;
+int	exein_interface_ready=0;
+struct	sock *exein_nl_sk_lsm=NULL;
+
+DEFINE_SPINLOCK(exein_pid_data_access);
+DEFINE_SPINLOCK(exein_reg_data_access);
+
+DEFINE_HASHTABLE(nl_peers,HASHTABLE_BITS);
+DEFINE_HASHTABLE(pid_repo,HASHTABLE_BITS);
+
+//EXPORT_SYMBOL(exein_debug);
+EXPORT_SYMBOL(exein_mode);
+EXPORT_SYMBOL(exein_payload_process_ptr);
+EXPORT_SYMBOL(exein_interface_ready);
+EXPORT_SYMBOL(exein_nl_sk_lsm);
+EXPORT_SYMBOL(exein_pid_status_get_ptr);
+EXPORT_SYMBOL(exein_register_status_get_ptr);
+
+#ifdef EXEIN_STUFF_DEBUG
+int exein_rndkey=SEEDRND;
+	EXPORT_SYMBOL(exein_rndkey);
+#endif
+
+static int hash_func_4_addrs(PTRSIZE data)
+{ //because the allignment, and other stuffs there's more entrophy starting from bit 5
+    return (data >> 6) & ((1<<HASHTABLE_BITS)-1);
+}
+static int hash_func_4_pids(int data)
+{
+    return data & ((1<<HASHTABLE_BITS)-1);
+}
+
+// this function gets called after a grace period has elapsed to deallocate the unlinked exein_pid_data elements.
+// to deallocate pids elements, the function needs to deallocate the container, ad all the buffers in the round buffer.
+static void pid_data_deferred_deletion(struct rcu_head *rcu) {
+	int 		i;
+	exein_pid_data	*b = container_of(rcu, exein_pid_data, rcu);
+
+//	printk(KERN_INFO "ExeinLSM[%d] - pid_data_deferred_deletion: delete pid_data [%d]@0x%p\n", current->pid, b->pid, b);
+	trace_printk("ExeinLSM[%d] - pid_data_deferred_deletion: delete pid_data [%d]@0x%p\n", current->pid, b->pid, b);
+	for (i=0; i<EXEIN_RINGBUFFER_SIZE; i++) kfree(b->hookdata[i]);
+	kfree(b);
+}
+
+static void reg_data_deferred_deletion(struct rcu_head *rcu) {
+	exein_reg_data  *b = container_of(rcu, exein_reg_data, rcu);
+	kfree(b);
+}
+
+int exein_register_status_get(char *buf, int size){ // TODO: Replace sprintf with snprintf. Use the size argument
+	int pos=0;
+        int bkt_cursor;
+        exein_reg_data *reg_data;
+
+	pos+=sprintf( (buf+pos),"pid, tag, time\n");
+	rcu_read_lock();
+	hash_for_each(nl_peers, bkt_cursor, reg_data, next)
+	pos+=sprintf( (buf+pos),"%d,%d,%llu\n", reg_data->pid, reg_data->tag, reg_data->timestamp);
+	rcu_read_unlock();
+	return pos;
+}
+
+int exein_pid_status_get(char *buf, int size){ // TODO: Replace sprintf with snprintf. Use the size argument
+	int pos=0, peerpid=0;
+	int bkt_cursor, pid_cursor;
+	exein_reg_data *reg_data;
+	exein_pid_data *pid_data;
+
+	pos+=sprintf( (buf+pos),"pid, tag, ts_addr, peer_pid\n");
+	rcu_read_lock();
+	hash_for_each(pid_repo, pid_cursor, pid_data, next){
+		hash_for_each(nl_peers, bkt_cursor, reg_data, next) if (reg_data->tag==pid_data->tag) peerpid=reg_data->pid;
+		pos+=sprintf( (buf+pos),"%d,%d,%x,%d\n", pid_data->pid, pid_data->tag, pid_data->task_struct_addr, peerpid);
+		}
+	rcu_read_unlock();
+	return pos;
+}
+
+
+
+// each time this function is triggered it scans the registration hash and select the first expired item if any.
+// if more than one exein agent is registered, and more than one expires, for example during the shutdown, it could be
+// too much delete everything in a single hook slot.
+void exein_delete_expired_regs(void){
+	int			bkt_cursor, pid_cursor;
+	exein_reg_data		*reg_data;
+	exein_pid_data          *pid_data;
+	int 			reg_2del_found=0;
+
+	// scans registration hashes and find first expired item
+	rcu_read_lock();
+	hash_for_each_rcu(nl_peers, bkt_cursor, reg_data, next){
+		if (jiffies_64-reg_data->timestamp>EXEIN_REG_DURATION){
+			reg_2del_found=1;
+			break;
+			}
+		}
+	rcu_read_unlock();
+
+	if (reg_2del_found){				// if one is found, it is possible to start a critical section with locks.
+							// in this critical section is mandatory to search for the expired regs again,with locks, just to be sure that in
+							// the meantime nothing has changed.
+		spin_lock_bh(&exein_reg_data_access);
+		hash_for_each_rcu(nl_peers, bkt_cursor, reg_data, next){
+			if (jiffies_64-reg_data->timestamp>EXEIN_REG_DURATION){
+				reg_2del_found=1;
+				break;
+				}
+			}
+		if (reg_data){				// if still there, just delete the expired reg, and schedule the function for free the memory.
+			hash_del_rcu(&reg_data->next);
+			call_rcu(&reg_data->rcu, reg_data_deferred_deletion);
+			}
+		spin_unlock_bh(&exein_reg_data_access);	//unlock the data structure either case, and do it asap.
+		if (reg_data){				// if needed, deal with the unlinking of each pid_data element, associated with the previously selected
+							// reg item.
+			spin_lock_bh(&exein_pid_data_access);
+			DODEBUG(KERN_INFO "ExeinLSM - PeerID: %d Tag: %d is expired.\n", reg_data->pid, reg_data->tag, reg_data->timestamp);
+			hash_for_each_rcu(pid_repo, pid_cursor, pid_data, next){ // look at the PIDs we have, if found update the ring buffer
+				DODEBUG(KERN_INFO "ExeinLSM - exein_delete_expired_regs: delete pid_data [%d]@0x%p\n", pid_data->pid,  pid_data);
+				hash_del_rcu(&pid_data->next);
+				call_rcu(&pid_data->rcu, pid_data_deferred_deletion);
+				}
+			spin_unlock_bh(&exein_pid_data_access);
+			}
+
+		}
+}
+
+int exein_send_nl_msg(void *pl, int plsize, pid_t dst_pid){
+	struct sk_buff *skb_out;
+	struct nlmsghdr *nlh;
+	int err;
+
+	DODEBUG(KERN_INFO "ExeinLSM - exein_send_nl_msg pl=%p, size=%d, PID=%d\n", pl, plsize, dst_pid);
+	skb_out = nlmsg_new(sizeof(exein_prot_reply),0); //message to notify new pid.
+	if(!skb_out) {
+		printk(KERN_INFO "ExeinLSM - Failed to allocate new skb\n");
+		return -ENOBUFS; //if this goes wrong, there's no mean in collecting data. MLE won't ask for them
+		}
+	nlh=nlmsg_put(skb_out, 0, 0, NLMSG_DONE, plsize,0);
+	if (!nlh) {
+		nlmsg_free(skb_out);
+		printk(KERN_INFO "ExeinLSM - Failed to nlmsg_put\n");
+		return -ENOBUFS; //if this goes wrong, there's no mean in collecting data. MLE won't ask for them
+		}
+	NETLINK_CB(skb_out).dst_group = 0;
+
+	memcpy(nlmsg_data(nlh), pl, plsize); //TODO: Does not check for buffer overflows when copying to destination (CWE-120). Make sure destination can always hold the source data.
+	err = netlink_unicast(exein_nl_sk_lsm, skb_out, dst_pid, MSG_DONTWAIT); // MSG_DONTWAIT=0x40  //err=nlmsg_unicast(exein_nl_sk_lsm, skb_out, reg_data->pid);
+	if (err<0) {
+		printk(KERN_INFO "ExeinLSM - Failed to send unicast netlink message p=%d, err=%d\n", dst_pid,  err);
+		} else {
+			DODEBUG(KERN_INFO "ExeinLSM - Complete to send unicast netlink message p=%d\n", dst_pid);
+			}
+	return err;
+}
+
+/*return value
+	=0 indicates no answer is needed
+	=1 indicates module must provide ok answer
+	=2 indicates module must provide ko answer
+*/
+static int exein_payload_process(void *data, pid_t pid){
+	int retval=2;
+	int bkt_cursor, pidfound;
+	exein_reg_data *reg_data, *curr_data;
+	u16 curr_tag;
+
+
+	DODEBUG(KERN_INFO "ExeinLSM - exein_payload_process data@%p, from pid=%d\n", data, pid);
+	if ((((exein_prot_req_t *)data)->key == SEEDRND)){
+		switch (((exein_prot_req_t *)data)->message_id){
+		case EXEIN_PROT_REGISTRATION_ID:
+			curr_tag = ((exein_prot_req_t *)data)->tag;
+			DODEBUG(KERN_INFO "ExeinLSM - Registration request for tag [%d] from MLE (PID %d)\n", curr_tag, pid);
+			rcu_read_lock();
+			hash_for_each_rcu(nl_peers, bkt_cursor, curr_data, next){
+				if (curr_data->tag == curr_tag){
+					DODEBUG(KERN_INFO "ExeinLSM - Tag [%d] exists!\n", curr_tag);
+					retval=2;
+					rcu_read_unlock();
+					return retval;
+					}
+				}
+			rcu_read_unlock();
+			reg_data=kmalloc(sizeof(exein_reg_data),GFP_ATOMIC);
+			reg_data->pid=pid;
+			reg_data->tag=((exein_prot_req_t *)data)->tag;
+			reg_data->timestamp=jiffies_64;
+			reg_data->seqn=0;
+			spin_lock_bh(&exein_reg_data_access);
+			hash_add_rcu(nl_peers, &reg_data->next, hash_func_4_pids(reg_data->pid) );
+			spin_unlock_bh(&exein_reg_data_access);
+#ifdef EXEIN_PRINT_DEBUG
+			rcu_read_lock();
+			hash_for_each(nl_peers, bkt_cursor, reg_data, next) printk(KERN_INFO "ExeinLSM - PeerID: %d Tag: %d @time=%llu\n", reg_data->pid, reg_data->tag, reg_data->timestamp);
+			rcu_read_unlock();
+#endif
+			retval=1;
+			break;
+		case EXEIN_PROT_KEEPALIVE_ID: //in this section, the "curr_data->timestamp" is actually written, but considering that modern processors are able to write int64 atomically, this should not concur with any race.
+			rcu_read_lock();
+			hash_for_each_possible(nl_peers, curr_data, next, hash_func_4_pids(pid) ) {
+				if ((curr_data->tag==((exein_prot_req_t *)data)->tag)){
+					curr_data->timestamp=jiffies_64;
+					DODEBUG(KERN_INFO "ExeinLSM - MLE (PID %d) for tag [%d] registration updated\n", pid, ((exein_prot_req_t *)data)->tag);
+					retval=0;
+					rcu_read_unlock();
+					return retval;
+					}
+				}
+			rcu_read_unlock();
+			DODEBUG(KERN_INFO "ExeinLSM - Unknown MLE received: (PID %d) for tag [%d]\n", pid, ((exein_prot_req_t *)data)->tag);
+			retval=0;
+			break;
+		case EXEIN_PROT_BLOCK_ID:
+			DODEBUG(KERN_INFO "ExeinLSM - Block process (%d) request for tag [%d] from MLE (PID %d)\n", ((exein_prot_req_t *)data)->pid, ((exein_prot_req_t *)data)->tag, pid);
+			exein_mark_not_trusted(((exein_prot_req_t *)data)->tag, ((exein_prot_req_t *)data)->pid);
+			retval=0;
+			break;
+		case EXEIN_PROT_DATA_REQ:
+			DODEBUG(KERN_INFO "ExeinLSM - data request from MLE (MLE_PID %d, Requested_PID=%d)\n", pid,((exein_prot_req_t *)data)->pid);
+			//look4 data in the "storage" and send it back
+			pidfound=0;
+			//for each request a message have to be send back.
+			rcu_read_lock();
+			hash_for_each(nl_peers, bkt_cursor, reg_data, next){
+				if (((exein_prot_req_t *)data)->tag==reg_data->tag) {
+					reg_data->pending_request=1;
+					}
+				}
+			rcu_read_unlock();
+			retval=0;
+			break;
+		default:
+			DODEBUG(KERN_INFO "ExeinLSM - Request about tag [%d] from MLE (PID %d) payload pid %d padding %d", ((exein_prot_req_t *)data)->tag, pid, ((exein_prot_req_t *)data)->pid, ((exein_prot_req_t *)data)->padding);
+			retval=0;
+		}
+	} else printk(KERN_INFO "ExeinLSM - Wrong key, request discarded\n");
+
+return retval;
+}
+
+static void commit_data(exein_feature_t *data, int size, uint16_t *NNInput){
+	int bkt_cursor, err, pid_cursor, i, pid_found, reg_found, pl_cursor, buf_cursor;
+	exein_reg_data *reg_data;
+	exein_pid_data *pid_data;
+	exein_prot_reply msg_rpy;
+
+#ifdef EXEIN_PRINT_DEBUG_EXTREME
+	if (data[EXEIN_PROT_TAG_POS]!=0) printk(KERN_INFO "ExeinLSM - Commit data for tag %d\n", data[5]);
+#endif
+	if (data[EXEIN_PROT_TAG_POS]!=0){
+		switch (exein_mode){
+			case EXEIN_ONREQUEST:
+				pid_found=0;
+				reg_found=0;
+				rcu_read_lock();
+				hash_for_each_rcu(nl_peers, bkt_cursor, reg_data, next){
+					if ((data[EXEIN_PROT_TAG_POS]==reg_data->tag)) {
+						reg_found=1;
+						hash_for_each_rcu(pid_repo, pid_cursor, pid_data, next){	// look at the PIDs we have, if found update the ring buffer
+							if (CURRENT_ADDR==pid_data->task_struct_addr){	//check if current is hash item corresponds to the target
+								pid_found=1;
+								break;
+								}
+							}
+						break;
+						}
+					}
+				rcu_read_unlock();
+				if (reg_found) {
+					if (pid_found) {
+						if (pid_data->in_use==1) {
+							DODEBUG(KERN_INFO "ExeinLSM[TS=%llu] - pid[%d] pid_data@0x%p produced %d hook while in use!!!!!!!!!!\n", jiffies_64, current->pid, pid_data, NNInput[EXEIN_HOOK_ID_ARG1_POS]);
+							return;
+							}
+						data[EXEIN_PROT_TAG_POS]=NNInput[EXEIN_HOOK_ID_ARG1_POS];
+//						printk(KERN_INFO "ExeinLSM - commit_data reg_found=%d, pid_found=%d, reg_data=0x%p, pid_data=0x%p\n", reg_found, pid_found, reg_data, pid_data);
+/*ATTENTION HERE*/				spin_lock_bh(&pid_data->ring_buffer_lock); //TODO: verifythe short period between the rcu_read_unlock and the spinlock do ot generates races
+						pid_data->in_use=1;
+						pid_data->index++;
+						pid_data->index&=0x7f;
+						memcpy(pid_data->hookdata[pid_data->index], data, size*sizeof(exein_feature_t));
+						spin_unlock_bh(&pid_data->ring_buffer_lock);
+						if (reg_data->pending_request==1){
+							DODEBUG(KERN_INFO "ExeinLSM - since data feed has been requested, prepare payload to send data back to registered peer\n");
+							msg_rpy.msg_type = EXEIN_PROT_FEED_ID;
+							msg_rpy.seed = SEEDRND;
+							msg_rpy.seq=(u16) reg_data->seqn++;
+							msg_rpy.pid = pid_data->pid;
+							DODEBUG(KERN_INFO "ExeinLSM - Header details: Type=%d, seed=%d, seqn=%d, objpid=%d\n", msg_rpy.msg_type, msg_rpy.seed, msg_rpy.seq, msg_rpy.pid);
+							pl_cursor=0;
+							buf_cursor=pid_data->index;
+							buf_cursor=(buf_cursor+1)&0x7f;
+/*remove*/						if (pid_data->hookdata[pid_data->index]->features[3]==0) printk(KERN_INFO "ExeinLSM - <<WARNING>> <<WARNING>> Last Hook=0 detected <<WARNING>> <<WARNING>>\n");
+
+							for (pl_cursor=0; pl_cursor<EXEIN_RINGBUFFER_SIZE; pl_cursor++){
+								*((u16 *) msg_rpy.payload+pl_cursor)=pid_data->hookdata[buf_cursor]->features[3]; //hookid
+								DODEBUG(KERN_INFO "ExeinLSM - @buf[%d]<-rbuf[%d]=%04x\n", pl_cursor, buf_cursor, pid_data->hookdata[buf_cursor]->features[3]);
+								buf_cursor=(buf_cursor+1)&0x7f;
+								}
+//remove start
+//							{
+//							int offset =0x0;
+//							printk(KERN_INFO ">%d %d %d %d  %d %d %d %d  %d %d %d %d  %d %d %d %d<\n", *((u16 *) msg_rpy.payload+offset+0x0),*((u16 *) msg_rpy.payload+offset+0x1),*((u16 *) msg_rpy.payload+offset+0x2),*((u16 *) msg_rpy.payload+offset+0x3),*((u16 *) msg_rpy.payload+offset+0x4),*((u16 *) msg_rpy.payload+offset+0x5),*((u16 *) msg_rpy.payload+offset+0x6),*((u16 *) msg_rpy.payload+offset+0x7),*((u16 *) msg_rpy.payload+offset+0x8),*((u16 *) msg_rpy.payload+offset+0x9),*((u16 *) msg_rpy.payload+offset+0xa),*((u16 *) msg_rpy.payload+offset+0xb),*((u16 *) msg_rpy.payload+offset+0xc),*((u16 *) msg_rpy.payload+offset+0xd),*((u16 *) msg_rpy.payload+offset+0xe),*((u16 *) msg_rpy.payload+offset+0xf));offset+=0x10;
+//							printk(KERN_INFO ">%d %d %d %d  %d %d %d %d  %d %d %d %d  %d %d %d %d<\n", *((u16 *) msg_rpy.payload+offset+0x0),*((u16 *) msg_rpy.payload+offset+0x1),*((u16 *) msg_rpy.payload+offset+0x2),*((u16 *) msg_rpy.payload+offset+0x3),*((u16 *) msg_rpy.payload+offset+0x4),*((u16 *) msg_rpy.payload+offset+0x5),*((u16 *) msg_rpy.payload+offset+0x6),*((u16 *) msg_rpy.payload+offset+0x7),*((u16 *) msg_rpy.payload+offset+0x8),*((u16 *) msg_rpy.payload+offset+0x9),*((u16 *) msg_rpy.payload+offset+0xa),*((u16 *) msg_rpy.payload+offset+0xb),*((u16 *) msg_rpy.payload+offset+0xc),*((u16 *) msg_rpy.payload+offset+0xd),*((u16 *) msg_rpy.payload+offset+0xe),*((u16 *) msg_rpy.payload+offset+0xf));offset+=0x10;
+//							printk(KERN_INFO ">%d %d %d %d  %d %d %d %d  %d %d %d %d  %d %d %d %d<\n", *((u16 *) msg_rpy.payload+offset+0x0),*((u16 *) msg_rpy.payload+offset+0x1),*((u16 *) msg_rpy.payload+offset+0x2),*((u16 *) msg_rpy.payload+offset+0x3),*((u16 *) msg_rpy.payload+offset+0x4),*((u16 *) msg_rpy.payload+offset+0x5),*((u16 *) msg_rpy.payload+offset+0x6),*((u16 *) msg_rpy.payload+offset+0x7),*((u16 *) msg_rpy.payload+offset+0x8),*((u16 *) msg_rpy.payload+offset+0x9),*((u16 *) msg_rpy.payload+offset+0xa),*((u16 *) msg_rpy.payload+offset+0xb),*((u16 *) msg_rpy.payload+offset+0xc),*((u16 *) msg_rpy.payload+offset+0xd),*((u16 *) msg_rpy.payload+offset+0xe),*((u16 *) msg_rpy.payload+offset+0xf));offset+=0x10;
+//							printk(KERN_INFO ">%d %d %d %d  %d %d %d %d  %d %d %d %d  %d %d %d %d<\n", *((u16 *) msg_rpy.payload+offset+0x0),*((u16 *) msg_rpy.payload+offset+0x1),*((u16 *) msg_rpy.payload+offset+0x2),*((u16 *) msg_rpy.payload+offset+0x3),*((u16 *) msg_rpy.payload+offset+0x4),*((u16 *) msg_rpy.payload+offset+0x5),*((u16 *) msg_rpy.payload+offset+0x6),*((u16 *) msg_rpy.payload+offset+0x7),*((u16 *) msg_rpy.payload+offset+0x8),*((u16 *) msg_rpy.payload+offset+0x9),*((u16 *) msg_rpy.payload+offset+0xa),*((u16 *) msg_rpy.payload+offset+0xb),*((u16 *) msg_rpy.payload+offset+0xc),*((u16 *) msg_rpy.payload+offset+0xd),*((u16 *) msg_rpy.payload+offset+0xe),*((u16 *) msg_rpy.payload+offset+0xf));offset+=0x10;
+//
+//							printk(KERN_INFO ">%d %d %d %d  %d %d %d %d  %d %d %d %d  %d %d %d %d<\n", *((u16 *) msg_rpy.payload+offset+0x0),*((u16 *) msg_rpy.payload+offset+0x1),*((u16 *) msg_rpy.payload+offset+0x2),*((u16 *) msg_rpy.payload+offset+0x3),*((u16 *) msg_rpy.payload+offset+0x4),*((u16 *) msg_rpy.payload+offset+0x5),*((u16 *) msg_rpy.payload+offset+0x6),*((u16 *) msg_rpy.payload+offset+0x7),*((u16 *) msg_rpy.payload+offset+0x8),*((u16 *) msg_rpy.payload+offset+0x9),*((u16 *) msg_rpy.payload+offset+0xa),*((u16 *) msg_rpy.payload+offset+0xb),*((u16 *) msg_rpy.payload+offset+0xc),*((u16 *) msg_rpy.payload+offset+0xd),*((u16 *) msg_rpy.payload+offset+0xe),*((u16 *) msg_rpy.payload+offset+0xf));offset+=0x10;
+//							printk(KERN_INFO ">%d %d %d %d  %d %d %d %d  %d %d %d %d  %d %d %d %d<\n", *((u16 *) msg_rpy.payload+offset+0x0),*((u16 *) msg_rpy.payload+offset+0x1),*((u16 *) msg_rpy.payload+offset+0x2),*((u16 *) msg_rpy.payload+offset+0x3),*((u16 *) msg_rpy.payload+offset+0x4),*((u16 *) msg_rpy.payload+offset+0x5),*((u16 *) msg_rpy.payload+offset+0x6),*((u16 *) msg_rpy.payload+offset+0x7),*((u16 *) msg_rpy.payload+offset+0x8),*((u16 *) msg_rpy.payload+offset+0x9),*((u16 *) msg_rpy.payload+offset+0xa),*((u16 *) msg_rpy.payload+offset+0xb),*((u16 *) msg_rpy.payload+offset+0xc),*((u16 *) msg_rpy.payload+offset+0xd),*((u16 *) msg_rpy.payload+offset+0xe),*((u16 *) msg_rpy.payload+offset+0xf));offset+=0x10;
+//							printk(KERN_INFO ">%d %d %d %d  %d %d %d %d  %d %d %d %d  %d %d %d %d<\n", *((u16 *) msg_rpy.payload+offset+0x0),*((u16 *) msg_rpy.payload+offset+0x1),*((u16 *) msg_rpy.payload+offset+0x2),*((u16 *) msg_rpy.payload+offset+0x3),*((u16 *) msg_rpy.payload+offset+0x4),*((u16 *) msg_rpy.payload+offset+0x5),*((u16 *) msg_rpy.payload+offset+0x6),*((u16 *) msg_rpy.payload+offset+0x7),*((u16 *) msg_rpy.payload+offset+0x8),*((u16 *) msg_rpy.payload+offset+0x9),*((u16 *) msg_rpy.payload+offset+0xa),*((u16 *) msg_rpy.payload+offset+0xb),*((u16 *) msg_rpy.payload+offset+0xc),*((u16 *) msg_rpy.payload+offset+0xd),*((u16 *) msg_rpy.payload+offset+0xe),*((u16 *) msg_rpy.payload+offset+0xf));offset+=0x10;
+//							printk(KERN_INFO ">%d %d %d %d  %d %d %d %d  %d %d %d %d  %d %d %d %d<\n", *((u16 *) msg_rpy.payload+offset+0x0),*((u16 *) msg_rpy.payload+offset+0x1),*((u16 *) msg_rpy.payload+offset+0x2),*((u16 *) msg_rpy.payload+offset+0x3),*((u16 *) msg_rpy.payload+offset+0x4),*((u16 *) msg_rpy.payload+offset+0x5),*((u16 *) msg_rpy.payload+offset+0x6),*((u16 *) msg_rpy.payload+offset+0x7),*((u16 *) msg_rpy.payload+offset+0x8),*((u16 *) msg_rpy.payload+offset+0x9),*((u16 *) msg_rpy.payload+offset+0xa),*((u16 *) msg_rpy.payload+offset+0xb),*((u16 *) msg_rpy.payload+offset+0xc),*((u16 *) msg_rpy.payload+offset+0xd),*((u16 *) msg_rpy.payload+offset+0xe),*((u16 *) msg_rpy.payload+offset+0xf));offset+=0x10;
+//							}
+//remove end
+							err=exein_send_nl_msg(&msg_rpy, sizeof(exein_prot_reply), reg_data->pid); //sending message to userspace that feeds hookIDs for specified PID on Registered TAG.
+							if (err<0) printk(KERN_INFO "ExeinLSM - Failed to send unicast FEED netlink message p=%d, t=%d, seq=%d err=%d\n", reg_data->pid, reg_data->tag, msg_rpy.seq, err);
+								else {
+								reg_data->pending_request=0;
+								DODEBUG(KERN_INFO "ExeinLSM - Feed sent!\n");
+								}
+							}
+						pid_data->in_use=0;
+						} else {//the PID is not found, add a buffer for it and send netlink message about the event.
+							//Setup a netlink packet and send it on the netlink connection.
+//							printk(KERN_INFO "ExeinLSM - commit_data reg_found=%d, pid_found=%d, reg_data=0x%p, pid_data=0x%p\n", reg_found, pid_found, reg_data, pid_data);
+							DODEBUG(KERN_INFO "ExeinLSM - <****> the pid %d is not there it's necessary to insert it. (index=0) <- hookid=%d\n", data[2], data[3]); //to be removed.
+							//add buffer for the new pid
+							data[EXEIN_PROT_TAG_POS]=NNInput[EXEIN_HOOK_ID_ARG1_POS];
+							pid_data=kmalloc(sizeof(exein_pid_data), GFP_ATOMIC); // TODO: consider include this into while loop to be sure memory is allocated
+							pid_data->pid=data[2];				// Issue #2 marked permanently data[2] aka current->pid as not trusted, but at this stage, it is, and there's no alternative to it.
+							pid_data->tag=reg_data->tag;
+							pid_data->index=0;
+							pid_data->task_struct_addr= CURRENT_ADDR;
+							pid_data->in_use=1;
+							spin_lock_init(&pid_data->ring_buffer_lock);
+							for (i=0; i<EXEIN_RINGBUFFER_SIZE; i++) { //allocate all buffers
+								if (!(pid_data->hookdata[i] = kzalloc(sizeof(exein_pid_data_cell), GFP_ATOMIC))){
+									panic("no memory for pid_data ring buffer target_pid=%d, pid_data=%p", data[2], pid_data);
+									}
+								}
+							memcpy(pid_data->hookdata[0], data, size*sizeof(exein_feature_t));//TODO:Does not check for buffer overflows when copying to destination (CWE-120). Make sure destination can always hold the source data.
+
+							spin_lock_bh(&exein_pid_data_access);
+							hash_add_rcu(pid_repo, &pid_data->next, hash_func_4_addrs(pid_data->task_struct_addr) );
+							spin_unlock_bh(&exein_pid_data_access);
+//							printk(KERN_INFO "ExeinLSM[TS=%llu] - pid[%d] just spawned! hookpid_data@0x%p hookNo=%d\n", jiffies_64, current->pid, pid_data, NNInput[EXEIN_HOOK_ID_ARG1_POS]);
+							trace_printk("ExeinLSM[TS=%llu] - pid[%d] just spawned! hookpid_data@0x%p hookNo=%d\n", jiffies_64, current->pid, pid_data, NNInput[EXEIN_HOOK_ID_ARG1_POS]);
+							msg_rpy.msg_type = EXEIN_PROT_NEW_PID;
+							msg_rpy.seed = SEEDRND;
+							msg_rpy.seq=(u16) reg_data->seqn++;
+							msg_rpy.pid= reg_data->pid;
+							*((pid_t *) msg_rpy.payload) = pid_data->pid; // Cannot relay on data[2] aka current->pid which issue #2 proved to be not equal to pid_data->pid.
+							DODEBUG(KERN_INFO "*** ExeinLSM - EXEIN_PROT_NEW_PID p=%d\n", pid_data->pid);
+							err=exein_send_nl_msg(&msg_rpy, sizeof(exein_prot_reply), reg_data->pid); //sending message to userspace that new pid appeared for specified tag.
+							if (err<0) printk(KERN_INFO "ExeinLSM - Failed to send unicast NEW_PID netlink message p=%d, t=%d, seq=%d err=%d\n", reg_data->pid, reg_data->tag, msg_rpy.seq, err);
+								else DODEBUG(KERN_INFO "ExeinLSM - NEW_PID Message sent\n");
+							pid_data->in_use=0;
+							}
+					}
+				break;
+			case EXEIN_LIVE:
+				rcu_read_lock();
+				hash_for_each(nl_peers, bkt_cursor, reg_data, next){
+					if ((data[EXEIN_PROT_TAG_POS]==reg_data->tag)) {
+						data[EXEIN_PROT_TAG_POS]=NNInput[EXEIN_HOOK_ID_ARG1_POS]; //tag is used no more
+						data[size++]=(u16) reg_data->seqn++;
+						err=exein_send_nl_msg(data, size<<1, reg_data->pid);
+						}
+					}
+				rcu_read_unlock();
+				break;
+			default:
+				printk(KERN_ERR "ExeinLSM - LSM is working in an unknown mode!\n");
+			}
+		}
+//#ifdef CONFIG_DUP_TS_FIND_IN_LSM
+//	do_dup_td_find(NNInput[EXEIN_HOOK_ID_ARG1_POS]);
+//#endif
+}
+
+static void exein_prepare_send_data(size_t start_index, size_t end_index, uint16_t *NNInput){
+	exein_feature_t *buffer;
+	int i, pos=0;
+
+	buffer=kmalloc(1024,GFP_ATOMIC);
+	*(buffer+(pos++))=0x7845;							//[0]           Magic Number "Ex"
+	*(buffer+(pos++))=(u16) EXEIN_NN_INPUT_SIZE;					//[1]           Size of the big input array
+	*(buffer+(pos++))=(u16) NNInput[EXEIN_HOOK_CURRENT_PROCESS_ARG1_POS];		//[2]           Current PID
+	*(buffer+(pos++))=(u16) NNInput[EXEIN_HOOK_CURRENT_PROCESS_TAG_ARG1_POS];	//[3]           Current HookID  temporary TAG
+	*(buffer+(pos++))=(u16) start_index;						//[4]           Feature data start position within the array
+	*(buffer+(pos++))=(u16) end_index;						//[5]           Feature data end position within the array
+	for (i=2; i<end_index-start_index+2;i++){					//[6]~[n - n-1] Features
+		*(buffer+(pos++))=(u16) *(NNInput+i);
+		}									//[last]            sequence number
+
+        if (NNInput[EXEIN_HOOK_ID_ARG1_POS]==0) {
+		printk(KERN_INFO "ExeinLSM - hookid=0, start=%d, end=%d, pid=[%d]\n", start_index, end_index, NNInput[EXEIN_HOOK_CURRENT_PROCESS_ARG1_POS]);
+		//dump_stack();
+		}
+	commit_data(buffer, pos, NNInput);
+	kfree(buffer);
+}
+
+void exein_delete_pids(void){ //this function is called inside /kernel/exit.c:do_exit()
+	int			err,i, bkt_cursor;
+	exein_pid_data		*pid_data;
+	exein_reg_data		*reg_data;
+	exein_prot_reply	msg_rpy;
+
+//	printk(KERN_INFO "ExeinLSM[TS=%llu] - exein_delete_pids: delete pid_data [%d]\n", jiffies_64, current->pid);
+	trace_printk("ExeinLSM[TS=%llu] - exein_delete_pids: delete pid_data [%d] l4 %x(%d)\n", jiffies_64, current->pid, CURRENT_ADDR, sizeof(CURRENT_ADDR) );
+	if ((exein_mode==EXEIN_ONREQUEST)&&(current->process_tag!=0)){
+		rcu_read_lock();
+		hash_for_each_possible_rcu(pid_repo, pid_data, next, hash_func_4_addrs(CURRENT_ADDR) ){ // look at the PIDs we have, if found update the ring buffer
+			if (CURRENT_ADDR==pid_data->task_struct_addr){
+				if (pid_data) trace_printk("ExeinLSM[TS=%llu] - exein_delete_pids(found): pid_data=(pid=%d, ts_addr=%x, tag=%d, [...])\n", jiffies_64, pid_data->pid, pid_data->task_struct_addr, pid_data->tag);
+				hash_for_each_rcu(nl_peers, bkt_cursor, reg_data, next){
+					if (pid_data->tag==reg_data->tag) {
+						printk(KERN_INFO "ExeinLSM[TS=%llu] - exein_delete_pids: PID[%d] found @0x%p owned by %d at 0x%p\n", jiffies_64, current->pid, pid_data, reg_data->pid, reg_data);
+						trace_printk("ExeinLSM[TS=%llu] - exein_delete_pids: PID[%d] found @0x%p owned by %d at 0x%p\n", jiffies_64, current->pid, pid_data, reg_data->pid, reg_data);
+						break;
+						}
+					}
+				break;
+				}
+			}
+		rcu_read_unlock();
+		if ( pid_data && reg_data){
+//			printk(KERN_INFO "ExeinLSM - exein_delete_pids: send notification to %d pid %d died\n", reg_data->pid, current->pid);
+			printk(KERN_INFO "ExeinLSM - pid=%d is no more. Send a message back to tell it pid_data=%px, reg_data=%px\n",current->pid, pid_data, reg_data);
+			pid_data->in_use=1;
+			msg_rpy.msg_type = EXEIN_PROT_DEL_PID;
+			msg_rpy.seed = SEEDRND;
+			msg_rpy.seq=(u16) reg_data->seqn++;
+			msg_rpy.pid=reg_data->pid;
+			*((pid_t *) msg_rpy.payload) = pid_data->pid;
+			err=exein_send_nl_msg(&msg_rpy, sizeof(exein_prot_reply), reg_data->pid);
+			if (err<0) printk(KERN_INFO "ExeinLSM - Failed to send unicast DEL_PID netlink message p=%d, t=%d, seq=%d err=%d\n", reg_data->pid, reg_data->tag, msg_rpy.seq, err);
+			DODEBUG("ExeinLSM - pid %d removed from storage\n", current->pid);
+			spin_lock_bh(&exein_pid_data_access);
+			hash_del_rcu(&pid_data->next);
+			spin_unlock_bh(&exein_pid_data_access);
+			call_rcu(&pid_data->rcu, pid_data_deferred_deletion);
+//			printk(KERN_INFO "ExeinLSM[TS=%llu] - exein_delete_pids: delete pid_data [%d]@0x%p<\n", jiffies_64, pid_data->pid, pid_data);
+			trace_printk("ExeinLSM[TS=%llu] - exein_delete_pids: delete pid_data [%d]@0x%p<\n", jiffies_64, pid_data->pid, pid_data);
+			} else {
+				trace_printk("ExeinLSM[TS=%llu] - exein_delete_pids: WEIRD pid_data=%px, reg_data=%px\n", jiffies_64, pid_data, reg_data);
+				if (pid_data) trace_printk("ExeinLSM[TS=%llu] - exein_delete_pids: pid_data=(pid=%d, ts_addr=%x, tag=%d, [...])\n", jiffies_64, pid_data->pid, pid_data->task_struct_addr, pid_data->tag);
+				}
+		}
+}
+
+/**********************************************************************************************************************/
+#ifdef EXEIN_CAPGET_SWITCH
+static int exein_capget(struct task_struct *target, kernel_cap_t *effective, kernel_cap_t *inheritable, kernel_cap_t *permitted )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_CAPGET_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_CAPGET_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_task_struct_to_features(target, &feature_index, NNInput);
+    exein_map_kernel_cap_t_to_features(effective, &feature_index, NNInput);
+    exein_map_kernel_cap_t_to_features(inheritable, &feature_index, NNInput);
+    exein_map_kernel_cap_t_to_features(permitted, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_CAPGET_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_CAPSET_SWITCH
+static int exein_capset(struct cred *new, const struct cred *old, const kernel_cap_t *effective, const kernel_cap_t *inheritable, const kernel_cap_t *permitted )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_CAPSET_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_CAPSET_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_cred_to_features(new, &feature_index, NNInput);
+    exein_map_cred_to_features(old, &feature_index, NNInput);
+    exein_map_kernel_cap_t_to_features(effective, &feature_index, NNInput);
+    exein_map_kernel_cap_t_to_features(inheritable, &feature_index, NNInput);
+    exein_map_kernel_cap_t_to_features(permitted, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_CAPSET_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_CAPABLE_SWITCH
+//4.14.151
+static int exein_capable(const struct cred *cred, struct user_namespace *ns, int cap, int opts )
+
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_CAPABLE_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_CAPABLE_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_cred_to_features(cred, &feature_index, NNInput);
+    exein_map_user_namespace_to_features(ns, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) cap;
+    NNInput[feature_index++] = (exein_feature_t) opts;
+    feature_index=arg1_pos+EXEIN_CAPABLE_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_BPRM_SET_CREDS_SWITCH
+static int exein_bprm_set_creds(struct linux_binprm *bprm )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_BPRM_SET_CREDS_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_BPRM_SET_CREDS_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_linux_binprm_to_features(bprm, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_BPRM_SET_CREDS_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_BPRM_CHECK_SECURITY_SWITCH
+static int exein_bprm_check_security(struct linux_binprm *bprm )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_BPRM_CHECK_SECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_BPRM_CHECK_SECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_linux_binprm_to_features(bprm, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_BPRM_CHECK_SECURITY_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_BPRM_COMMITTING_CREDS_SWITCH
+static void exein_bprm_committing_creds(struct linux_binprm *bprm )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_BPRM_COMMITTING_CREDS_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_BPRM_COMMITTING_CREDS_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_linux_binprm_to_features(bprm, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_BPRM_COMMITTING_CREDS_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_BPRM_COMMITTED_CREDS_SWITCH
+static void exein_bprm_committed_creds(struct linux_binprm *bprm )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_BPRM_COMMITTED_CREDS_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_BPRM_COMMITTED_CREDS_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_linux_binprm_to_features(bprm, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_BPRM_COMMITTED_CREDS_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_FS_CONTEXT_DUP_SWITCH
+static int exein_fs_context_dup(struct fs_context *fc, struct fs_context *src_sc )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_FS_CONTEXT_DUP_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_FS_CONTEXT_DUP_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_fs_context_to_features(fc, &feature_index, NNInput);
+    exein_map_fs_context_to_features(src_sc, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_FS_CONTEXT_DUP_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_FS_CONTEXT_PARSE_PARAM_SWITCH
+static int exein_fs_context_parse_param(struct fs_context *fc, struct fs_parameter *param )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_FS_CONTEXT_PARSE_PARAM_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_FS_CONTEXT_PARSE_PARAM_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_fs_context_to_features(fc, &feature_index, NNInput);
+    exein_map_fs_parameter_to_features(param, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_FS_CONTEXT_PARSE_PARAM_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_PATH_UNLINK_SWITCH
+static int exein_path_unlink(const struct path *dir, struct dentry *dentry )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_PATH_UNLINK_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_PATH_UNLINK_ARG1_POS;
+    size_t feature_index = 3;
+
+//    exein_map_path_to_features(dir, &feature_index, NNInput);
+//    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_PATH_UNLINK_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_PATH_MKDIR_SWITCH
+static int exein_path_mkdir(const struct path *dir, struct dentry *dentry, umode_t mode )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_PATH_MKDIR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_PATH_MKDIR_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_path_to_features(dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) mode;
+    feature_index=arg1_pos+EXEIN_PATH_MKDIR_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_PATH_RMDIR_SWITCH
+static int exein_path_rmdir(const struct path *dir, struct dentry *dentry )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_PATH_RMDIR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_PATH_RMDIR_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_path_to_features(dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_PATH_RMDIR_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_PATH_MKNOD_SWITCH
+static int exein_path_mknod(const struct path *dir, struct dentry *dentry, umode_t mode, unsigned int dev )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_PATH_MKNOD_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_PATH_MKNOD_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_path_to_features(dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) mode;
+    NNInput[feature_index++] = (exein_feature_t) dev;
+    feature_index=arg1_pos+EXEIN_PATH_MKNOD_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_PATH_TRUNCATE_SWITCH
+static int exein_path_truncate(const struct path *path )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_PATH_TRUNCATE_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_PATH_TRUNCATE_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_path_to_features(path, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_PATH_TRUNCATE_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_PATH_SYMLINK_SWITCH
+static int exein_path_symlink(const struct path *dir, struct dentry *dentry, const char *old_name )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_PATH_SYMLINK_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_PATH_SYMLINK_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_path_to_features(dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    exein_map_string_to_features(old_name, DUMMY_STRING_MAX_LENGTH ,&feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_PATH_SYMLINK_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_PATH_LINK_SWITCH
+static int exein_path_link(struct dentry *old_dentry, const struct path *new_dir, struct dentry *new_dentry )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_PATH_LINK_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_PATH_LINK_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_dentry_to_features(old_dentry, &feature_index, NNInput);
+    exein_map_path_to_features(new_dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(new_dentry, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_PATH_LINK_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_PATH_RENAME_SWITCH
+static int exein_path_rename(const struct path *old_dir, struct dentry *old_dentry, const struct path *new_dir, struct dentry *new_dentry )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_PATH_RENAME_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_PATH_RENAME_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_path_to_features(old_dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(old_dentry, &feature_index, NNInput);
+    exein_map_path_to_features(new_dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(new_dentry, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_PATH_RENAME_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_PATH_CHMOD_SWITCH
+static int exein_path_chmod(const struct path *path, umode_t mode )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_PATH_CHMOD_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_PATH_CHMOD_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_path_to_features(path, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) mode;
+    feature_index=arg1_pos+EXEIN_PATH_CHMOD_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_PATH_CHOWN_SWITCH
+static int exein_path_chown(const struct path *path, kuid_t uid, kgid_t gid )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_PATH_CHOWN_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_PATH_CHOWN_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_path_to_features(path, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) uid.val;
+    NNInput[feature_index++] = (exein_feature_t) gid.val;
+    feature_index=arg1_pos+EXEIN_PATH_CHOWN_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_PATH_CHROOT_SWITCH
+static int exein_path_chroot(const struct path *path )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_PATH_CHROOT_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_PATH_CHROOT_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_path_to_features(path, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_PATH_CHROOT_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_ALLOC_SECURITY_SWITCH
+static int exein_inode_alloc_security(struct inode *inode )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_ALLOC_SECURITY_ID;
+//    printk(KERN_INFO "EXEIN_INODE_ALLOC_SECURITY hookid=%d, pid=%d\n", NNInput[EXEIN_HOOK_ID_ARG1_POS], NNInput[EXEIN_HOOK_CURRENT_PROCESS_ARG1_POS]);
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_ALLOC_SECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(inode, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_ALLOC_SECURITY_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_FREE_SECURITY_SWITCH
+static void exein_inode_free_security(struct inode *inode )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_FREE_SECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_FREE_SECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(inode, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_FREE_SECURITY_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_INIT_SECURITY_SWITCH
+static int exein_inode_init_security(struct inode *inode, struct inode *dir, const struct qstr *qstr, const char **name, void **value, size_t *len )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_INIT_SECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_INIT_SECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(inode, &feature_index, NNInput);
+    exein_map_inode_to_features(dir, &feature_index, NNInput);
+    exein_map_qstr_to_features(qstr, &feature_index, NNInput);
+    exein_map_string_to_features(*name, DUMMY_STRING_MAX_LENGTH, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) *len;
+    feature_index=arg1_pos+EXEIN_INODE_INIT_SECURITY_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_CREATE_SWITCH
+static int exein_inode_create(struct inode *dir, struct dentry *dentry, umode_t mode )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_CREATE_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_CREATE_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) mode;
+    feature_index=arg1_pos+EXEIN_INODE_CREATE_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_LINK_SWITCH
+static int exein_inode_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_LINK_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_LINK_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_dentry_to_features(old_dentry, &feature_index, NNInput);
+    exein_map_inode_to_features(dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(new_dentry, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_LINK_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_UNLINK_SWITCH
+static int exein_inode_unlink(struct inode *dir, struct dentry *dentry )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_UNLINK_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_UNLINK_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_UNLINK_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_SYMLINK_SWITCH
+static int exein_inode_symlink(struct inode *dir, struct dentry *dentry, const char *old_name )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_SYMLINK_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_SYMLINK_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    exein_map_string_to_features(old_name, DUMMY_STRING_MAX_LENGTH, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_SYMLINK_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_MKDIR_SWITCH
+static int exein_inode_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_MKDIR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_MKDIR_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) mode;
+    feature_index=arg1_pos+EXEIN_INODE_MKDIR_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_RMDIR_SWITCH
+static int exein_inode_rmdir(struct inode *dir, struct dentry *dentry )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_RMDIR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_RMDIR_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_RMDIR_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_MKNOD_SWITCH
+static int exein_inode_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_MKNOD_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_MKNOD_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) mode;
+    NNInput[feature_index++] = (exein_feature_t) dev;
+    feature_index=arg1_pos+EXEIN_INODE_MKNOD_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_RENAME_SWITCH
+static int exein_inode_rename(struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_RENAME_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_RENAME_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(old_dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(old_dentry, &feature_index, NNInput);
+    exein_map_inode_to_features(new_dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(new_dentry, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_RENAME_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_READLINK_SWITCH
+static int exein_inode_readlink(struct dentry *dentry )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_READLINK_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_READLINK_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_READLINK_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_FOLLOW_LINK_SWITCH
+static int exein_inode_follow_link(struct dentry *dentry, struct inode *inode, bool rcu )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_FOLLOW_LINK_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_FOLLOW_LINK_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    exein_map_inode_to_features(inode, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) rcu;
+    feature_index=arg1_pos+EXEIN_INODE_FOLLOW_LINK_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_PERMISSION_SWITCH
+static int exein_inode_permission(struct inode *inode, int mask )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_PERMISSION_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_PERMISSION_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(inode, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) mask;
+    feature_index=arg1_pos+EXEIN_INODE_PERMISSION_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_SETATTR_SWITCH
+static int exein_inode_setattr(struct dentry *dentry, struct iattr *attr )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_SETATTR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_SETATTR_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    exein_map_iattr_to_features(attr, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_SETATTR_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_GETATTR_SWITCH
+static int exein_inode_getattr(const struct path *path )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_GETATTR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_GETATTR_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_path_to_features(path, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_GETATTR_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_SETATTR_SWITCH
+static int exein_inode_setxattr(struct dentry *dentry, const char *name, const void *value, size_t size, int flags )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_SETATTR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_SETATTR_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    exein_map_string_to_features(name, DUMMY_STRING_MAX_LENGTH, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) size;
+    NNInput[feature_index++] = (exein_feature_t) flags;
+    feature_index=arg1_pos+EXEIN_INODE_SETATTR_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_POST_SETXATTR_SWITCH
+static void exein_inode_post_setxattr(struct dentry *dentry, const char *name, const void *value, size_t size, int flags )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_POST_SETXATTR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_POST_SETXATTR_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    exein_map_string_to_features(name, DUMMY_STRING_MAX_LENGTH, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) size;
+    NNInput[feature_index++] = (exein_feature_t) flags;
+    feature_index=arg1_pos+EXEIN_INODE_POST_SETXATTR_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_GETATTR_SWITCH
+static int exein_inode_getxattr(struct dentry *dentry, const char *name )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_GETATTR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_GETATTR_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    exein_map_string_to_features(name, DUMMY_STRING_MAX_LENGTH, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_GETATTR_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_LISTXATTR_SWITCH
+static int exein_inode_listxattr(struct dentry *dentry )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_LISTXATTR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_LISTXATTR_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_LISTXATTR_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_REMOVEXATTR_SWITCH
+static int exein_inode_removexattr(struct dentry *dentry, const char *name )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_REMOVEXATTR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_REMOVEXATTR_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    exein_map_string_to_features(name, DUMMY_STRING_MAX_LENGTH, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_REMOVEXATTR_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_NEED_KILLPRIV_SWITCH
+static int exein_inode_need_killpriv(struct dentry *dentry )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_NEED_KILLPRIV_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_NEED_KILLPRIV_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_NEED_KILLPRIV_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_KILLPRIV_SWITCH
+static int exein_inode_killpriv(struct dentry *dentry )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_KILLPRIV_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_KILLPRIV_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_KILLPRIV_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_GETSECURITY_SWITCH
+static int exein_inode_getsecurity(struct inode *inode, const char *name, void **buffer, bool alloc )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_GETSECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_GETSECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(inode, &feature_index, NNInput);
+    exein_map_string_to_features(name, DUMMY_STRING_MAX_LENGTH, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) alloc;
+    feature_index=arg1_pos+EXEIN_INODE_GETSECURITY_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_SETSECURITY_SWITCH
+static int exein_inode_setsecurity(struct inode *inode, const char *name, const void *value, size_t size, int flags )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_SETSECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_SETSECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(inode, &feature_index, NNInput);
+    exein_map_string_to_features(name, DUMMY_STRING_MAX_LENGTH, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) size;
+    NNInput[feature_index++] = (exein_feature_t) flags;
+    feature_index=arg1_pos+EXEIN_INODE_SETSECURITY_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_LISTSECURITY_SWITCH
+static int exein_inode_listsecurity(struct inode *inode, char *buffer, size_t buffer_size )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_LISTSECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_LISTSECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(inode, &feature_index, NNInput);
+    exein_map_string_to_features(buffer, buffer_size, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_LISTSECURITY_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_GETSECID_SWITCH
+static void exein_inode_getsecid(struct inode *inode, u32 *secid )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_GETSECID_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_GETSECID_ID;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(inode, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) *secid;
+    feature_index=arg1_pos+EXEIN_INODE_GETSECID_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_COPY_UP_SWITCH
+static int exein_inode_copy_up(struct dentry *src, struct cred **new )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_COPY_UP_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_COPY_UP_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_dentry_to_features(src, &feature_index, NNInput);
+    exein_map_cred_to_features(*new, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_COPY_UP_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_COPY_UP_XATTR_SWITCH
+static int exein_inode_copy_up_xattr(const char *name )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_COPY_UP_XATTR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_COPY_UP_XATTR_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_string_to_features(name, DUMMY_STRING_MAX_LENGTH, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_COPY_UP_XATTR_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+/**
+ * exein_file_open - validate file_open calls
+ * @file: descriptor of the file
+ *
+ * stores the filename counter in the rbtree
+ * Returns 0 .
+ */
+#ifdef EXEIN_FILE_OPEN_SWITCH
+//4.14.151
+static int exein_file_open(struct file *file, const struct cred *cred)
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_FILE_OPEN_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_FILE_OPEN_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_file_to_features(file, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_FILE_OPEN_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_FILE_PERMISSION_SWITCH
+static int exein_file_permission(struct file *file, int mask)
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_FILE_PERMISSION_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_FILE_PERMISSION_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_file_to_features(file, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) mask;
+    feature_index=arg1_pos+EXEIN_FILE_PERMISSION_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_FILE_ALLOC_SECURITY_SWITCH
+static int exein_file_alloc_security(struct file *file )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_FILE_ALLOC_SECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_FILE_ALLOC_SECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_file_to_features(file, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_FILE_ALLOC_SECURITY_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_FILE_FREE_SECURITY_SWITCH
+static void exein_file_free_security(struct file *file )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_FILE_FREE_SECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_FILE_FREE_SECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_file_to_features(file, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_FILE_FREE_SECURITY_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_FILE_IOCTL_SWITCH
+static int exein_file_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_FILE_IOCTL_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_FILE_IOCTL_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_file_to_features(file, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) cmd;
+    NNInput[feature_index++] = (exein_feature_t) arg;
+    feature_index=arg1_pos+EXEIN_FILE_IOCTL_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_FILE_MPROTECT_SWITCH
+static int exein_file_mprotect(struct vm_area_struct *vma, unsigned long reqprot, unsigned long prot )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_FILE_MPROTECT_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_FILE_MPROTECT_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_vm_area_struct_to_features(vma, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) reqprot;
+    NNInput[feature_index++] = (exein_feature_t) prot;
+    feature_index=arg1_pos+EXEIN_FILE_MPROTECT_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_FILE_LOCK_SWITCH
+static int exein_file_lock(struct file *file, unsigned int cmd )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_FILE_LOCK_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_FILE_LOCK_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_file_to_features(file, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) cmd;
+    feature_index=arg1_pos+EXEIN_FILE_LOCK_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_FILE_FCNTL_SWITCH
+static int exein_file_fcntl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_FILE_FCNTL_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_FILE_FCNTL_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_file_to_features(file, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) cmd;
+    NNInput[feature_index++] = (exein_feature_t) arg;
+    feature_index=arg1_pos+EXEIN_FILE_FCNTL_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_FILE_SET_FOWNER_SWITCH
+static void exein_file_set_fowner(struct file *file )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_FILE_SET_FOWNER_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_FILE_SET_FOWNER_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_file_to_features(file, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_FILE_SET_FOWNER_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_FILE_SEND_SIGIOTASK_SWITCH
+static int exein_file_send_sigiotask(struct task_struct *tsk, struct fown_struct *fown, int sig )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_FILE_SEND_SIGIOTASK_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_FILE_SEND_SIGIOTASK_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_task_struct_to_features(tsk, &feature_index, NNInput);
+    exein_map_fown_struct_to_features(fown, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) sig;
+    feature_index=arg1_pos+EXEIN_FILE_SEND_SIGIOTASK_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_FILE_RECEIVE_SWITCH
+static int exein_file_receive(struct file *file )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_FILE_RECEIVE_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_FILE_RECEIVE_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_file_to_features(file, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_FILE_RECEIVE_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_INVALIDATE_SECCTX_SWITCH
+static void exein_inode_invalidate_secctx(struct inode *inode )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_INVALIDATE_SECCTX_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_INVALIDATE_SECCTX_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(inode, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_INVALIDATE_SECCTX_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_NOTIFYSECCTX_SWITCH
+static int exein_inode_notifysecctx(struct inode *inode, void *ctx, u32 ctxlen )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_NOTIFYSECCTX_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_NOTIFYSECCTX_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(inode, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_NOTIFYSECCTX_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_SETSECCTX_SWITCH
+static int exein_inode_setsecctx(struct dentry *dentry, void *ctx, u32 ctxlen )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_SETSECCTX_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_SETSECCTX_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_SETSECCTX_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_GETSECCTX_SWITCH
+static int exein_inode_getsecctx(struct inode *inode, void **ctx, u32 *ctxlen )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_GETSECCTX_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_GETSECCTX_ID;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(inode, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_GETSECCTX_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+/********************************************************************************************/
+
+#ifdef EXEIN_SOCKET_POST_CREATE_SWITCH
+static int exein_socket_post_create(struct socket * arg1, int arg2, int arg3, int arg4, int arg5 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_POST_CREATE_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_POST_CREATE_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_POST_CREATE_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_SOCKETPAIR_SWITCH
+static int exein_socket_socketpair(struct socket * arg1, struct socket * arg2 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_SOCKETPAIR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_SOCKETPAIR_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_SOCKETPAIR_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_BIND_SWITCH
+static int exein_socket_bind(struct socket * arg1, struct sockaddr * arg2, int arg3 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_BIND_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_BIND_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_BIND_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_CONNECT_SWITCH
+static int exein_socket_connect(struct socket * arg1, struct sockaddr * arg2, int arg3 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_CONNECT_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_CONNECT_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_CONNECT_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_LISTEN_SWITCH
+static int exein_socket_listen(struct socket * arg1, int arg2 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_LISTEN_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_LISTEN_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_LISTEN_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_ACCEPT_SWITCH
+static int exein_socket_accept(struct socket * arg1, struct socket * arg2 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_ACCEPT_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_ACCEPT_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_ACCEPT_SIZE;
+/* end ---- specific mappings*/
+
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_SENDMSG_SWITCH
+static int exein_socket_sendmsg(struct socket * arg1, struct msghdr * arg2, int arg3 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_SENDMSG_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_SENDMSG_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_SENDMSG_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_RECVMSG_SWITCH
+static int exein_socket_recvmsg(struct socket * arg1, struct msghdr * arg2, int arg3, int arg4 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_RECVMSG_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_RECVMSG_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_RECVMSG_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_GETSOCKNAME_SWITCH
+static int exein_socket_getsockname(struct socket * arg1 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_GETSOCKNAME_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_GETSOCKNAME_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_GETSOCKNAME_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_GETPEERNAME_SWITCH
+static int exein_socket_getpeername(struct socket * arg1 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_GETPEERNAME_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_GETPEERNAME_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_GETPEERNAME_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_GETSOCKOPT_SWITCH
+static int exein_socket_getsockopt(struct socket * arg1, int arg2, int arg3 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_GETSOCKOPT_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_GETSOCKOPT_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_GETSOCKOPT_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_SETSOCKOPT_SWITCH
+static int exein_socket_setsockopt(struct socket * arg1, int arg2, int arg3 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_SETSOCKOPT_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_SETSOCKOPT_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_SETSOCKOPT_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_SHUTDOWN_SWITCH
+static int exein_socket_shutdown(struct socket * arg1, int arg2 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_SHUTDOWN_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_SHUTDOWN_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_SHUTDOWN_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_SOCK_RCV_SKB_SWITCH
+static int exein_socket_sock_rcv_skb(struct sock * arg1, struct sk_buff * arg2 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_SOCK_RCV_SKB_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_SOCK_RCV_SKB_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_SOCK_RCV_SKB_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_GETPEERSEC_STREAM_SWITCH
+static int exein_socket_getpeersec_stream(struct socket * arg1, char * arg2, int * arg3, unsigned arg4 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_GETPEERSEC_STREAM_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_GETPEERSEC_STREAM_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_GETPEERSEC_STREAM_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_GETPEERSEC_DGRAM_SWITCH
+static int exein_socket_getpeersec_dgram(struct socket * arg1, struct sk_buff * arg2, u32 * arg3 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_GETPEERSEC_DGRAM_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_GETPEERSEC_DGRAM_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_GETPEERSEC_DGRAM_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SK_ALLOC_SECURITY_SWITCH
+static int exein_sk_alloc_security(struct sock * arg1, int arg2, gfp_t arg3 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SK_ALLOC_SECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SK_ALLOC_SECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SK_ALLOC_SECURITY_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SK_FREE_SECURITY_SWITCH
+static void exein_sk_free_security(struct sock * arg1 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SK_FREE_SECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SK_FREE_SECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SK_FREE_SECURITY_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SK_CLONE_SECURITY_SWITCH
+static void exein_sk_clone_security(const struct sock * arg1, struct sock * arg2 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SK_CLONE_SECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SK_CLONE_SECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SK_CLONE_SECURITY_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SK_GETSECID_SWITCH
+static void exein_sk_getsecid(struct sock * arg1, u32 * arg2 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SK_GETSECID_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SK_GETSECID_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SK_GETSECID_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_BPF_SWITCH
+static int exein_bpf(int arg1, union bpf_attr * arg2, unsigned int arg3 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_BPF_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_BPF_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_BPF_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_BPF_MAP_SWITCH
+static int exein_bpf_map(struct bpf_map * arg1, fmode_t arg2 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_BPF_MAP_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_BPF_MAP_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_BPF_MAP_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_BPF_PROG_SWITCH
+static int exein_bpf_prog(struct bpf_prog * arg1 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_BPF_PROG_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_BPF_PROG_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_BPF_PROG_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_BPF_MAP_ALLOC_SECURITY_SWITCH
+static int exein_bpf_map_alloc_security(struct bpf_map * arg1 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_BPF_MAP_ALLOC_SECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_BPF_MAP_ALLOC_SECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_BPF_MAP_ALLOC_SECURITY_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_BPF_MAP_FREE_SECURITY_SWITCH
+static void exein_bpf_map_free_security(struct bpf_map * arg1 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_BPF_MAP_FREE_SECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_BPF_MAP_FREE_SECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_BPF_MAP_FREE_SECURITY_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_BPF_PROG_ALLOC_SECURITY_SWITCH
+static int exein_bpf_prog_alloc_security(struct bpf_prog_aux * arg1 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_BPF_PROG_ALLOC_SECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_BPF_PROG_ALLOC_SECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_BPF_PROG_ALLOC_SECURITY_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_BPF_PROG_FREE_SECURITY_SWITCH
+static void exein_bpf_prog_free_security(struct bpf_prog_aux * arg1 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_BPF_PROG_FREE_SECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_BPF_PROG_FREE_SECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_BPF_PROG_FREE_SECURITY_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_ALLOC_SWITCH
+static int exein_task_alloc(struct task_struct * arg1, unsigned long arg2 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_ALLOC_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_ALLOC_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_ALLOC_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_FREE_SWITCH
+static void exein_task_free(struct task_struct * arg1 )
+{
+	exein_feature_t		NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+	NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_FREE_ID;
+	exein_map_current_to_features(NNInput);
+	size_t arg1_pos = EXEIN_TASK_FREE_ARG1_POS;
+	size_t feature_index = 3;
+/* start -- specific mappings*/ 
+	NNInput[3] = task_struct_get_pid(arg1);
+	feature_index=arg1_pos+EXEIN_TASK_FREE_SIZE;
+/* end ---- specific mappings*/
+	exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+	playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_FIX_SETUID_SWITCH
+static int exein_task_fix_setuid(struct cred * arg1, const struct cred * arg2, int arg3 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_FIX_SETUID_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_FIX_SETUID_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_FIX_SETUID_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_SETPGID_SWITCH
+static int exein_task_setpgid(struct task_struct * arg1, pid_t arg2 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_SETPGID_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_SETPGID_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_SETPGID_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_GETPGID_SWITCH
+static int exein_task_getpgid(struct task_struct * arg1 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_GETPGID_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_GETPGID_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_GETPGID_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_GETSID_SWITCH
+static int exein_task_getsid(struct task_struct * arg1 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_GETSID_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_GETSID_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_GETSID_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_GETSECID_SWITCH
+static void exein_task_getsecid(struct task_struct * arg1, u32 * arg2 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_GETSECID_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_GETSECID_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_GETSECID_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_SETNICE_SWITCH
+static int exein_task_setnice(struct task_struct * arg1, int arg2 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_SETNICE_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_SETNICE_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_SETNICE_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_SETIOPRIO_SWITCH
+static int exein_task_setioprio(struct task_struct * arg1, int arg2 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_SETIOPRIO_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_SETIOPRIO_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_SETIOPRIO_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_GETIOPRIO_SWITCH
+static int exein_task_getioprio(struct task_struct * arg1 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_GETIOPRIO_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_GETIOPRIO_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_GETIOPRIO_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_PRLIMIT_SWITCH
+static int exein_task_prlimit(const struct cred * arg1, const struct cred * arg2, unsigned int arg3 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_PRLIMIT_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_PRLIMIT_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_PRLIMIT_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_SETRLIMIT_SWITCH
+static int exein_task_setrlimit(struct task_struct * arg1, unsigned int arg2, struct rlimit * arg3 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_SETRLIMIT_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_SETRLIMIT_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_SETRLIMIT_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_SETSCHEDULER_SWITCH
+static int exein_task_setscheduler(struct task_struct * arg1 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_SETSCHEDULER_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_SETSCHEDULER_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_SETSCHEDULER_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_GETSCHEDULER_SWITCH
+static int exein_task_getscheduler(struct task_struct * arg1 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_GETSCHEDULER_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_GETSCHEDULER_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_GETSCHEDULER_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_MOVEMEMORY_SWITCH
+static int exein_task_movememory(struct task_struct * arg1 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_MOVEMEMORY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_MOVEMEMORY_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_MOVEMEMORY_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_KILL_SWITCH
+//4.14.151
+static int exein_task_kill(struct task_struct * arg1, struct siginfo * arg2, int arg3, u32 arg4 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_KILL_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_KILL_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_KILL_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_PRCTL_SWITCH
+static int exein_task_prctl(int arg1, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_PRCTL_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_PRCTL_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_PRCTL_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_TO_INODE_SWITCH
+static void exein_task_to_inode(struct task_struct * arg1, struct inode * arg2 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_TO_INODE_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_TO_INODE_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_TO_INODE_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_GETPROCATTR_SWITCH
+static int exein_getprocattr(struct task_struct * arg1, char * arg2, char ** arg3 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_GETPROCATTR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_GETPROCATTR_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_GETPROCATTR_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SETPROCATTR_SWITCH
+static int exein_setprocattr(const char * arg1, void * arg2, size_t arg3 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SETPROCATTR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SETPROCATTR_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SETPROCATTR_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+
+
+/* Hooks setup */ static struct security_hook_list exein_hooks[] __lsm_ro_after_init = {
+#ifdef EXEIN_CAPGET_SWITCH
+     LSM_HOOK_INIT(capget,                                exein_capget ),
+#endif
+#ifdef EXEIN_CAPSET_SWITCH
+     LSM_HOOK_INIT(capset,                                exein_capset ),
+#endif
+#ifdef EXEIN_CAPABLE_SWITCH
+     LSM_HOOK_INIT(capable,                               exein_capable ),
+#endif
+#ifdef EXEIN_BPRM_SET_CREDS_SWITCH
+     LSM_HOOK_INIT(bprm_set_creds,                        exein_bprm_set_creds ),
+#endif
+#ifdef EXEIN_BPRM_CHECK_SECURITY_SWITCH
+     LSM_HOOK_INIT(bprm_check_security,                   exein_bprm_check_security ),
+#endif
+#ifdef EXEIN_BPRM_COMMITTING_CREDS_SWITCH
+     LSM_HOOK_INIT(bprm_committing_creds,                 exein_bprm_committing_creds ),
+#endif
+#ifdef EXEIN_BPRM_COMMITTED_CREDS_SWITCH
+     LSM_HOOK_INIT(bprm_committed_creds,                  exein_bprm_committed_creds ),
+#endif
+#ifdef EXEIN_FS_CONTEXT_DUP_SWITCH
+     LSM_HOOK_INIT(fs_context_dup,                        exein_fs_context_dup ),
+#endif
+#ifdef EXEIN_FS_CONTEXT_PARSE_PARAM_SWITCH
+   LSM_HOOK_INIT(fs_context_parse_param,                  exein_fs_context_parse_param ),
+#endif
+#ifdef EXEIN_PATH_UNLINK_SWITCH
+     LSM_HOOK_INIT(path_unlink,                           exein_path_unlink ),
+#endif
+#ifdef EXEIN_PATH_MKDIR_SWITCH
+     LSM_HOOK_INIT(path_mkdir,                            exein_path_mkdir ),
+#endif
+#ifdef EXEIN_PATH_RMDIR_SWITCH
+     LSM_HOOK_INIT(path_rmdir,                            exein_path_rmdir ),
+#endif
+#ifdef EXEIN_PATH_MKNOD_SWITCH
+     LSM_HOOK_INIT(path_mknod,                            exein_path_mknod ),
+#endif
+#ifdef EXEIN_PATH_TRUNCATE_SWITCH
+     LSM_HOOK_INIT(path_truncate,                         exein_path_truncate ),
+#endif
+#ifdef EXEIN_PATH_SYMLINK_SWITCH
+     LSM_HOOK_INIT(path_symlink,                          exein_path_symlink ),
+#endif
+#ifdef EXEIN_PATH_LINK_SWITCH
+     LSM_HOOK_INIT(path_link,                             exein_path_link ),
+#endif
+#ifdef EXEIN_PATH_RENAME_SWITCH
+     LSM_HOOK_INIT(path_rename,                           exein_path_rename ),
+#endif
+#ifdef EXEIN_PATH_CHMOD_SWITCH
+     LSM_HOOK_INIT(path_chmod,                            exein_path_chmod ),
+#endif
+#ifdef EXEIN_PATH_CHOWN_SWITCH
+     LSM_HOOK_INIT(path_chown,                            exein_path_chown ),
+#endif
+#ifdef EXEIN_PATH_CHROOT_SWITCH
+     LSM_HOOK_INIT(path_chroot,                           exein_path_chroot ),
+#endif
+#ifdef EXEIN_INODE_ALLOC_SECURITY_SWITCH
+     LSM_HOOK_INIT(inode_alloc_security,                  exein_inode_alloc_security ),
+#endif
+#ifdef EXEIN_INODE_FREE_SECURITY_SWITCH
+     LSM_HOOK_INIT(inode_free_security,                   exein_inode_free_security ),
+#endif
+#ifdef EXEIN_INODE_INIT_SECURITY_SWITCH
+     LSM_HOOK_INIT(inode_init_security,                   exein_inode_init_security ),
+#endif
+#ifdef EXEIN_INODE_CREATE_SWITCH
+     LSM_HOOK_INIT(inode_create,                          exein_inode_create ),
+#endif
+#ifdef EXEIN_INODE_LINK_SWITCH
+     LSM_HOOK_INIT(inode_link,                            exein_inode_link ),
+#endif
+#ifdef EXEIN_INODE_UNLINK_SWITCH
+     LSM_HOOK_INIT(inode_unlink,                          exein_inode_unlink ),
+#endif
+#ifdef EXEIN_INODE_SYMLINK_SWITCH
+     LSM_HOOK_INIT(inode_symlink,                         exein_inode_symlink ),
+#endif
+#ifdef EXEIN_INODE_MKDIR_SWITCH
+     LSM_HOOK_INIT(inode_mkdir,                           exein_inode_mkdir ),
+#endif
+#ifdef EXEIN_INODE_RMDIR_SWITCH
+     LSM_HOOK_INIT(inode_rmdir,                           exein_inode_rmdir ),
+#endif
+#ifdef EXEIN_INODE_MKNOD_SWITCH
+     LSM_HOOK_INIT(inode_mknod,                           exein_inode_mknod ),
+#endif
+#ifdef EXEIN_INODE_RENAME_SWITCH
+     LSM_HOOK_INIT(inode_rename,                          exein_inode_rename ),
+#endif
+#ifdef EXEIN_INODE_READLINK_SWITCH
+     LSM_HOOK_INIT(inode_readlink,                        exein_inode_readlink ),
+#endif
+#ifdef EXEIN_INODE_FOLLOW_LINK_SWITCH
+     LSM_HOOK_INIT(inode_follow_link,                     exein_inode_follow_link ),
+#endif
+#ifdef EXEIN_INODE_PERMISSION_SWITCH
+     LSM_HOOK_INIT(inode_permission,                      exein_inode_permission ),
+#endif
+#ifdef EXEIN_INODE_SETATTR_SWITCH
+     LSM_HOOK_INIT(inode_setattr,                         exein_inode_setattr ),
+#endif
+#ifdef EXEIN_INODE_GETATTR_SWITCH
+     LSM_HOOK_INIT(inode_getattr,                         exein_inode_getattr ),
+#endif
+#ifdef EXEIN_INODE_SETXATTR_SWITCH
+     LSM_HOOK_INIT(inode_setxattr,                        exein_inode_setxattr ),
+#endif
+#ifdef EXEIN_INODE_POST_SETXATTR_SWITCH
+     LSM_HOOK_INIT(inode_post_setxattr,                   exein_inode_post_setxattr ),
+#endif
+#ifdef EXEIN_INODE_GETXATTR_SWITCH
+     LSM_HOOK_INIT(inode_getxattr,                        exein_inode_getxattr ),
+#endif
+#ifdef EXEIN_INODE_LISTXATTR_SWITCH
+     LSM_HOOK_INIT(inode_listxattr,                       exein_inode_listxattr ),
+#endif
+#ifdef EXEIN_INODE_REMOVEXATTR_SWITCH
+     LSM_HOOK_INIT(inode_removexattr,                     exein_inode_removexattr ),
+#endif
+#ifdef EXEIN_INODE_NEED_KILLPRIV_SWITCH
+     LSM_HOOK_INIT(inode_need_killpriv,                   exein_inode_need_killpriv ),
+#endif
+#ifdef EXEIN_INODE_KILLPRIV_SWITCH
+     LSM_HOOK_INIT(inode_killpriv,                        exein_inode_killpriv ),
+#endif
+#ifdef EXEIN_INODE_GETSECURITY_SWITCH
+     LSM_HOOK_INIT(inode_getsecurity,                     exein_inode_getsecurity ),
+#endif
+#ifdef EXEIN_INODE_SETSECURITY_SWITCH
+     LSM_HOOK_INIT(inode_setsecurity,                     exein_inode_setsecurity ),
+#endif
+#ifdef EXEIN_INODE_LISTSECURITY_SWITCH
+     LSM_HOOK_INIT(inode_listsecurity,                    exein_inode_listsecurity ),
+#endif
+#ifdef EXEIN_INODE_GETSECID_SWITCH
+     LSM_HOOK_INIT(inode_getsecid,                        exein_inode_getsecid ),
+#endif
+#ifdef EXEIN_INODE_COPY_UP_SWITCH
+     LSM_HOOK_INIT(inode_copy_up,                         exein_inode_copy_up ),
+#endif
+#ifdef EXEIN_INODE_COPY_UP_XATTR_SWITCH
+     LSM_HOOK_INIT(inode_copy_up_xattr,                   exein_inode_copy_up_xattr ),
+#endif
+#ifdef EXEIN_FILE_PERMISSION_SWITCH
+     LSM_HOOK_INIT(file_permission,                       exein_file_permission ),
+#endif
+#ifdef EXEIN_FILE_ALLOC_SECURITY_SWITCH
+     LSM_HOOK_INIT(file_alloc_security,                   exein_file_alloc_security ),
+#endif
+#ifdef EXEIN_FILE_FREE_SECURITY_SWITCH
+     LSM_HOOK_INIT(file_free_security,                    exein_file_free_security ),
+#endif
+#ifdef EXEIN_FILE_IOCTL_SWITCH
+     LSM_HOOK_INIT(file_ioctl,                            exein_file_ioctl ),
+#endif
+#ifdef EXEIN_FILE_MPROTECT_SWITCH
+     LSM_HOOK_INIT(file_mprotect,                         exein_file_mprotect ),
+#endif
+#ifdef EXEIN_FILE_LOCK_SWITCH
+     LSM_HOOK_INIT(file_lock,                             exein_file_lock ),
+#endif
+#ifdef EXEIN_FILE_FCNTL_SWITCH
+     LSM_HOOK_INIT(file_fcntl,                            exein_file_fcntl ),
+#endif
+#ifdef EXEIN_FILE_SET_FOWNER_SWITCH
+     LSM_HOOK_INIT(file_set_fowner,                       exein_file_set_fowner ),
+#endif
+#ifdef EXEIN_FILE_SEND_SIGIOTASK_SWITCH
+     LSM_HOOK_INIT(file_send_sigiotask,                   exein_file_send_sigiotask ),
+#endif
+#ifdef EXEIN_FILE_RECEIVE_SWITCH
+     LSM_HOOK_INIT(file_receive,                          exein_file_receive ),
+#endif
+#ifdef EXEIN_FILE_OPEN_SWITCH
+     LSM_HOOK_INIT(file_open,                             exein_file_open ),
+#endif
+#ifdef EXEIN_INODE_INVALIDATE_SECCTX_SWITCH
+     LSM_HOOK_INIT(inode_invalidate_secctx,               exein_inode_invalidate_secctx ),
+#endif
+#ifdef EXEIN_INODE_NOTIFYSECCTX_SWITCH
+     LSM_HOOK_INIT(inode_notifysecctx,                    exein_inode_notifysecctx ),
+#endif
+#ifdef EXEIN_INODE_SETSECCTX_SWITCH
+     LSM_HOOK_INIT(inode_setsecctx,                       exein_inode_setsecctx ),
+#endif
+#ifdef EXEIN_INODE_GETSECCTX_SWITCH
+     LSM_HOOK_INIT(inode_getsecctx,                       exein_inode_getsecctx ),
+#endif
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#ifdef EXEIN_SOCKET_POST_CREATE_SWITCH
+    LSM_HOOK_INIT(socket_post_create,	exein_socket_post_create ),
+#endif
+
+#ifdef EXEIN_SOCKET_SOCKETPAIR_SWITCH
+    LSM_HOOK_INIT(socket_socketpair,	exein_socket_socketpair ),
+#endif
+
+#ifdef EXEIN_SOCKET_BIND_SWITCH
+    LSM_HOOK_INIT(socket_bind,	exein_socket_bind ),
+#endif
+
+#ifdef EXEIN_SOCKET_CONNECT_SWITCH
+    LSM_HOOK_INIT(socket_connect,	exein_socket_connect ),
+#endif
+
+#ifdef EXEIN_SOCKET_LISTEN_SWITCH
+    LSM_HOOK_INIT(socket_listen,	exein_socket_listen ),
+#endif
+
+#ifdef EXEIN_SOCKET_ACCEPT_SWITCH
+    LSM_HOOK_INIT(socket_accept,	exein_socket_accept ),
+#endif
+
+#ifdef EXEIN_SOCKET_SENDMSG_SWITCH
+    LSM_HOOK_INIT(socket_sendmsg,	exein_socket_sendmsg ),
+#endif
+
+#ifdef EXEIN_SOCKET_RECVMSG_SWITCH
+    LSM_HOOK_INIT(socket_recvmsg,	exein_socket_recvmsg ),
+#endif
+
+#ifdef EXEIN_SOCKET_GETSOCKNAME_SWITCH
+    LSM_HOOK_INIT(socket_getsockname,	exein_socket_getsockname ),
+#endif
+
+#ifdef EXEIN_SOCKET_GETPEERNAME_SWITCH
+    LSM_HOOK_INIT(socket_getpeername,	exein_socket_getpeername ),
+#endif
+
+#ifdef EXEIN_SOCKET_GETSOCKOPT_SWITCH
+    LSM_HOOK_INIT(socket_getsockopt,	exein_socket_getsockopt ),
+#endif
+
+#ifdef EXEIN_SOCKET_SETSOCKOPT_SWITCH
+    LSM_HOOK_INIT(socket_setsockopt,	exein_socket_setsockopt ),
+#endif
+
+#ifdef EXEIN_SOCKET_SHUTDOWN_SWITCH
+    LSM_HOOK_INIT(socket_shutdown,	exein_socket_shutdown ),
+#endif
+
+#ifdef EXEIN_SOCKET_SOCK_RCV_SKB_SWITCH
+    LSM_HOOK_INIT(socket_sock_rcv_skb,	exein_socket_sock_rcv_skb ),
+#endif
+
+#ifdef EXEIN_SOCKET_GETPEERSEC_STREAM_SWITCH
+    LSM_HOOK_INIT(socket_getpeersec_stream,	exein_socket_getpeersec_stream ),
+#endif
+
+#ifdef EXEIN_SOCKET_GETPEERSEC_DGRAM_SWITCH
+    LSM_HOOK_INIT(socket_getpeersec_dgram,	exein_socket_getpeersec_dgram ),
+#endif
+
+#ifdef EXEIN_SK_ALLOC_SECURITY_SWITCH
+    LSM_HOOK_INIT(sk_alloc_security,	exein_sk_alloc_security ),
+#endif
+
+#ifdef EXEIN_SK_FREE_SECURITY_SWITCH
+    LSM_HOOK_INIT(sk_free_security,	exein_sk_free_security ),
+#endif
+
+#ifdef EXEIN_SK_CLONE_SECURITY_SWITCH
+    LSM_HOOK_INIT(sk_clone_security,	exein_sk_clone_security ),
+#endif
+
+#ifdef EXEIN_SK_GETSECID_SWITCH
+    LSM_HOOK_INIT(sk_getsecid,	exein_sk_getsecid ),
+#endif
+
+#ifdef EXEIN_BPF_SWITCH
+    LSM_HOOK_INIT(bpf,	exein_bpf ),
+#endif
+
+#ifdef EXEIN_BPF_MAP_SWITCH
+    LSM_HOOK_INIT(bpf_map,	exein_bpf_map ),
+#endif
+
+#ifdef EXEIN_BPF_PROG_SWITCH
+    LSM_HOOK_INIT(bpf_prog,	exein_bpf_prog ),
+#endif
+
+#ifdef EXEIN_BPF_MAP_ALLOC_SECURITY_SWITCH
+    LSM_HOOK_INIT(bpf_map_alloc_security,	exein_bpf_map_alloc_security ),
+#endif
+
+#ifdef EXEIN_BPF_MAP_FREE_SECURITY_SWITCH
+    LSM_HOOK_INIT(bpf_map_free_security,	exein_bpf_map_free_security ),
+#endif
+
+#ifdef EXEIN_BPF_PROG_ALLOC_SECURITY_SWITCH
+    LSM_HOOK_INIT(bpf_prog_alloc_security,	exein_bpf_prog_alloc_security ),
+#endif
+
+#ifdef EXEIN_BPF_PROG_FREE_SECURITY_SWITCH
+    LSM_HOOK_INIT(bpf_prog_free_security,	exein_bpf_prog_free_security ),
+#endif
+
+#ifdef EXEIN_TASK_ALLOC_SWITCH
+    LSM_HOOK_INIT(task_alloc,	exein_task_alloc ),
+#endif
+
+#ifdef EXEIN_TASK_FREE_SWITCH
+    LSM_HOOK_INIT(task_free,	exein_task_free ),
+#endif
+
+#ifdef EXEIN_TASK_FIX_SETUID_SWITCH
+    LSM_HOOK_INIT(task_fix_setuid,	exein_task_fix_setuid ),
+#endif
+
+#ifdef EXEIN_TASK_SETPGID_SWITCH
+    LSM_HOOK_INIT(task_setpgid,	exein_task_setpgid ),
+#endif
+
+#ifdef EXEIN_TASK_GETPGID_SWITCH
+    LSM_HOOK_INIT(task_getpgid,	exein_task_getpgid ),
+#endif
+
+#ifdef EXEIN_TASK_GETSID_SWITCH
+    LSM_HOOK_INIT(task_getsid,	exein_task_getsid ),
+#endif
+
+#ifdef EXEIN_TASK_GETSECID_SWITCH
+    LSM_HOOK_INIT(task_getsecid,	exein_task_getsecid ),
+#endif
+
+#ifdef EXEIN_TASK_SETNICE_SWITCH
+    LSM_HOOK_INIT(task_setnice,	exein_task_setnice ),
+#endif
+
+#ifdef EXEIN_TASK_SETIOPRIO_SWITCH
+    LSM_HOOK_INIT(task_setioprio,	exein_task_setioprio ),
+#endif
+
+#ifdef EXEIN_TASK_GETIOPRIO_SWITCH
+    LSM_HOOK_INIT(task_getioprio,	exein_task_getioprio ),
+#endif
+
+#ifdef EXEIN_TASK_PRLIMIT_SWITCH
+    LSM_HOOK_INIT(task_prlimit,	exein_task_prlimit ),
+#endif
+
+#ifdef EXEIN_TASK_SETRLIMIT_SWITCH
+    LSM_HOOK_INIT(task_setrlimit,	exein_task_setrlimit ),
+#endif
+
+#ifdef EXEIN_TASK_SETSCHEDULER_SWITCH
+    LSM_HOOK_INIT(task_setscheduler,	exein_task_setscheduler ),
+#endif
+
+#ifdef EXEIN_TASK_GETSCHEDULER_SWITCH
+    LSM_HOOK_INIT(task_getscheduler,	exein_task_getscheduler ),
+#endif
+
+#ifdef EXEIN_TASK_MOVEMEMORY_SWITCH
+    LSM_HOOK_INIT(task_movememory,	exein_task_movememory ),
+#endif
+
+#ifdef EXEIN_TASK_KILL_SWITCH
+    LSM_HOOK_INIT(task_kill,	exein_task_kill ),
+#endif
+
+#ifdef EXEIN_TASK_PRCTL_SWITCH
+    LSM_HOOK_INIT(task_prctl,	exein_task_prctl ),
+#endif
+
+#ifdef EXEIN_TASK_TO_INODE_SWITCH
+    LSM_HOOK_INIT(task_to_inode,	exein_task_to_inode ),
+#endif
+
+#ifdef EXEIN_GETPROCATTR_SWITCH
+    LSM_HOOK_INIT(getprocattr,	exein_getprocattr ),
+#endif
+
+#ifdef EXEIN_SETPROCATTR_SWITCH
+    LSM_HOOK_INIT(setprocattr,	exein_setprocattr ),
+#endif
+};
+
+static int __init exein_init(void)
+{
+	pr_info("ExeinLSM - lsm is active: seed [%d]\n",SEEDRND);
+        exein_payload_process_ptr	=	&exein_payload_process;
+	exein_register_status_get_ptr	=	&exein_register_status_get;
+	exein_pid_status_get_ptr	=	&exein_pid_status_get;
+	security_add_hooks(exein_hooks, ARRAY_SIZE(exein_hooks), "exein");
+	hash_init(nl_peers);
+	hash_init(pid_repo);
+	return 0;
+}
+
+//4.14.151
+security_initcall(exein_init);
+
+//5.1.11
+// DEFINE_LSM(exein) = {
+// 	.name = "exein",
+// 	.init = exein_init,
+// };
--- a/security/exein/exein_trust.c
+++ b/security/exein/exein_trust.c
@@ -0,0 +1,13 @@
+#include <linux/slab.h>
+#include <linux/gfp.h>
+#include "exein_types.h"
+#include "exein_trust.h"
+#include <linux/sched/signal.h>
+
+void exein_mark_not_trusted(uint16_t tag, pid_t pid){
+	int ret = kill_pid(find_vpid(pid), SIGKILL, 1);
+	if (ret < 0) {
+		printk(KERN_INFO "error kill pid\n");
+		}
+	printk(KERN_CRIT "EXEIN MARKED PROCESS AS NOT TRUSTED [tag:%d pid:%d]\n", tag, pid);
+}
--- a/security/exein/exein_print_level.h
+++ b/security/exein/exein_print_level.h
@@ -0,0 +1,6 @@
+/*
+    KERN_DEBUG   won't show on console
+    KERN_INFO    will print everything on console by default
+*/
+
+#define EXEIN_PRINT_LEVEL KERN_INFO
--- a/security/exein/eval_p_sym.h
+++ b/security/exein/eval_p_sym.h
@@ -0,0 +1,82 @@
+#if EVALUATE_ ==0
+#pragma message (SYMNAME "= 0")
+#elif EVALUATE_ ==1
+#pragma message (SYMNAME "= 1")
+#elif EVALUATE_ ==2
+#pragma message (SYMNAME "= 2")
+#elif EVALUATE_ ==3
+#pragma message (SYMNAME "= 3")
+#elif EVALUATE_ ==4
+#pragma message (SYMNAME "= 4")
+#elif EVALUATE_ ==5
+#pragma message (SYMNAME "= 5")
+#elif EVALUATE_ ==6
+#pragma message (SYMNAME "= 6")
+#elif EVALUATE_ ==7
+#pragma message (SYMNAME "= 7")
+#elif EVALUATE_ ==8
+#pragma message (SYMNAME "= 8")
+#elif EVALUATE_ ==9
+#pragma message (SYMNAME "= 9")
+#elif EVALUATE_ ==10
+#pragma message (SYMNAME "= 10")
+#elif EVALUATE_ ==11
+#pragma message (SYMNAME "= 11")
+#elif EVALUATE_ ==12
+#pragma message (SYMNAME "= 12")
+#elif EVALUATE_ ==13
+#pragma message (SYMNAME "= 13")
+#elif EVALUATE_ ==14
+#pragma message (SYMNAME "= 14")
+#elif EVALUATE_ ==15
+#pragma message (SYMNAME "= 15")
+#elif EVALUATE_ ==16
+#pragma message (SYMNAME "= 16")
+#elif EVALUATE_ ==17
+#pragma message (SYMNAME "= 17")
+#elif EVALUATE_ ==18
+#pragma message (SYMNAME "= 18")
+#elif EVALUATE_ ==19
+#pragma message (SYMNAME "= 19")
+#elif EVALUATE_ ==10
+#pragma message (SYMNAME "= 10")
+#elif EVALUATE_ ==21
+#pragma message (SYMNAME "= 21")
+#elif EVALUATE_ ==22
+#pragma message (SYMNAME "= 22")
+#elif EVALUATE_ ==23
+#pragma message (SYMNAME "= 23")
+#elif EVALUATE_ ==24
+#pragma message (SYMNAME "= 24")
+#elif EVALUATE_ ==25
+#pragma message (SYMNAME "= 25")
+#elif EVALUATE_ ==26
+#pragma message (SYMNAME "= 26")
+#elif EVALUATE_ ==27
+#pragma message (SYMNAME "= 27")
+#elif EVALUATE_ ==28
+#pragma message (SYMNAME "= 28")
+#elif EVALUATE_ ==29
+#pragma message (SYMNAME "= 29")
+
+#elif EVALUATE_ ==30
+#pragma message (SYMNAME "= 30")
+#elif EVALUATE_ ==31
+#pragma message (SYMNAME "= 31")
+#elif EVALUATE_ ==32
+#pragma message (SYMNAME "= 32")
+#elif EVALUATE_ ==33
+#pragma message (SYMNAME "= 33")
+#elif EVALUATE_ ==34
+#pragma message (SYMNAME "= 34")
+#elif EVALUATE_ ==35
+#pragma message (SYMNAME "= 35")
+#elif EVALUATE_ ==36
+#pragma message (SYMNAME "= 36")
+#elif EVALUATE_ ==37
+#pragma message (SYMNAME "= 37")
+#elif EVALUATE_ ==38
+#pragma message (SYMNAME "= 38")
+#elif EVALUATE_ ==39
+#pragma message (SYMNAME "= 39")
+#endif
--- a/security/exein/exein_struct_mappings.h
+++ b/security/exein/exein_struct_mappings.h
@@ -0,0 +1,44 @@
+#include <linux/types.h>
+#include <linux/cred.h>             // cred
+#include <linux/fs.h>               // fown_struct, iattr,
+#include <linux/binfmts.h>          // linux_binprm
+#include <linux/user_namespace.h>
+#include <linux/mount.h>            // vfsmount
+#include <linux/sched.h>
+//5.1.11
+//#include <linux/fs_context.h>       // fs_context, fs_parameter
+#include <linux/capability.h>       //  kernel_cap_struct
+#include <linux/path.h>             // path
+#include <linux/uidgid.h>           // kuid_t
+
+//4.14.151
+#include <linux/sem.h>           // sem_array
+#include "../../kernel/audit.h"
+
+#include "exein_types.h"
+#include "exein_nn_defs.h"
+#include "exein_print_level.h"
+
+#define PARSE_STRINGS 0
+#define DUMMY_STRING_MAX_LENGTH 10
+
+uint16_t task_struct_get_pid(struct task_struct *arg1);
+void exein_map_current_to_features(exein_feature_t* features_arr);
+
+void exein_map_string_to_features(const char* string,   size_t string_max_length,   size_t* index_p,   exein_feature_t* features_arr);
+
+void exein_map_cred_to_features(            const struct cred* input,               size_t* index_p,   exein_feature_t* features_arr);
+void exein_map_fown_struct_to_features(     const struct fown_struct* input,        size_t* index_p,   exein_feature_t* features_arr);
+void exein_map_iattr_to_features(           const struct iattr* input,              size_t* index_p,   exein_feature_t* features_arr);
+void exein_map_user_namespace_to_features(  const struct user_namespace* input,     size_t* index_p,   exein_feature_t* features_arr);
+void exein_map_vm_area_struct_to_features(  const struct vm_area_struct* input,     size_t* index_p,   exein_feature_t* features_arr);
+void exein_map_task_struct_to_features(     const struct task_struct* input,        size_t* index_p,   exein_feature_t* features_arr);
+//void exein_map_fs_context_to_features(      const struct fs_context* input,         size_t* index_p,   exein_feature_t* features_arr);
+void exein_map_inode_to_features(           const struct inode* input,              size_t* index_p,   exein_feature_t* features_arr);
+void exein_map_dentry_to_features(          const struct dentry* input,             size_t* index_p,   exein_feature_t* features_arr);
+void exein_map_file_to_features(            const struct file* input,               size_t* index_p,   exein_feature_t* features_arr);
+void exein_map_kernel_cap_t_to_features(    const struct kernel_cap_struct* input,  size_t* index_p,   exein_feature_t* features_arr);
+void exein_map_linux_binprm_to_features(    const struct linux_binprm* input,       size_t* index_p,   exein_feature_t* features_arr);
+//void exein_map_fs_parameter_to_features(    const struct fs_parameter* input,       size_t* index_p,   exein_feature_t* features_arr);
+void exein_map_path_to_features(            const struct path* input,               size_t* index_p,   exein_feature_t* features_arr);
+void exein_map_qstr_to_features(            const struct qstr* input,               size_t* index_p,   exein_feature_t* features_arr);
--- a/security/exein/exein_nn_main.h
+++ b/security/exein/exein_nn_main.h
@@ -0,0 +1,5 @@
+#include "exein_types.h"
+#include "exein_nn_defs_parts.h"
+#include "exein_nn_defs.h" // Autogenerated file
+
+int playnn(exein_feature_t *NNInput);
--- a/security/exein/Makefile
+++ b/security/exein/Makefile
@@ -0,0 +1,46 @@
+obj-$(CONFIG_SECURITY_EXEIN) := exein.o
+exein-y := exein_lsm.o exein_nn_main.o exein_struct_mappings.o exein_trust.o
+ccflags-y := -Wno-declaration-after-statement -Wno-unused-function
+
+$(addprefix $(obj)/,$(exein-y)): $(obj)/exein_nn_defs.h
+$(addprefix $(obj)/,$(exein-y)): $(obj)/mkHookh_data/hooks.csv
+$(addprefix $(obj)/,$(exein-y)): $(obj)/mkHookh_data/hookspart.ini
+$(addprefix $(obj)/,$(exein-y)): $(obj)/exein_nn_defs_comp.h
+
+quiet_cmd_mkHooksh = GENH	$(srctree)/exein_nn_defs.h
+	cmd_mkHooksh = $(obj)/../../scripts/exein/mkHookh/mkHookh $(obj)/mkHookh_data/hooks.ini $(obj)/mkHookh_data/config.ini Y >$(srctree)/security/exein/exein_nn_defs.h && chmod +x $(srctree)/scripts/exein/make_define_aliases.sh && $(srctree)/scripts/exein/make_define_aliases.sh >>$(srctree)/security/exein/exein_nn_defs.h
+
+quiet_cmd_mkHookhcomp = GENH	$(srctree)/exein_nn_defs_comp.h
+	cmd_mkHookhcomp = $(obj)/../../scripts/exein/mkHookhcomp/mkHookhcomp $(obj)/mkHookh_data/hookspart.ini $(obj)/mkHookh_data/config.ini >$(srctree)/security/exein/exein_nn_defs_comp.h
+
+quiet_cmd_csv2ini = MKINI	$(obj)/mkHookh_data/hookspart.ini
+	cmd_csv2ini = chmod +x $(srctree)/scripts/exein/csv2ini.sh && $(srctree)/scripts/exein/csv2ini.sh $(obj)/mkHookh_data/hooks.csv >$(obj)/mkHookh_data/hookspart.ini
+
+quiet_cmd_HeaderParser = PARSE	$(obj)/mkHookh_data/hooks.csv
+	cmd_HeaderParser = $(obj)/../../scripts/exein/HeaderParser/HeaderParser < $(srctree)/include/linux/lsm_hooks.h >$(obj)/mkHookh_data/hooks.csv
+
+
+
+targets += exein_nn_defs.h
+targets += hooks.csv
+targets += hookspart.ini
+targets += exein_nn_defs_comp.h
+
+$(obj)/exein_nn_defs_comp.h: $(obj)/mkHookh_data/hookspart.ini
+	$(call if_changed,mkHookhcomp)
+
+$(obj)/exein_nn_defs.h: FORCE
+ifeq ($(wildcard $(obj)/mkHookh_data/.),)
+	cp -r $(srctree)/security/exein/mkHookh_data/ $(obj)
+endif
+	$(call if_changed,mkHooksh)
+
+$(obj)/mkHookh_data/hookspart.ini: $(obj)/mkHookh_data/hooks.csv
+	$(call if_changed,csv2ini)
+
+$(obj)/mkHookh_data/hooks.csv: FORCE
+	$(call if_changed,HeaderParser)
+
+$(obj)/exein_nn_defs.h: FORCE
+
+FORCE: ;
--- a/security/exein/exein_struct_mappings.c
+++ b/security/exein/exein_struct_mappings.c
@@ -0,0 +1,270 @@
+#include "exein_struct_mappings.h"
+#include "exein_nn_defs_parts.h"
+
+
+
+uint16_t task_struct_get_pid(struct task_struct *arg1){
+	return arg1->pid;
+}
+
+void exein_map_string_to_features(const char * input, size_t string_length, size_t* index_p, exein_feature_t* features_arr){
+    if(input == NULL){
+        (*index_p)+=string_length;
+        return;
+    }
+
+    #if PARSE_STRINGS > 0
+        size_t i;
+        for (i = 0; i < string_length; i++)
+        {
+            features_arr[(*index_p)++] = input[i];
+        }
+    #endif
+}
+
+
+void exein_map_cred_to_features(const struct cred* input, size_t* index_p, exein_feature_t* features_arr){
+    /* Cred structure */
+    if(input == NULL){
+        (*index_p)+=STRUCT_CRED;
+        return;
+    }
+
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).uid.val;       /* real UID of the task */
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).gid.val;       /* real GID of the task */
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).suid.val;      /* saved UID of the task */
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).sgid.val;      /* saved GID of the task */
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).euid.val;      /* effective UID of the task */
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).egid.val;      /* effective GID of the task */
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).fsuid.val;     /* UID for VFS ops */
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).fsgid.val;     /* GID for VFS ops */
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).securebits;    /* SUID-less security management */
+}
+
+
+void exein_map_fown_struct_to_features(const struct fown_struct* input, size_t* index_p, exein_feature_t* features_arr){
+    /* Fown structure */
+    if(input == NULL){
+        (*index_p)+=STRUCT_FOWN_STRUCT;
+        return;
+    }
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).euid.val;
+}
+
+
+void exein_map_iattr_to_features(const struct iattr* input, size_t* index_p, exein_feature_t* features_arr){
+    /* Inode Attributes structure */
+    if(input == NULL){
+        (*index_p)+=STRUCT_IATTR;
+        return;
+    }
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).ia_valid;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).ia_mode;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).ia_uid.val;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).ia_gid.val;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).ia_size;
+}
+
+
+void exein_map_user_namespace_to_features(const struct user_namespace* input, size_t* index_p, exein_feature_t* features_arr){
+    /* User Namespace structure */
+    if(input == NULL){
+        (*index_p)+=STRUCT_USER_NAMESPACE;
+        return;
+    }
+
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).owner.val;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).group.val;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).flags;
+}
+
+
+void exein_map_vm_area_struct_to_features(const struct vm_area_struct * input, size_t* index_p, exein_feature_t* features_arr){
+    /* VM Area structure */
+    if(input == NULL){
+        (*index_p)+=STRUCT_VM_AREA_STRUCT;
+        return;
+    }
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_start;                  /* Start address within vm_mm. */
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_end;                    /* The first byte after the end address within vm_mm. */
+    //features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_page_prot.pgprot;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_flags;                  /* Flags: https://elixir.bootlin.com/linux/v5.1.11/source/include/linux/mm.h#L197 */
+
+    if(input->vm_mm == NULL){
+        (*index_p)+=STRUCT_VM_AREA_STRUCT-4;
+        return;
+    }
+    //features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->pgd->pgd;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->mm_users.counter;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->data_vm;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->exec_vm;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->stack_vm;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->def_flags;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->start_code;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->start_data;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->end_data;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->start_brk;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->brk;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->start_stack;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->arg_end;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->env_start;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->env_end;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->def_flags;
+}
+
+void exein_map_task_struct_to_features(const struct task_struct* input, size_t* index_p, exein_feature_t* features_arr){
+    /* Task structure */
+
+    /*
+        This is one of the most complex structures
+        Deeper analysis is needed
+    */
+
+    if(input == NULL){
+        (*index_p)+=STRUCT_TASK_STRUCT;
+        return;
+    }
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).flags;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).ptrace;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).pdeath_signal;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).in_execve;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).pid;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).tgid;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).stack;
+    //4.14.151
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).usage.counter;    /* indicates how many object are referencing this task */
+	  features_arr[(*index_p)++] = (exein_feature_t) (*input).static_prio;           /* static_prio is the starting priority which is not affected by the scheduler dynamics */
+    //features_arr[(*index_p)++] = (exein_feature_t) (*input).thread_pid->count.counter;
+
+    // TODO: Map the whole path?
+    // target->nameidata->path
+
+    // TODO: Map the whole inode struct?
+    // target->nameidata->inode
+
+    // TODO: Map the whole cred struct?
+    // input->cred->euid.val         /* effective process uid */
+
+}
+
+
+void exein_map_current_to_features(exein_feature_t* features_arr){
+    /* Identify current process */
+    /* Current is just an instance of strcut task_struct */
+    /* How to get the process name : https://stackoverflow.com/questions/5406942/linux-get-process-name-from-pid-within-kernel */
+    int index = EXEIN_HOOK_CURRENT_PROCESS_ARG1_POS;
+    features_arr[index++]  = (exein_feature_t) current->pid;
+    features_arr[index]  = (exein_feature_t) current->process_tag;
+
+}
+
+
+void exein_map_inode_to_features(const struct inode *input, size_t* index_p, exein_feature_t* features_arr){
+    /* Inode structure */
+    if(input == NULL){
+        (*index_p)+=STRUCT_INODE;
+        return;
+    }
+
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).i_mode;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).i_opflags;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).i_uid.val;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).i_gid.val;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).i_flags;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).i_size;        /* Filesize */
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).i_ino;         /* Inode number */
+}
+
+
+void exein_map_dentry_to_features(const struct dentry *input, size_t* index_p, exein_feature_t* features_arr){
+    /* Dentry structure */
+    if(input == NULL){
+        (*index_p)+=STRUCT_DENTRY;
+        return;
+    }
+
+    //printk(EXEIN_PRINT_LEVEL "MAP dentry to features disabled\n");
+
+    // TODO:  Map the d_name qstr to features
+    // input->d_name;  // this is a struct qstr (quickstring)
+                    // it contains not only the dentry name but also the hash. Which is better in our case
+    // In case we use the full name : exein_map_string_to_features(fullname, 768, index_p, features_arr);
+
+    exein_map_inode_to_features((*input).d_inode, index_p, features_arr);
+}
+
+
+void exein_map_file_to_features(const struct file *input, size_t* index_p, exein_feature_t* features_arr){
+    /* File structure */
+    if(input == NULL){
+        (*index_p)+=STRUCT_FILE;
+        return;
+    }
+
+    exein_map_dentry_to_features((*input).f_path.dentry, index_p, features_arr);
+
+    exein_map_inode_to_features((*input).f_inode, index_p, features_arr);
+
+    exein_map_fown_struct_to_features(&(*input).f_owner, index_p, features_arr);
+
+    u_int32_t trustworthiness = 0;
+
+    // Check if the file has a mnt
+    if (input->f_path.mnt != NULL)
+    {
+        // trustworthiness
+        char buffer[150];
+        char *path;
+
+        //printk(EXEIN_PRINT_LEVEL "MAP dentry path is not implemented [!]\n");
+        // path = dentry_path_raw(input->f_path.mnt->mnt_root, buffer, 150);
+        // if (strcmp("/", path) == 0 ) trustworthiness+=10;
+        // if (strcmp("squashfs",  input->f_path.mnt->mnt_sb->s_type->name) == 0 ) trustworthiness+=5;
+        // if (strcmp("rootfs",    input->f_path.mnt->mnt_sb->s_type->name) == 0 ) trustworthiness+=5;
+        // if (strcmp("cramfs",    input->f_path.mnt->mnt_sb->s_type->name) == 0 ) trustworthiness+=5;
+    }
+
+    features_arr[(*index_p)++] = (exein_feature_t) trustworthiness;
+
+    // features_arr[(*index_p)++] = (exein_feature_t) djb2(input); // Simple hash of the name
+
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).f_flags;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).f_mode;
+}
+
+
+void exein_map_kernel_cap_t_to_features(const struct kernel_cap_struct* input, size_t* index_p, exein_feature_t* features_arr){
+    if(input == NULL){
+        (*index_p)+=KERNEL_CAP_T;
+        return;
+    }
+
+    size_t i;
+    for (i = 0; i < KERNEL_CAP_T; i++)
+    {
+        features_arr[(*index_p)++] = (exein_feature_t) (*input).cap[i];
+    }
+}
+
+
+void exein_map_linux_binprm_to_features(const struct linux_binprm *input, size_t* index_p, exein_feature_t* features_arr){
+    //printk(EXEIN_PRINT_LEVEL "MAP linux_binprm to features not implemented\n");
+}
+
+//4.14.151
+// void exein_map_fs_parameter_to_features(const struct fs_parameter *input, size_t* index_p, exein_feature_t* features_arr){
+//     printk(EXEIN_PRINT_LEVEL "MAP fs_parameter to features not implemented\n");
+// }
+
+
+void exein_map_path_to_features(const struct path *input, size_t* index_p, exein_feature_t* features_arr){
+    //printk(EXEIN_PRINT_LEVEL "MAP path to features not implemented\n");
+}
+
+
+void exein_map_qstr_to_features(const struct qstr *input, size_t* index_p, exein_feature_t* features_arr){
+    //printk(EXEIN_PRINT_LEVEL "MAP qstr to features not implemented\n");
+}
+
+//4.14.151
+//void exein_map_fs_context_to_features(const struct fs_context * input, size_t* index_p, exein_feature_t* features_arr){}
--- a/security/exein/exein_lsm.h
+++ b/security/exein/exein_lsm.h
@@ -0,0 +1,83 @@
+#include <linux/types.h>
+#include <linux/hashtable.h>
+#include <linux/spinlock_types.h>
+#define EXEIN_REG_DURATION		2500
+#define EXEIN_PROT_REGISTRATION_ID	1
+#define EXEIN_PROT_KEEPALIVE_ID		2
+#define EXEIN_PROT_FEED_ID		3
+#define EXEIN_PROT_BLOCK_ID		4
+#define EXEIN_PROT_DATA_REQ		5
+#define EXEIN_PROT_NEW_PID		6
+#define EXEIN_PROT_DEL_PID		7
+#define EXEIN_PID_POS			1
+#define EXEIN_NN_MAX_SIZE		50
+#define EXEIN_RINGBUFFER_SIZE		(1<<7)
+#define EXEIN_FEATURE_NUM_MAX		35
+#define HASHTABLE_BITS			5
+
+#define EXEIN_ONREQUEST			0x80
+#define EXEIN_LIVE			0x81
+
+#ifdef EXEIN_PRINT_DEBUG
+#define DODEBUG( ... ) printk( __VA_ARGS__ );
+#else
+#define DODEBUG( ... ) do { } while(0)
+#endif
+
+#ifdef __LP64__
+#define CURRENT_ADDR ((u64) current)
+#define PTRSIZE u64
+#else
+#define CURRENT_ADDR ((u32) current)
+#define PTRSIZE u32
+#endif
+
+typedef struct {
+        u32			key;
+        u8			message_id;
+        u8			padding;
+        u16			tag;
+        pid_t			pid;
+} exein_prot_req_t;
+
+typedef struct {
+	u16			tag;
+	u64			timestamp;
+	pid_t			pid;
+	uint16_t		pending_request;
+	u16			seqn;
+	struct hlist_node	next;
+	struct rcu_head         rcu;
+} exein_reg_data;
+
+void exein_delete_expired_regs(void);
+
+typedef struct {
+	u16			features[EXEIN_FEATURE_NUM_MAX];
+} exein_pid_data_cell;
+
+typedef struct {
+	pid_t			pid;
+#ifdef __LP64__
+	u64			task_struct_addr;
+#else
+	u32			task_struct_addr;
+#endif
+	u16			tag;
+	exein_pid_data_cell	*hookdata[EXEIN_RINGBUFFER_SIZE];
+	spinlock_t 		ring_buffer_lock;
+	int			index;
+	int			in_use;
+	struct hlist_node	next;
+	struct rcu_head		rcu;
+} exein_pid_data;
+
+typedef struct {
+	u16			msg_type;
+	u32			seed;
+	u16			seq;
+	pid_t			pid;
+	u16			payload[EXEIN_RINGBUFFER_SIZE];
+} exein_prot_reply;
+
+
--- a/security/exein/exein_nn_models.h
+++ b/security/exein/exein_nn_models.h
@@ -0,0 +1,308 @@
+int models [16][256]={
+/* 0 */ {
+//              0           1           2           3           4           5           6           7           8           9           A           B           C           D           E           R
+/* 0 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 1 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 2 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 3 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 4 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 5 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 6 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 7 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 8 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 9 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* A */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* B */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* C */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* D */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* E */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* F */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+         },
+/* 1 */ {
+//              0           1           2           3           4           5           6           7           8           9           A           B           C           D           E           R
+/* 0 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 1 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 2 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 3 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 4 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 5 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 6 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 7 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 8 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 9 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* A */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* B */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* C */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* D */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* E */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* F */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+        },
+/* 2 */ {
+//              0           1           2           3           4           5           6           7           8           9           A           B           C           D           E           R
+/* 0 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 1 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 2 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 3 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 4 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 5 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 6 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 7 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 8 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 9 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* A */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* B */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* C */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* D */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* E */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* F */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+        },
+/* 3 */ {
+//              0           1           2           3           4           5           6           7           8           9           A           B           C           D           E           R
+/* 0 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 1 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 2 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 3 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 4 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 5 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 6 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 7 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 8 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 9 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* A */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* B */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* C */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* D */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* E */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* F */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+        },
+/* 4 */ {
+//              0           1           2           3           4           5           6           7           8           9           A           B           C           D           E           R
+/* 0 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 1 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 2 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 3 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 4 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 5 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 6 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 7 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 8 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 9 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* A */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* B */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* C */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* D */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* E */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* F */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+        },
+/* 5 */ {
+//              0           1           2           3           4           5           6           7           8           9           A           B           C           D           E           R
+/* 0 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 1 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 2 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 3 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 4 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 5 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 6 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 7 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 8 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 9 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* A */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* B */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* C */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* D */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* E */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* F */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+        },
+/* 6 */ {
+//              0           1           2           3           4           5           6           7           8           9           A           B           C           D           E           R
+/* 0 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 1 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 2 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 3 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 4 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 5 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 6 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 7 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 8 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 9 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* A */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* B */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* C */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* D */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* E */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* F */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+        },
+/* 7 */ {
+//              0           1           2           3           4           5           6           7           8           9           A           B           C           D           E           R
+/* 0 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 1 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 2 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 3 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 4 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 5 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 6 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 7 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 8 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 9 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* A */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* B */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* C */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* D */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* E */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* F */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+        },
+/* 8 */ {
+//              0           1           2           3           4           5           6           7           8           9           A           B           C           D           E           R
+/* 0 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 1 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 2 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 3 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 4 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 5 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 6 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 7 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 8 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 9 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* A */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* B */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* C */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* D */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* E */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* F */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+        },
+/* 9 */ {
+//              0           1           2           3           4           5           6           7           8           9           A           B           C           D           E           R
+/* 0 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 1 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 2 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 3 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 4 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 5 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 6 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 7 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 8 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 9 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* A */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* B */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* C */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* D */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* E */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* F */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+        },
+/* A */ {
+//              0           1           2           3           4           5           6           7           8           9           A           B           C           D           E           R
+/* 0 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 1 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 2 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 3 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 4 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 5 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 6 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 7 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 8 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 9 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* A */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* B */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* C */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* D */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* E */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* F */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+        },
+/* B */ {
+//              0           1           2           3           4           5           6           7           8           9           A           B           C           D           E           R
+/* 0 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 1 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 2 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 3 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 4 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 5 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 6 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 7 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 8 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 9 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* A */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* B */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* C */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* D */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* E */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* F */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+        },
+/* C */ {
+//              0           1           2           3           4           5           6           7           8           9           A           B           C           D           E           R
+/* 0 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 1 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 2 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 3 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 4 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 5 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 6 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 7 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 8 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 9 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* A */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* B */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* C */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* D */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* E */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* F */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+        },
+/* D */ {
+//              0           1           2           3           4           5           6           7           8           9           A           B           C           D           E           R
+/* 0 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 1 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 2 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 3 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 4 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 5 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 6 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 7 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 8 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 9 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* A */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* B */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* C */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* D */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* E */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* F */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+        },
+/* E */ {
+//              0           1           2           3           4           5           6           7           8           9           A           B           C           D           E           R
+/* 0 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 1 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 2 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 3 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 4 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 5 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 6 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 7 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 8 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 9 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* A */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* B */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* C */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* D */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* E */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* F */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+        },
+/* F */ {
+//              0           1           2           3           4           5           6           7           8           9           A           B           C           D           E           R
+/* 0 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 1 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 2 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 3 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 4 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 5 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 6 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 7 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 8 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* 9 */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* A */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* B */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* C */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* D */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* E */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+/* F */         0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567, 0x01234567,
+        },
+}
+
+x509
--- a/security/exein/exein_nn_defs_parts.h
+++ b/security/exein/exein_nn_defs_parts.h
@@ -0,0 +1,101 @@
+/*
+   ------
+  / *    *
+ /   *  *  *
+(------     *
+ \   *  *  *
+  \ *    *
+   ------
+Exein
+*/
+#include <uapi/linux/capability.h>
+
+#define	DUMMY_STRING_MAX_LENGTH     0
+
+#define CURRENT_PROCESS_FEATURES    1
+#define BOOL                        1
+#define CHAR                        1
+#define CONST_CHAR                  CHAR
+#define CONST_STRUCT_CRED           STRUCT_CRED
+#define CONST_STRUCT_KERNEL_CAP_T   KERNEL_CAP_T
+#define CONST_STRUCT_PATH           1 //temporary
+#define CONST_STRUCT_QSTR           STRUCT_QSTR
+#define CONST_STRUCT_SUPER_BLOCK    1 //temporary
+#define CONST_STRUCT_TIMESPEC64     1 //temporary
+#define CONST_STRUCT_TIMEZONE       1 //temporary
+#define CONST_VOID                  1 //temporary
+#define CONST_STRUCT_REQUEST_SOCK   STRUCT_REQUEST_SOCK
+#define CONST_STRUCT_FLOWI          STRUCT_FLOWI
+#define CONST_STRUCT_SOCK           STRUCT_SOCK
+#define UNION_BPF_ATTR              1 //temporary
+#define DEV_T                       1 //temporary
+#define ENUM_KERNEL_LOAD_DATA_ID    1 //temporary
+#define ENUM_KERNEL_READ_FILE_ID    1 //temporary
+#define GFP_T                       1 //temporary
+#define INT                         1
+#define KERNEL_CAP_T                2 //_KERNEL_CAPABILITY_U32S
+#define KGID_T                      1 //temporary
+#define KUID_T                      1 //temporary
+#define LOFF_T                      1 //temporary
+#define LONG                        1 //temporary
+#define PID_T                       1 //temporary
+#define SHORT                       1 //temporary
+#define SIZE_T                      1 //temporary
+#define KEY_REF_T                   1 //temporary
+#define FMODE_T                     1 //temporary
+#define STRUCT_CRED                 9
+#define STRUCT_DENTRY               1 //temporary was 0
+#define STRUCT_FILE                 STRUCT_DENTRY + STRUCT_INODE + STRUCT_FOWN_STRUCT + 1
+#define STRUCT_FOWN_STRUCT          1
+#define STRUCT_FS_CONTEXT           DUMMY_STRING_MAX_LENGTH + STRUCT_DENTRY + STRUCT_USER_NAMESPACE + STRUCT_CRED + DUMMY_STRING_MAX_LENGTH + DUMMY_STRING_MAX_LENGTH + 6
+#define STRUCT_FS_PARAMETER         1 //temporary was 0
+#define STRUCT_IATTR                5
+#define STRUCT_INODE                7
+//4.14.151
+#define STRUCT_SIGINFO       1 //temporary
+#define STRUCT_KERN_IPC_PERM        1 //temporary
+#define STRUCT_LINUX_BINPRM         1 //temporary was 0
+#define STRUCT_MM_STRUCT            1 //temporary
+#define STRUCT_MSG_MSG              1 //temporary
+#define STRUCT_QSTR                 1 //temporary was 0
+#define STRUCT_RLIMIT               1 //temporary
+#define STRUCT_SEQ_FILE             1 //temporary
+#define STRUCT_SUPER_BLOCK          1 //temporary
+#define STRUCT_TASK_STRUCT         10
+#define STRUCT_USER_NAMESPACE       3
+#define STRUCT_VFSMOUNT             1 //temporary
+#define STRUCT_VM_AREA_STRUCT      20
+#define STRUCT_AUDIT_KRULE          1 //temporary
+//4.14.151
+#define STRUCT_AUDIT_CONTEXT        1 //temporary
+#define STRUCT_XFRM_STATE           1 //temporary
+#define STRUCT_XFRM_USER_SEC_CTX    1 //temporary
+#define STRUCT_XFRM_SEC_CTX         1 //temporary
+#define STRUCT_SOCK                 1 //temporary
+#define STRUCT_XFRM_POLICY          1 //temporary
+#define STRUCT_MSGHDR               1 //temporary
+#define STRUCT_SOCKADDR             1 //temporary
+#define STRUCT_SOCKET               1 //temporary
+#define STRUCT_KEY                  1 //temporary
+#define STRUCT_SK_BUFF              1 //temporary
+#define STRUCT_REQUEST_SOCK         1 //temporary
+#define STRUCT_SEMBUF               1 //temporary
+#define STRUCT_BPF_PROG_AUX         1 //temporary
+#define STRUCT_BPF_PROG             1 //temporary
+#define STRUCT_BPF_MAP              1 //temporary
+#define STRUCT_SCTP_ENDPOINT        1 //temporary
+#define STRUCT_FLOWI                1 //temporary
+#define UMODE_T                     1 //temporary
+#define UNSIGNED_INT                1
+#define UNSIGNED_LONG               1 //temporary
+#define VOID                        1 //temporary
+#define UNSIGNED                    1 //temporary
+#define U8                          1 //temporary
+#define U16                         1 //temporary
+#define U32                         1 //temporary
+#define U64                         1 //temporary
+//4.14.151
+#define STRUCT_SECURITY_MNT_OPTS    1 //temporary
+#define STRUCT_SEM_ARRAY            1 //temporary
+#define STRUCT_MSG_QUEUE            1 //temporary
+#define STRUCT_SHMID_KERNEL         1 //temporary
--- a/security/exein/mkHookh_data/banner.txt
+++ b/security/exein/mkHookh_data/banner.txt
@@ -0,0 +1,15 @@
+/*******************************************************************************************************
+     _  _   _ _____ ___   ___ ___ _  _ ___ ___    _ _____ ___ ___
+    /_\| | | |_   _/ _ \ / __| __| \| | __| _ \  /_\_   _| __|   \
+   / _ \ |_| | | || (_) | (_ | _|| .` | _||   / / _ \| | | _|| |) |
+  /_/ \_\___/  |_| \___/ \___|___|_|\_|___|_|_\/_/ \_\_| |___|___/                         _ _
+   __| |___   _ _  ___| |_   __| |_  __ _ _ _  __ _ ___  (_) |_   _ __  __ _ _ _ _  _ __ _| | |_  _
+  / _` / _ \ | ' \/ _ \  _| / _| ' \/ _` | ' \/ _` / -_) | |  _| | '  \/ _` | ' \ || / _` | | | || |
+  \__,_\___/ |_||_\___/\__| \__|_||_\__,_|_||_\__, \___| |_|\__| |_|_|_\__,_|_||_\_,_\__,_|_|_|\_, |
+                                               |___/                                            |__/
+  DO NOT CHANGE THIS [!]
+  This file has been generated during the build process
+  To change this refer to the config.ini and hooks.ini files inside the mkHookh_data directory
+********************************************************************************************************/
+
+
--- a/security/exein/mkHookh_data/config.ini
+++ b/security/exein/mkHookh_data/config.ini
@@ -0,0 +1,3 @@
+[files]
+header=./security/exein/mkHookh_data/banner.txt
+footer=./security/exein/mkHookh_data/banner.txt
--- a/security/exein/mkHookh_data/hooks.ini
+++ b/security/exein/mkHookh_data/hooks.ini
@@ -0,0 +1,228 @@
+[ID]
+HOOK_ID=1
+HOOK_CURRENT_PROCESS=1
+HOOK_CURRENT_PROCESS_TAG=1
+
+[PTRACE_HOOKS]
+PTRACE_ACCESS_CHECK=PTRACE_ACCESS_CHECK
+PTRACE_TRACEME=PTRACE_TRACEME
+
+[CAP_HOOKS]
+CAPGET=CAPGET
+CAPSET=CAPSET
+CAPABLE=CAPABLE
+
+[EXEC_HOOKS]
+BPRM_SET_CREDS=BPRM_SET_CREDS
+BPRM_CHECK_SECURITY=BPRM_CHECK_SECURITY
+BPRM_COMMITTING_CREDS=BPRM_COMMITTING_CREDS
+BPRM_COMMITTED_CREDS=BPRM_COMMITTED_CREDS
+
+[DISKIO_HOOKS]
+SB_ALLOC_SECURITY=SB_ALLOC_SECURITY
+SB_FREE_SECURITY=SB_FREE_SECURITY
+SB_REMOUNT=SB_REMOUNT
+SB_KERN_MOUNT=SB_KERN_MOUNT
+SB_SHOW_OPTIONS=SB_SHOW_OPTIONS
+SB_STATFS=SB_STATFS
+SB_MOUNT=SB_MOUNT
+SB_UMOUNT=SB_UMOUNT
+SB_PIVOTROOT=SB_PIVOTROOT
+SB_SET_MNT_OPTS=SB_SET_MNT_OPTS
+SB_CLONE_MNT_OPTS=SB_CLONE_MNT_OPTS
+DENTRY_INIT_SECURITY=DENTRY_INIT_SECURITY
+DENTRY_CREATE_FILES_AS=DENTRY_CREATE_FILES_AS
+PATH_UNLINK=PATH_UNLINK
+PATH_MKDIR=PATH_MKDIR
+PATH_RMDIR=PATH_RMDIR
+PATH_MKNOD=PATH_MKNOD
+PATH_TRUNCATE=PATH_TRUNCATE
+PATH_SYMLINK=PATH_SYMLINK
+PATH_LINK=PATH_LINK
+PATH_RENAME=PATH_RENAME
+PATH_CHMOD=PATH_CHMOD
+PATH_CHOWN=PATH_CHOWN
+PATH_CHROOT=PATH_CHROOT
+INODE_ALLOC_SECURITY=INODE_ALLOC_SECURITY
+INODE_FREE_SECURITY=INODE_FREE_SECURITY
+INODE_INIT_SECURITY=INODE_INIT_SECURITY
+INODE_CREATE=INODE_CREATE
+INODE_LINK=INODE_LINK
+INODE_UNLINK=INODE_UNLINK
+INODE_SYMLINK=INODE_SYMLINK
+INODE_MKDIR=INODE_MKDIR
+INODE_RMDIR=INODE_RMDIR
+INODE_MKNOD=INODE_MKNOD
+INODE_RENAME=INODE_RENAME
+INODE_READLINK=INODE_READLINK
+INODE_FOLLOW_LINK=INODE_FOLLOW_LINK
+INODE_PERMISSION=INODE_PERMISSION
+INODE_SETATTR=INODE_SETATTR
+INODE_GETATTR=INODE_GETATTR
+INODE_SETXATTR=INODE_SETXATTR
+INODE_POST_SETXATTR=INODE_POST_SETXATTR
+INODE_GETXATTR=INODE_GETXATTR
+INODE_LISTXATTR=INODE_LISTXATTR
+INODE_REMOVEXATTR=INODE_REMOVEXATTR
+INODE_NEED_KILLPRIV=INODE_NEED_KILLPRIV
+INODE_KILLPRIV=INODE_KILLPRIV
+INODE_GETSECURITY=INODE_GETSECURITY
+INODE_SETSECURITY=INODE_SETSECURITY
+INODE_LISTSECURITY=INODE_LISTSECURITY
+INODE_GETSECID=INODE_GETSECID
+INODE_COPY_UP=INODE_COPY_UP
+INODE_COPY_UP_XATTR=INODE_COPY_UP_XATTR
+INODE_INVALIDATE_SECCTX=INODE_INVALIDATE_SECCTX
+INODE_NOTIFYSECCTX=INODE_NOTIFYSECCTX
+INODE_GETSECCTX=INODE_GETSECCTX
+INODE_SETSECCTX=INODE_SETSECCTX
+FILE_PERMISSION=FILE_PERMISSION
+FILE_ALLOC_SECURITY=FILE_ALLOC_SECURITY
+FILE_FREE_SECURITY=FILE_FREE_SECURITY
+FILE_IOCTL=FILE_IOCTL
+FILE_MPROTECT=FILE_MPROTECT
+FILE_LOCK=FILE_LOCK
+FILE_FCNTL=FILE_FCNTL
+FILE_SET_FOWNER=FILE_SET_FOWNER
+FILE_SEND_SIGIOTASK=FILE_SEND_SIGIOTASK
+FILE_RECEIVE=FILE_RECEIVE
+FILE_OPEN=FILE_OPEN
+
+[MEMORY_HOOKS]
+MMAP_ADDR=MMAP_ADDR
+MMAP_FILE=MMAP_FILE
+
+[TASK_HOOKS]
+TASK_ALLOC=TASK_ALLOC
+TASK_FIX_SETUID=TASK_FIX_SETUID
+TASK_SETPGID=TASK_SETPGID
+TASK_GETPGID=TASK_GETPGID
+TASK_GETSID=TASK_GETSID
+TASK_GETSECID=TASK_GETSECID
+TASK_SETNICE=TASK_SETNICE
+TASK_SETIOPRIO=TASK_SETIOPRIO
+TASK_GETIOPRIO=TASK_GETIOPRIO
+TASK_PRLIMIT=TASK_PRLIMIT
+TASK_SETRLIMIT=TASK_SETRLIMIT
+TASK_SETSCHEDULER=TASK_SETSCHEDULER
+TASK_GETSCHEDULER=TASK_GETSCHEDULER
+TASK_MOVEMEMORY=TASK_MOVEMEMORY
+TASK_KILL=TASK_KILL
+TASK_PRCTL=TASK_PRCTL
+TASK_TO_INODE=TASK_TO_INODE
+GETPROCATTR=GETPROCATTR
+SETPROCATTR=SETPROCATTR
+
+[TUNNEL_HOOKS]
+TUN_DEV_ALLOC_SECURITY=TUN_DEV_ALLOC_SECURITY
+TUN_DEV_FREE_SECURITY=TUN_DEV_FREE_SECURITY
+TUN_DEV_CREATE=TUN_DEV_CREATE
+TUN_DEV_ATTACH_QUEUE=TUN_DEV_ATTACH_QUEUE
+TUN_DEV_ATTACH=TUN_DEV_ATTACH
+TUN_DEV_OPEN=TUN_DEV_OPEN
+XFRM_POLICY_ALLOC_SECURITY=XFRM_POLICY_ALLOC_SECURITY
+XFRM_POLICY_CLONE_SECURITY=XFRM_POLICY_CLONE_SECURITY
+XFRM_POLICY_FREE_SECURITY=XFRM_POLICY_FREE_SECURITY
+XFRM_POLICY_DELETE_SECURITY=XFRM_POLICY_DELETE_SECURITY
+XFRM_STATE_ALLOC=XFRM_STATE_ALLOC
+XFRM_STATE_ALLOC_ACQUIRE=XFRM_STATE_ALLOC_ACQUIRE
+XFRM_STATE_FREE_SECURITY=XFRM_STATE_FREE_SECURITY
+XFRM_STATE_DELETE_SECURITY=XFRM_STATE_DELETE_SECURITY
+XFRM_POLICY_LOOKUP=XFRM_POLICY_LOOKUP
+XFRM_STATE_POL_FLOW_MATCH=XFRM_STATE_POL_FLOW_MATCH
+XFRM_DECODE_SESSION=XFRM_DECODE_SESSION
+KEY_ALLOC=KEY_ALLOC
+KEY_FREE=KEY_FREE
+KEY_PERMISSION=KEY_PERMISSION
+KEY_GETSECURITY=KEY_GETSECURITY
+
+[NETWORK_HOOKS]
+SOCKET_POST_CREATE=SOCKET_POST_CREATE
+SOCKET_BIND=SOCKET_BIND
+SOCKET_CONNECT=SOCKET_CONNECT
+SOCKET_LISTEN=SOCKET_LISTEN
+SOCKET_ACCEPT=SOCKET_ACCEPT
+SOCKET_SENDMSG=SOCKET_SENDMSG
+SOCKET_RECVMSG=SOCKET_RECVMSG
+SOCKET_GETSOCKNAME=SOCKET_GETSOCKNAME
+SOCKET_GETPEERNAME=SOCKET_GETPEERNAME
+SOCKET_GETSOCKOPT=SOCKET_GETSOCKOPT
+SOCKET_SETSOCKOPT=SOCKET_SETSOCKOPT
+SOCKET_SHUTDOWN=SOCKET_SHUTDOWN
+SOCKET_GETPEERSEC_STREAM=SOCKET_GETPEERSEC_STREAM
+SOCKET_GETPEERSEC_DGRAM=SOCKET_GETPEERSEC_DGRAM
+SK_ALLOC_SECURITY=SK_ALLOC_SECURITY
+SK_FREE_SECURITY=SK_FREE_SECURITY
+SK_CLONE_SECURITY=SK_CLONE_SECURITY
+SK_GETSECID=SK_GETSECID
+
+[INTERPROCESSPROC_HOOKS]
+IPC_PERMISSION=IPC_PERMISSION
+IPC_GETSECID=IPC_GETSECID
+MSG_MSG_ALLOC_SECURITY=MSG_MSG_ALLOC_SECURITY
+MSG_MSG_FREE_SECURITY=MSG_MSG_FREE_SECURITY
+MSG_QUEUE_ALLOC_SECURITY=MSG_QUEUE_ALLOC_SECURITY
+MSG_QUEUE_FREE_SECURITY=MSG_QUEUE_FREE_SECURITY
+MSG_QUEUE_ASSOCIATE=MSG_QUEUE_ASSOCIATE
+MSG_QUEUE_MSGCTL=MSG_QUEUE_MSGCTL
+MSG_QUEUE_MSGSND=MSG_QUEUE_MSGSND
+MSG_QUEUE_MSGRCV=MSG_QUEUE_MSGRCV
+SHM_ALLOC_SECURITY=SHM_ALLOC_SECURITY
+SHM_FREE_SECURITY=SHM_FREE_SECURITY
+SHM_ASSOCIATE=SHM_ASSOCIATE
+SHM_SHMCTL=SHM_SHMCTL
+SHM_SHMAT=SHM_SHMAT
+BINDER_SET_CONTEXT_MGR=BINDER_SET_CONTEXT_MGR
+BINDER_TRANSACTION=BINDER_TRANSACTION
+BINDER_TRANSFER_BINDER=BINDER_TRANSFER_BINDER
+BINDER_TRANSFER_FILE=BINDER_TRANSFER_FILE
+NETLINK_SEND=NETLINK_SEND
+UNIX_STREAM_CONNECT=UNIX_STREAM_CONNECT
+UNIX_MAY_SEND=UNIX_MAY_SEND
+
+[SEMAPHORES_HOOKS]
+SEM_ALLOC_SECURITY=SEM_ALLOC_SECURITY
+SEM_FREE_SECURITY=SEM_FREE_SECURITY
+SEM_ASSOCIATE=SEM_ASSOCIATE
+SEM_SEMCTL=SEM_SEMCTL
+SEM_SEMOP=SEM_SEMOP
+
+[SECCONNS_HOOKS]
+SECMARK_RELABEL_PACKET=SECMARK_RELABEL_PACKET
+SECMARK_REFCOUNT_INC=SECMARK_REFCOUNT_INC
+SECMARK_REFCOUNT_DEC=SECMARK_REFCOUNT_DEC
+INET_CONN_REQUEST=INET_CONN_REQUEST
+INET_CSK_CLONE=INET_CSK_CLONE
+INET_CONN_ESTABLISHED=INET_CONN_ESTABLISHED
+
+[KERNEL_HOOKS]
+KERNEL_ACT_AS=KERNEL_ACT_AS
+KERNEL_CREATE_FILES_AS=KERNEL_CREATE_FILES_AS
+KERNEL_MODULE_REQUEST=KERNEL_MODULE_REQUEST
+KERNEL_READ_FILE=KERNEL_READ_FILE
+KERNEL_POST_READ_FILE=KERNEL_POST_READ_FILE
+CRED_ALLOC_BLANK=CRED_ALLOC_BLANK
+CRED_FREE=CRED_FREE
+CRED_PREPARE=CRED_PREPARE
+CRED_TRANSFER=CRED_TRANSFER
+ISMACLABEL=ISMACLABEL
+SECID_TO_SECCTX=SECID_TO_SECCTX
+SECCTX_TO_SECID=SECCTX_TO_SECID
+RELEASE_SECCTX=RELEASE_SECCTX
+SOCK_GRAFT=SOCK_GRAFT
+REQ_CLASSIFY_FLOW=REQ_CLASSIFY_FLOW
+IB_PKEY_ACCESS=IB_PKEY_ACCESS
+IB_ENDPORT_MANAGE_SUBNET=IB_ENDPORT_MANAGE_SUBNET
+IB_ALLOC_SECURITY=IB_ALLOC_SECURITY
+IB_FREE_SECURITY=IB_FREE_SECURITY
+AUDIT_RULE_INIT=AUDIT_RULE_INIT
+AUDIT_RULE_KNOWN=AUDIT_RULE_KNOWN
+AUDIT_RULE_MATCH=AUDIT_RULE_MATCH
+AUDIT_RULE_FREE=AUDIT_RULE_FREE
+QUOTACTL=QUOTACTL
+QUOTA_ON=QUOTA_ON
+SYSLOG=SYSLOG
+SETTIME=SETTIME
+VM_ENOUGH_MEMORY=VM_ENOUGH_MEMORY
+D_INSTANTIATE=D_INSTANTIATE
+
--- a/scripts/Makefile
+++ b/scripts/Makefile
@@ -40,6 +40,7 @@
 subdir-$(CONFIG_SECURITY_SELINUX) += selinux
 subdir-$(CONFIG_DTC)         += dtc
 subdir-$(CONFIG_GDB_SCRIPTS) += gdb
+subdir-$(CONFIG_SECURITY_EXEIN) += exein
 
 # Let clean descend into subdirs
 subdir-	+= basic kconfig package gcc-plugins
--- a/scripts/exein/make_define_aliases.sh
+++ b/scripts/exein/make_define_aliases.sh
@@ -0,0 +1,5 @@
+#!/bin/sh
+sed -n '/union security_list_options {/,/};/p' $srctree/include/linux/lsm_hooks.h |\
+egrep "\(.*\)\(|^#" |\
+sed -r 's/.*\(\*(.*)\)\(.*/\1/' |\
+gawk -f $srctree/scripts/exein/hooks_define.awk
--- a/scripts/exein/config.h
+++ b/scripts/exein/config.h
@@ -0,0 +1,83 @@
+#ifndef INI_FILE_H_
+#define INI_FILE_H_
+
+#include <net/if.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <string.h>
+#include <sys/types.h>
+#include "list.h"
+
+#define NAME_NAME     0
+#define NAME_NUMBER   1
+#define NUMBER_NAME   2
+#define NUMBER_NUMBER 3
+
+#define NAME          0
+#define NUMBER        1
+
+#define LEFT_BRACE '['
+#define RIGHT_BRACE ']'
+#define COMMENT ';'
+#define SIGN_OF_EQUAL "=="
+
+#define BASE_URL_FIRST_GROUP 3
+
+#define LINE_LEN 256
+
+#define SectionName(ptr) (ptr)!=NULL?(ptr)->section:"NA"
+#define KeyValue(ptr) (ptr)!=NULL?(ptr)->value:"NA"
+#define KeyName(ptr) (ptr)!=NULL?(ptr)->key:"NA"
+
+/** @brief max length of each value */
+#define VALUE_LEN 256
+
+typedef struct keys {
+	struct list_head node;
+	char value[VALUE_LEN];
+	char key[VALUE_LEN];
+	int id;
+}keys_t;
+
+typedef struct sections{
+	struct list_head node;
+	char section[VALUE_LEN];
+	keys_t *keys;
+}sections_t;
+
+typedef struct group_range {
+	int begin;
+	int end;
+	int group_num;
+}group_range_t;
+
+extern group_range_t *g_group;
+/** @brief the end of each line */
+#define NEW_LINE(c) ('\n' == c || '\r' == c)? 1 : 0
+
+/** @brief delete the end-of-line indicator */
+#define DELE_NEW_LINE_INDICATOR(buffer, len) 	\
+									if (NEW_LINE(buffer[len - 1])) { \
+										if (NEW_LINE(buffer[len - 2])) \
+											buffer[len - 2] = '\0';   \
+										else  						\
+											buffer[len - 1] = '\0';\
+									}	
+
+#define STRING_COMPARE(x, equ, y) (strcmp(x, y) equ 0)
+
+int delete_line_break_indicator(char *buffer);
+void print_error(char *err_msg);
+int read_file_content(const char *file, sections_t *section_head);
+int read_ini_file(char * filename, sections_t *section_head);
+sections_t *get_section(void *section, sections_t *section_head, char method);
+keys_t *get_key(void *section, void *key, sections_t *section_head, char method);
+int add_section(char *section_name, sections_t *section_head);
+int add_key(char *section_name, char *key_name, char *key_value, sections_t *section_head);
+void print_ini(sections_t *section_head);
+
+#define CONFIG_FILE "./config.ini"
+
+#endif //end of INI_FILE_H_
+
--- a/scripts/exein/list.h
+++ b/scripts/exein/list.h
@@ -0,0 +1,310 @@
+#ifndef _LINUX_LIST_H
+#define _LINUX_LIST_H
+
+#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
+
+#define container_of(ptr, type, member) ( { \
+        const typeof( ((type *)0)->member ) *__mptr = (ptr); \
+        (type *)( (char *)__mptr - offsetof(type,member) ); } )
+
+static inline void prefetch(const void *x) {;}
+static inline void prefetchw(const void *x) {;}
+
+#define LIST_POISON1  ((void *) 0x00100100)
+#define LIST_POISON2  ((void *) 0x00200200)
+
+struct list_head {
+        struct list_head *next, *prev;
+};
+
+#define LIST_HEAD_INIT(name) { &(name), &(name) }
+
+#define LIST_HEAD(name) \
+        struct list_head name = LIST_HEAD_INIT(name)
+
+#define INIT_LIST_HEAD(ptr) do { \
+        (ptr)->next = (ptr); (ptr)->prev = (ptr); \
+} while (0)
+
+/*
+* Insert a new entry between two known consecutive entries.
+*
+* This is only for internal list manipulation where we know
+* the prev/next entries already!
+*/
+static inline void __list_add(struct list_head *new,
+                              struct list_head *prev,
+                              struct list_head *next)
+{
+        next->prev = new;
+        new->next = next;
+        new->prev = prev;
+        prev->next = new;
+}
+
+/**
+* list_add - add a new entry
+* @new: new entry to be added
+* @head: list head to add it after
+*
+* Insert a new entry after the specified head.
+* This is good for implementing stacks.
+*/
+static inline void list_add(struct list_head *new, struct list_head *head)
+{
+        __list_add(new, head, head->next);
+}
+
+/**
+* list_add_tail - add a new entry
+* @new: new entry to be added
+* @head: list head to add it before
+*
+* Insert a new entry before the specified head.
+* This is useful for implementing queues.
+*/
+static inline void list_add_tail(struct list_head *new, struct list_head *head)
+{
+        __list_add(new, head->prev, head);
+}
+
+static inline void __list_del(struct list_head * prev, struct list_head * next)
+{
+        next->prev = prev;
+        prev->next = next;
+}
+
+static inline void list_del(struct list_head *entry)
+{
+        __list_del(entry->prev, entry->next);
+        entry->next = LIST_POISON1;
+        entry->prev = LIST_POISON2;
+}
+
+static inline void list_del_init(struct list_head *entry)
+{
+        __list_del(entry->prev, entry->next);
+        INIT_LIST_HEAD(entry);
+}
+
+static inline void list_move(struct list_head *list, struct list_head *head)
+{
+        __list_del(list->prev, list->next);
+        list_add(list, head);
+}
+
+static inline void list_move_tail(struct list_head *list,
+                                  struct list_head *head)
+{
+        __list_del(list->prev, list->next);
+        list_add_tail(list, head);
+}
+
+static inline int list_empty(const struct list_head *head)
+{
+        return head->next == head;
+}
+
+static inline int list_empty_careful(const struct list_head *head)
+{
+        struct list_head *next = head->next;
+        return (next == head) && (next == head->prev);
+}
+
+static inline void __list_splice(struct list_head *list,
+                                 struct list_head *head)
+{
+        struct list_head *first = list->next;
+        struct list_head *last = list->prev;
+        struct list_head *at = head->next;
+
+        first->prev = head;
+        head->next = first;
+
+        last->next = at;
+        at->prev = last;
+}
+
+/**
+* list_splice - join two lists
+* @list: the new list to add.
+* @head: the place to add it in the first list.
+*/
+static inline void list_splice(struct list_head *list, struct list_head *head)
+{
+        if (!list_empty(list))
+                __list_splice(list, head);
+}
+
+/**
+* list_splice_init - join two lists and reinitialise the emptied list.
+* @list: the new list to add.
+* @head: the place to add it in the first list.
+*
+* The list at @list is reinitialised
+*/
+static inline void list_splice_init(struct list_head *list,
+                                    struct list_head *head)
+{
+        if (!list_empty(list)) {
+                __list_splice(list, head);
+                INIT_LIST_HEAD(list);
+        }
+}
+
+#define list_entry(ptr, type, member) container_of(ptr, type, member)
+
+
+#define list_for_each(pos, head) \
+        for (pos = (head)->next; prefetch(pos->next), pos != (head); \
+                pos = pos->next)
+
+#define __list_for_each(pos, head) \
+        for (pos = (head)->next; pos != (head); pos = pos->next)
+
+#define list_for_each_prev(pos, head) \
+        for (pos = (head)->prev; prefetch(pos->prev), pos != (head); \
+                pos = pos->prev)
+
+#define list_for_each_safe(pos, n, head) \
+        for (pos = (head)->next, n = pos->next; pos != (head); \
+                pos = n, n = pos->next)
+
+#define list_for_each_entry(pos, head, member)                                \
+        for (pos = list_entry((head)->next, typeof(*pos), member);        \
+             prefetch(pos->member.next), &pos->member != (head);         \
+             pos = list_entry(pos->member.next, typeof(*pos), member))
+
+#define list_for_each_entry_reverse(pos, head, member)                        \
+        for (pos = list_entry((head)->prev, typeof(*pos), member);        \
+             prefetch(pos->member.prev), &pos->member != (head);         \
+             pos = list_entry(pos->member.prev, typeof(*pos), member))
+
+#define list_prepare_entry(pos, head, member) \
+        ((pos) ? : list_entry(head, typeof(*pos), member))
+
+#define list_for_each_entry_continue(pos, head, member)                 \
+        for (pos = list_entry(pos->member.next, typeof(*pos), member);        \
+             prefetch(pos->member.next), &pos->member != (head);        \
+             pos = list_entry(pos->member.next, typeof(*pos), member))
+
+#define list_for_each_entry_safe(pos, n, head, member)                        \
+        for (pos = list_entry((head)->next, typeof(*pos), member),        \
+                n = list_entry(pos->member.next, typeof(*pos), member);        \
+             &pos->member != (head);                                         \
+             pos = n, n = list_entry(n->member.next, typeof(*n), member))
+
+//HASH LIST
+struct hlist_head {
+        struct hlist_node *first;
+};
+
+struct hlist_node {
+        struct hlist_node *next, **pprev;
+};
+
+#define HLIST_HEAD_INIT { .first = NULL }
+#define HLIST_HEAD(name) struct hlist_head name = {  .first = NULL }
+#define INIT_HLIST_HEAD(ptr) ((ptr)->first = NULL)
+#define INIT_HLIST_NODE(ptr) ((ptr)->next = NULL, (ptr)->pprev = NULL)
+
+static inline int hlist_unhashed(const struct hlist_node *h)
+{
+        return !h->pprev;
+}
+
+static inline int hlist_empty(const struct hlist_head *h)
+{
+        return !h->first;
+}
+
+static inline void __hlist_del(struct hlist_node *n)
+{
+        struct hlist_node *next = n->next;
+        struct hlist_node **pprev = n->pprev;
+        *pprev = next;
+        if (next)
+                next->pprev = pprev;
+}
+
+static inline void hlist_del(struct hlist_node *n)
+{
+        __hlist_del(n);
+        n->next = LIST_POISON1;
+        n->pprev = LIST_POISON2;
+}
+
+static inline void hlist_del_init(struct hlist_node *n)
+{
+        if (n->pprev)  {
+                __hlist_del(n);
+                INIT_HLIST_NODE(n);
+        }
+}
+
+static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h)
+{
+        struct hlist_node *first = h->first;
+        n->next = first;
+        if (first)
+                first->pprev = &n->next;
+        h->first = n;
+        n->pprev = &h->first;
+}
+
+
+/* next must be != NULL */
+static inline void hlist_add_before(struct hlist_node *n,
+                                        struct hlist_node *next)
+{
+        n->pprev = next->pprev;
+        n->next = next;
+        next->pprev = &n->next;
+        *(n->pprev) = n;
+}
+
+static inline void hlist_add_after(struct hlist_node *n,
+                                        struct hlist_node *next)
+{
+        next->next = n->next;
+        n->next = next;
+        next->pprev = &n->next;
+
+        if(next->next)
+                next->next->pprev  = &next->next;
+}
+
+#define hlist_entry(ptr, type, member) container_of(ptr,type,member)
+
+#define hlist_for_each(pos, head) \
+        for (pos = (head)->first; pos && ({ prefetch(pos->next); 1; }); \
+             pos = pos->next)
+
+#define hlist_for_each_safe(pos, n, head) \
+        for (pos = (head)->first; pos && ({ n = pos->next; 1; }); \
+             pos = n)
+
+#define hlist_for_each_entry(tpos, pos, head, member)                         \
+        for (pos = (head)->first;                                         \
+             pos && ({ prefetch(pos->next); 1;}) &&                         \
+                ({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \
+             pos = pos->next)
+
+#define hlist_for_each_entry_continue(tpos, pos, member)                 \
+        for (pos = (pos)->next;                                                 \
+             pos && ({ prefetch(pos->next); 1;}) &&                         \
+                ({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \
+             pos = pos->next)
+
+#define hlist_for_each_entry_from(tpos, pos, member)                         \
+        for (; pos && ({ prefetch(pos->next); 1;}) &&                         \
+                ({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \
+             pos = pos->next)
+
+#define hlist_for_each_entry_safe(tpos, pos, n, head, member)                  \
+        for (pos = (head)->first;                                         \
+             pos && ({ n = pos->next; 1; }) &&                                  \
+                ({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \
+             pos = n)
+
+#endif
--- a/scripts/exein/Kconfig
+++ b/scripts/exein/Kconfig
@@ -0,0 +1,6 @@
+config SECURITY_EXEIN
+	bool "Exein rules the IT"
+	depends on SECURITY
+	default n
+	help
+	  This selects exein, bla bla bla
--- a/scripts/exein/config.c
+++ b/scripts/exein/config.c
@@ -0,0 +1,394 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <string.h>
+#include <ctype.h>
+#include <errno.h>
+#include "config.h"
+#include "list.h"
+
+/*
+ * INTERNAL - NOT EXPORTED
+ */
+void print_error(char *err_msg)
+{
+	printf("%s\n", err_msg);
+	exit(0);
+}
+
+/*
+ * @brief delete_line_break_indicator
+ * @buffer[in,out]
+ * @NOTE:
+ * detete the last one or two character which is '\n' or 'r'
+ * INTERNAL - NOT EXPORTED
+ */
+int delete_line_break_indicator(char *buffer)
+{
+	int len = strlen(buffer), i, j = len - 1;
+	for (i = j; i >= 0; i--) {
+		if (!isspace(buffer[i])) {
+			if (i == j) {
+				break;
+			}
+			else {
+				buffer[i + 1] = '\0';
+				break;
+			}
+		}
+	}
+
+	DELE_NEW_LINE_INDICATOR(buffer, len);
+#if 0
+	if (NEW_LINE(buffer[len - 1])) {
+		if (NEW_LINE(buffer[len - 2]))
+			buffer[len - 2] = '\0';
+		else
+			buffer[len - 1] = '\0';
+	}
+#endif
+	return 0;
+}
+
+/*
+ * @read_file_content
+ * @file         [in] the direcotry of category.ini
+ * @section_head [in,out]
+ * Return 1 on success and populates the section_heads, 0 elsewhere.
+ */
+int read_file_content(const char *file, sections_t *section_head)
+{
+	FILE *fp = NULL;
+	char * ret_buf, contents[LINE_LEN] = {0}, *saveptr = NULL, *pcon = contents;
+	sections_t *section_node = NULL;
+	keys_t *keys;
+
+	assert(file !=NULL);
+
+	if ((fp = fopen(file,"r")) == NULL) {
+		fprintf(stderr, "Open [%s] %s\n", file ,strerror(errno));
+		return 0;
+	}
+
+	while (fgets(pcon, LINE_LEN, fp)){
+		/** @brief skip all the space character that contains
+			('\r', '\n', '\f', '\t', '\v')
+		*/
+		while (isspace(*pcon)) {
+			pcon++;
+			}
+
+		/** @brief find the section '[]' */
+		if (*pcon == LEFT_BRACE) {
+			if ((ret_buf = strchr(pcon, RIGHT_BRACE))) {
+				if ((section_node = (sections_t *)malloc(sizeof(sections_t))) == NULL) {
+					perror("MALLOC:");
+					return 0;
+					}
+				memset(section_node, 0, sizeof(sections_t));
+				memcpy(section_node->section, pcon + 1, ret_buf - pcon - 1);
+				list_add_tail(&section_node->node, &section_head->node);
+				}else {
+					print_error("syntex error , there are need ']'");
+					}
+			}else if (*pcon == COMMENT) {
+				/** @brief this is a comment line and ignore it */
+				continue;
+				}else {
+
+				/** @brief find all the keys and value which under the section found */
+				if (section_node == NULL) {
+					print_error("syntex error, there are no '[]'");
+					}
+
+				int i = 0;
+				if (section_node->keys == NULL) {
+					if ((section_node->keys = (keys_t *)malloc(sizeof(keys_t))) == NULL){
+						perror("MALLOC:");
+						return 0;
+						}
+				memset(section_node->keys, 0, sizeof(keys_t));
+				INIT_LIST_HEAD(&section_node->keys->node);
+				}
+			if ((keys = (keys_t *)malloc(sizeof(keys_t))) == NULL) {
+				perror("MALLOC:");
+				exit(0);
+				}
+			memset(keys, 0, sizeof(keys_t));
+
+			while ((ret_buf = strtok_r(pcon, SIGN_OF_EQUAL, &saveptr))) {
+				if (i == 0) {
+					delete_line_break_indicator(ret_buf);
+					memcpy(keys->key, ret_buf, strlen(ret_buf)); }else if (i == 1) {
+					delete_line_break_indicator(ret_buf);
+					memcpy(keys->value, ret_buf, strlen(ret_buf));
+					}
+				pcon = NULL;
+				i++;
+				}
+
+			if (i == 0) {
+				free(keys);
+				}else list_add_tail(&keys->node, &section_node->keys->node);
+			}
+
+		memset(contents, 0, LINE_LEN);
+		pcon = contents;
+	}
+
+	fclose(fp);
+	return 1;
+}
+
+/*
+ * @get_section
+ * @section      [in]
+ * @section_head [in] the struct which stores the head of section list
+ * @method       [in] defines the type of data specified to access the structure. 
+ *                    Valid methods includes: NAME, NUMBER.
+ * Return a pointer to the section having the specified characteristics if found; NULL elsewhere.
+ */
+
+sections_t *get_section(void *section, sections_t *section_head, char method)
+{
+	assert(section != NULL);
+	assert(section_head != NULL);
+	assert(method <= NUMBER);
+
+	struct list_head *pos = NULL;
+	sections_t * tmp_node = NULL;
+
+	switch (method) {
+		case NAME:
+		list_for_each(pos, &section_head->node) {
+			tmp_node = (sections_t *)container_of(pos, sections_t, node);
+			if (STRING_COMPARE((char *)section, ==, tmp_node->section)) {
+				return tmp_node;
+				}
+			}
+		break;
+		case NUMBER:
+		{
+		int ct=0;
+		list_for_each(pos, &section_head->node) {
+			tmp_node = (sections_t *)container_of(pos, sections_t, node);
+			if (ct==*((int *)section)) {
+				return tmp_node;
+				}
+			ct++;
+			}
+		}
+		break;
+		}
+	return NULL;
+}
+
+/*
+ * @add_section
+ * @section_name [in]
+ * @section_head [in/out] the struct which stores the head of section list
+ * Return 0 on success others on failure
+ *        1 section exist
+ *        2 memory alloc fail
+ */
+
+int add_section(char *section_name, sections_t *section_head){
+	sections_t *section_node = NULL;
+
+	if (get_section(section_name, section_head, NAME)){
+		return 1;
+		}
+	if ((section_node = (sections_t *)malloc(sizeof(sections_t))) == NULL) {
+		return 2;
+		}
+	memset(section_node, 0, sizeof(sections_t));
+	memcpy(section_node->section, section_name, strlen(section_name));
+	list_add_tail(&section_node->node, &section_head->node);
+	return 0;
+}
+
+/*
+typedef struct keys {
+        struct list_head node;
+        char value[VALUE_LEN];
+        char key[VALUE_LEN];
+        int id;
+}keys_t;
+
+typedef struct sections{
+        struct list_head node;
+        char section[VALUE_LEN];
+        keys_t *keys;
+}sections_t;
+*/
+
+
+/*
+ * @add_key
+ * @key_name [in]
+ * @key_value [in]
+ * @section_head [in/out] the struct which stores the head of section list
+ * Return 0 on success others on failure
+ *        1 section not found
+ *        2 memory alloc fail
+ */
+
+int add_key(char *section_name, char *key_name, char *key_value, sections_t *section_head){
+        sections_t *section_node;
+	keys_t *tmp_key;
+
+        if (!(section_node=get_section(section_name, section_head, NAME))){
+		fflush(stdout);
+                return 1;
+                }
+
+	fflush(stdout);
+	if ((tmp_key = (keys_t *)malloc(sizeof(keys_t))) == NULL){
+		return 2;
+		}
+	memset(tmp_key, 0, sizeof(keys_t));
+	memcpy(tmp_key->key, key_name, strlen(key_name));
+	memcpy(tmp_key->value, key_value, strlen(key_value));
+
+        if (section_node->keys == NULL) {
+		if ((section_node->keys = (keys_t *)malloc(sizeof(keys_t))) == NULL){
+                	return 2;
+                	}
+		memset(section_node->keys, 0, sizeof(keys_t));
+		INIT_LIST_HEAD(&section_node->keys->node);
+		}
+	list_add_tail(&tmp_key->node, &section_node->keys->node);
+        return 0;
+}
+
+
+
+
+/*
+ * @get_key
+ * @section      [in]
+ * @key          [in]
+ * @section_head [in] the struct which stores the head of section list
+ * @method       [in] defines the type of data specified to access the structure. 
+ *                    Valid methods includes: NAME_NAME, NAME_NUMBER, NUMBER_NAME, NUMBER_NUMBER.
+ * Returns a pointer to the specified key laying in the specified section if found, NULL elsewhere.
+ */
+
+keys_t *get_key(void *section, void *key, sections_t *section_head, char method)
+{
+	assert(section != NULL);
+	assert(section_head != NULL);
+	assert(key != NULL);
+	assert(method <= NUMBER_NUMBER);
+
+	struct list_head *pos = NULL, *pos_child = NULL;
+	sections_t * tmp_node = NULL;
+	keys_t *tmp_key = NULL;
+
+
+	switch (method) {
+		case NAME_NAME:
+		list_for_each(pos, &section_head->node) {
+			tmp_node = (sections_t *)container_of(pos, sections_t, node);
+			if (STRING_COMPARE((char *)section, ==, tmp_node->section)) {
+				list_for_each(pos_child, &tmp_node->keys->node) {
+					tmp_key = (keys_t *)container_of(pos_child, keys_t, node);
+					if (STRING_COMPARE((char *)key, ==, tmp_key->key)) {
+						return tmp_key;
+						}
+					}
+				}
+			}
+		break;
+		case NAME_NUMBER:
+		{
+		int ct=0;
+		list_for_each(pos, &section_head->node) {
+			tmp_node = (sections_t *)container_of(pos, sections_t, node);
+			if (STRING_COMPARE((char *)section, ==, tmp_node->section)) {
+				list_for_each(pos_child, &tmp_node->keys->node) {
+					tmp_key = (keys_t *)container_of(pos_child, keys_t, node);
+					if (*((int *)key)==ct) {
+						return tmp_key;
+						}
+					ct++;
+					}
+				}
+			}
+		}
+		break;
+		case NUMBER_NAME:
+		{
+		int ct=0;
+		list_for_each(pos, &section_head->node) {
+			tmp_node = (sections_t *)container_of(pos, sections_t, node);
+			if (*((int *) section)==ct) {
+				list_for_each(pos_child, &tmp_node->keys->node) {
+					tmp_key = (keys_t *)container_of(pos_child, keys_t, node);
+					if (STRING_COMPARE((char *)key, ==, tmp_key->key)) {
+						return tmp_key;
+						}
+					}
+				}
+			ct++;
+			}
+		}
+		break;
+		case NUMBER_NUMBER:
+		{
+		int ctk=0,cts=0;
+		list_for_each(pos, &section_head->node) {
+			tmp_node = (sections_t *)container_of(pos, sections_t, node);
+			if (*((int *) section)==cts)  {
+				list_for_each(pos_child, &tmp_node->keys->node) {
+					tmp_key = (keys_t *)container_of(pos_child, keys_t, node);
+					if (*((int *)key)==ctk) {
+						return tmp_key;
+						}
+					ctk++;
+					}
+				}
+			cts++;
+			}
+		}
+		break;
+		}
+	return NULL;
+}
+
+void print_ini(sections_t *section_head){
+	sections_t *tmp_sec;
+	keys_t *tmp_key;
+
+	for (char i=0;(tmp_sec=get_section(&i,section_head, NUMBER)); i++){
+//		printf("[%s] debug: key=%p\n", SectionName(tmp_sec), tmp_sec->keys);
+		printf("[%s]\n", SectionName(tmp_sec));
+		if (tmp_sec->keys){
+	                for (char j=0;(tmp_key=get_key(&i,&j,section_head, NUMBER_NUMBER)); j++){
+        	                printf("%s=%s\n", KeyName(tmp_key), KeyValue(tmp_key));
+                	        }
+			}
+                }
+}
+
+
+
+
+/*
+ * @read_ini_file
+ * @filename[in] the name of *.ini file
+ * @section_head[in,out]
+ */
+int read_ini_file(char * filename, sections_t *section_head)
+{
+//	char buffer[VALUE_LEN] = {0};
+	/** @brief init the head of list */
+	INIT_LIST_HEAD(&section_head->node);
+
+
+	/** @brief parse the whole .ini file and
+		store information in section_head list */
+	read_file_content(filename, section_head);
+
+	return 0;
+}
--- a/scripts/exein/csv2ini.sh
+++ b/scripts/exein/csv2ini.sh
@@ -0,0 +1,18 @@
+#!/bin/bash
+[ "$#" -ne 1 ] && echo "$0 hooks.csv" && exit 1;
+IFS=$'\n';
+for i in $(cat $1); do
+    type=$(echo $i | cut -d, -f1);
+    name=$(echo $i | cut -d, -f2);
+    echo "[$name]";
+    echo "type=\"$type\"";
+    count=1;
+    tmp=$(echo $i | cut -d, -f3-);
+    IFS=$',';
+    for j in $tmp; do
+          echo "arg${count}=\"${j}\"";
+          count=$((count+1));
+          done;
+    echo;
+    IFS=$'\n';
+    done
--- a/scripts/exein/Makefile
+++ b/scripts/exein/Makefile
@@ -0,0 +1,2 @@
+subdir-y := mkHookh HeaderParser mkHookhcomp inibuilder
+MAKEFLAGS := -j 1
--- a/scripts/exein/hooks_define.awk
+++ b/scripts/exein/hooks_define.awk
@@ -0,0 +1,11 @@
+BEGIN {
+       config="NONE";
+      }
+{
+ if ($1== "#ifdef") config=$2; 
+               else if ($1== "#endif") config="NONE"; 
+                                  else {
+                                        str=sprintf( (config=="NONE")?"#define EXEIN_%2$s_SWITCH":"#ifdef %s\n#define EXEIN_%s_SWITCH\n#endif",config, toupper($0));
+                                        print str;
+                                       }
+ }
--- a/scripts/exein/mkHookhcomp/Makefile
+++ b/scripts/exein/mkHookhcomp/Makefile
@@ -0,0 +1,4 @@
+hostprogs-y     := mkHookhcomp
+mkHookhcomp-objs    := ../config.o mkHookhcomp.o
+HOST_EXTRACFLAGS += -std=gnu11
+always          := $(hostprogs-y)
--- a/scripts/exein/mkHookhcomp/mkHookhcomp.c
+++ b/scripts/exein/mkHookhcomp/mkHookhcomp.c
@@ -0,0 +1,116 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <strings.h>
+#include <ctype.h>
+#include "../config.h"
+
+
+//#define EXEIN_COMPSIZE_PRINT
+#define FILE_BUFFER_SIZE 1048510
+#define MAXCHAR 1024
+
+char *getMainType(char *s){
+	char i;
+	for (i=0; i<strlen(s);i++) {
+		*(s+i)= *(s+i)==' '?'_':*(s+i);
+		}
+	while ((*(s+i)=='"') || (*(s+i)=='_') || (*(s+i)=='*')  || (*(s+i)=='\x00')) i--;
+	*(s+i+1)='\x00';
+
+//	if (*(s+i-2)=='*') *(s+i-3)='\x00';
+//                      else *(s+i-1)='\x00';
+	return s+1;
+}
+
+int main(int argc, char **argv)
+{
+	char keynum, secnum;
+	sections_t *tmp_sec;
+	keys_t *tmp_key;
+	sections_t section_head = {0};
+	sections_t config_head = {0};
+	int pos=0, cur_array_pos=0;
+	FILE *fp;
+	char str[MAXCHAR];
+	char *tmp_str;
+
+
+	char *H_file=(char *)malloc(FILE_BUFFER_SIZE);
+	memset(H_file,0, FILE_BUFFER_SIZE);
+
+	if (argc!=3) {
+		printf("call:\n\tmkHookhcomp hookspart.ini config.ini\n");
+		exit(1);
+		}
+
+	read_ini_file(argv[1], &section_head);
+	read_ini_file(argv[2], &config_head);
+
+/*
+  _                    _
+ | |                  | |
+ | |__   ___  __ _  __| | ___ _ __ ___
+ | '_ \ / _ \/ _` |/ _` |/ _ \ '__/ __|
+ | | | |  __/ (_| | (_| |  __/ |  \__ \
+ |_| |_|\___|\__,_|\__,_|\___|_|  |___/
+
+*/
+	for (int i=0;tmp_sec=get_section(&i,&section_head, NUMBER); i++){
+		int flag=0;
+		tmp_str=SectionName(tmp_sec);
+		for (int t=0; t<strlen(tmp_str);t++) *(tmp_str+t)= toupper((unsigned char) *(tmp_str+t));
+		pos+=sprintf((H_file+pos),"#define %s    ", tmp_str);
+		for (int j=0; tmp_key=get_key(&i,&j,&section_head, NUMBER_NUMBER); j++){
+                        tmp_str=KeyName(tmp_key);
+			if (strcmp(tmp_str,"type")) {
+				 int tmp=j+1;
+				 tmp_str=KeyValue(tmp_key);
+				 for (int t=0; t<strlen(tmp_str);t++) *(tmp_str+t)= toupper((unsigned char) *(tmp_str+t));
+				 pos+=sprintf((H_file+pos),get_key(&i,&tmp,&section_head, NUMBER_NUMBER)?"%s + ":"%s", getMainType(tmp_str));
+				 flag=1;
+				}
+			}
+		 pos+=sprintf((H_file+pos),flag==0?" 0\n":"\n");
+		 flag=0;
+		}
+#ifdef EXEIN_COMPSIZE_PRINT
+	pos+=sprintf((H_file+pos),"/********************************************|DEBUG START|********************************************/\n");
+	for (int i=0;tmp_sec=get_section(&i,&section_head, NUMBER); i++){
+		tmp_str=SectionName(tmp_sec);
+		for (int t=0; t<strlen(tmp_str);t++) *(tmp_str+t)= toupper((unsigned char) *(tmp_str+t));
+		pos+=sprintf((H_file+pos),"#ifdef %s\n", tmp_str);
+		pos+=sprintf((H_file+pos),"#define SYMNAME \"%s\"\n", tmp_str);
+		pos+=sprintf((H_file+pos),"#define EVALUATE_ %s\n", tmp_str);
+		pos+=sprintf((H_file+pos),"#include \"eval_p_sym.h\"\n");
+		pos+=sprintf((H_file+pos),"#endif\n");
+		}
+	pos+=sprintf((H_file+pos),"/********************************************|DEBUG END|********************************************/\n");
+#endif
+
+/*
+              _               _
+             | |             | |
+   ___  _   _| |_ _ __  _   _| |_
+  / _ \| | | | __| '_ \| | | | __|
+ | (_) | |_| | |_| |_) | |_| | |_
+  \___/ \__,_|\__| .__/ \__,_|\__|
+                 | |
+                 |_|
+*/
+	fp = fopen(KeyValue(get_key("files","header",&config_head, NAME_NAME)), "r");
+	if (fp == NULL){
+		printf("Could not open header file\n");
+		return 1;
+		}
+	while (fgets(str, MAXCHAR, fp) != NULL) printf("%s", str);
+	fclose(fp);
+	puts(H_file);
+        fp = fopen(KeyValue(get_key("files","footer",&config_head, NAME_NAME)), "r");
+        if (fp == NULL){
+                printf("Could not open header file\n");
+                return 1;
+                }
+        while (fgets(str, MAXCHAR, fp) != NULL) printf("%s", str);
+        fclose(fp);
+	return 0;
+}
--- a/scripts/exein/data/lookup
+++ b/scripts/exein/data/lookup
@@ -0,0 +1,237 @@
+Audit:audit_rule_free
+Audit:audit_rule_init
+Audit:audit_rule_known
+Audit:audit_rule_match
+Audit:inode_getsecctx
+Audit:inode_invalidate_secctx
+Audit:inode_notifysecctx
+Audit:inode_setsecctx
+eBPF:bpf
+eBPF:bpf_map
+eBPF:bpf_map_alloc_security
+eBPF:bpf_map_free_security
+eBPF:bpf_prog
+eBPF:bpf_prog_alloc_security
+eBPF:bpf_prog_free_security
+Exec:bprm_check_security
+Exec:bprm_committed_creds
+Exec:bprm_committing_creds
+Exec:bprm_secureexec
+Exec:bprm_set_creds
+Files:dentry_open
+Files:file_alloc_security
+Files:file_fcntl
+Files:file_free_security
+Files:file_ioctl
+Files:file_lock
+Files:file_mmap
+Files:file_mprotect
+Files:file_open
+Files:file_permission
+Files:file_receive
+Files:file_send_sigiotask
+Files:file_set_fowner
+Files:mmap_addr
+Files:mmap_file
+Filesystems:d_instantiate
+Filesystems:dentry_create_files_as
+Filesystems:dentry_init_security
+Filesystems:move_mount
+Filesystems:sb_alloc_security
+Filesystems:sb_clone_mnt_opts
+Filesystems:sb_copy_data
+Filesystems:sb_free_security
+Filesystems:sb_mount
+Filesystems:sb_parse_opts_str
+Filesystems:sb_pivotroot
+Filesystems:sb_remount
+Filesystems:sb_set_mnt_opts
+Filesystems:sb_statfs
+Filesystems:sb_umount
+Filesystems:quotactl
+Filesystems:quota_on
+Filesystems:sb_free_mnt_opts
+Filesystems:sb_eat_lsm_opts
+Filesystems:sb_kern_mount
+Filesystems:sb_show_options
+Filesystems:sb_add_mnt_opt
+Infiniband:ib_alloc_security
+Infiniband:ib_endport_manage_subnet
+Infiniband:ib_free_security
+Infiniband:ib_pkey_access
+Inodes:inode_alloc_security
+Inodes:inode_copy_up
+Inodes:inode_copy_up_xattr
+Inodes:inode_create
+Inodes:inode_follow_link
+Inodes:inode_free_security
+Inodes:inode_getattr
+Inodes:inode_getsecid
+Inodes:inode_getsecurity
+Inodes:inode_getxattr
+Inodes:inode_init_security
+Inodes:inode_killpriv
+Inodes:inode_link
+Inodes:inode_listsecurity
+Inodes:inode_listxattr
+Inodes:inode_mkdir
+Inodes:inode_mknod
+Inodes:inode_need_killpriv
+Inodes:inode_permission
+Inodes:inode_post_setxattr
+Inodes:inode_readlink
+Inodes:inode_removexattr
+Inodes:inode_rename
+Inodes:inode_rmdir
+Inodes:inode_setattr
+Inodes:inode_setsecurity
+Inodes:inode_setxattr
+Inodes:inode_symlink
+Inodes:inode_unlink
+Inodes:path_chmod
+Inodes:path_chown
+Inodes:path_chroot
+Inodes:path_link
+Inodes:path_mkdir
+Inodes:path_mknod
+Inodes:path_rename
+Inodes:path_rmdir
+Inodes:path_symlink
+Inodes:path_truncate
+Inodes:path_unlink
+Kernfs:kernfs_init_security
+KeyManagement:key_alloc
+KeyManagement:key_free
+KeyManagement:key_getsecurity
+KeyManagement:key_permission
+Mountfs_context:fs_context_dup
+Mountfs_context:fs_context_parse_param
+Netlink.messaging:netlink_recv
+Netlink.messaging:netlink_send
+Others:binder_set_context_mgr
+Others:binder_transaction
+Others:binder_transfer_binder
+Others:binder_transfer_file
+Others:capable
+Others:capget
+Others:capset
+Others:ismaclabel
+Others:ptrace_access_check
+Others:ptrace_traceme
+Others:release_secctx
+Others:secctx_to_secid
+Others:secid_to_secctx
+Others:settime
+Others:syslog
+Others:vm_enough_memory
+SCTP:sctp_assoc_request
+SCTP:sctp_bind_connect
+SCTP:sctp_sk_clone
+Sockets:inet_conn_established
+Sockets:inet_conn_request
+Sockets:inet_csk_clone
+Sockets:req_classify_flow
+Sockets:secmark_refcount_dec
+Sockets:secmark_refcount_inc
+Sockets:secmark_relabel_packet
+Sockets:security_secmark_refcount_dec
+Sockets:security_secmark_refcount_inc
+Sockets:sk_alloc_security
+Sockets:skb_owned_by
+Sockets:sk_clone_security
+Sockets:sk_free_security
+Sockets:sk_getsecid
+Sockets:socket_accept
+Sockets:socket_bind
+Sockets:socket_connect
+Sockets:socket_create
+Sockets:socket_getpeername
+Sockets:socket_getpeersec_dgram
+Sockets:socket_getpeersec_stream
+Sockets:socket_getsockname
+Sockets:socket_getsockopt
+Sockets:socket_listen
+Sockets:socket_post_create
+Sockets:socket_recvmsg
+Sockets:socket_sendmsg
+Sockets:socket_setsockopt
+Sockets:socket_shutdown
+Sockets:socket_socketpair
+Sockets:socket_sock_rcv_skb
+Sockets:sock_graft
+Sockets:tun_dev_alloc_security
+Sockets:tun_dev_attach
+Sockets:tun_dev_attach_queue
+Sockets:tun_dev_create
+Sockets:tun_dev_free_security
+Sockets:tun_dev_open
+Sockets:tun_dev_post_create
+SystemVAll:ipc_getsecid
+SystemVAll:ipc_permission
+SystemVMessageQueues:msg_msg_alloc_security
+SystemVMessageQueues:msg_msg_free_security
+SystemVMessageQueues:msg_queue_alloc_security
+SystemVMessageQueues:msg_queue_associate
+SystemVMessageQueues:msg_queue_free_security
+SystemVMessageQueues:msg_queue_msgctl
+SystemVMessageQueues:msg_queue_msgrcv
+SystemVMessageQueues:msg_queue_msgsnd
+SystemVSemaphores:sem_alloc_security
+SystemVSemaphores:sem_associate
+SystemVSemaphores:sem_free_security
+SystemVSemaphores:sem_semctl
+SystemVSemaphores:sem_semop
+SystemVSHM:shm_alloc_security
+SystemVSHM:shm_associate
+SystemVSHM:shm_free_security
+SystemVSHM:shm_shmat
+SystemVSHM:shm_shmctl
+Tasks:getprocattr
+Tasks:setprocattr
+Tasks:cred_alloc_blank
+Tasks:cred_free
+Tasks:cred_getsecid
+Tasks:cred_prepare
+Tasks:cred_transfer
+Tasks:kernel_act_as
+Tasks:kernel_create_files_as
+Tasks:kernel_fw_from_file
+Tasks:kernel_load_data
+Tasks:kernel_module_from_file
+Tasks:kernel_module_request
+Tasks:kernel_post_read_file
+Tasks:kernel_read_file
+Tasks:task_alloc
+Tasks:task_create
+Tasks:task_fix_setuid
+Tasks:task_free
+Tasks:task_getioprio
+Tasks:task_getpgid
+Tasks:task_getscheduler
+Tasks:task_getsecid
+Tasks:task_getsid
+Tasks:task_kill
+Tasks:task_movememory
+Tasks:task_prctl
+Tasks:task_prlimit
+Tasks:task_setioprio
+Tasks:task_setnice
+Tasks:task_setpgid
+Tasks:task_setrlimit
+Tasks:task_setscheduler
+Tasks:task_to_inode
+Tasks:task_wait
+UnixSocket:unix_may_send
+UnixSocket:unix_stream_connect
+XFRM:xfrm_decode_session
+XFRM:xfrm_policy_alloc_security
+XFRM:xfrm_policy_clone_security
+XFRM:xfrm_policy_delete_security
+XFRM:xfrm_policy_free_security
+XFRM:xfrm_policy_lookup
+XFRM:xfrm_state_alloc
+XFRM:xfrm_state_alloc_acquire
+XFRM:xfrm_state_alloc_security
+XFRM:xfrm_state_delete_security
+XFRM:xfrm_state_free_security
+XFRM:xfrm_state_pol_flow_match
--- a/scripts/exein/HeaderParser/HeaderParser.y
+++ b/scripts/exein/HeaderParser/HeaderParser.y
@@ -0,0 +1,163 @@
+%{
+
+#include <stdio.h>
+#include <stdlib.h>
+
+extern int yylex();
+extern int yyparse();
+extern FILE* yyin;
+
+void yyerror(const char* s);
+%}
+
+%union {
+	int ival;
+	float fval;
+	char *sval;
+}
+
+
+%token PO PC COLON COMMA STRUCT UNSIGNED CONST INT LONG SIGNED SHORT CHAR VOID AST ENUM UNION
+%token<sval> ARGNAME ARGTYPE FUNNAME TYPE IDENTIFIER
+%type<sval> statement arguments argument type argname funname
+
+%%
+
+definitions:  /* empty */
+	|definitions instruction
+	;
+
+instruction: COLON                                  
+	|statement COLON                            { printf("\n");}
+	;
+
+statement:  type funname PO arguments               
+	;
+
+arguments: argument
+	| arguments argument                        
+	;
+
+argument: type argname                              
+	| VOID PC                                   
+	;
+
+argname: IDENTIFIER COMMA                           
+	|IDENTIFIER PC                              
+	;
+funname: PO AST IDENTIFIER PC                       { printf("%s,", $3); }
+
+
+type: IDENTIFIER                                    { printf("%s,", $1); }
+	| UNION IDENTIFIER                          { printf("union %s,", $2); }
+	| ENUM IDENTIFIER                           { printf("enum %s,", $2); }
+	| CONST IDENTIFIER                          { printf("const  %s,", $2); }
+	| CONST STRUCT IDENTIFIER                   { printf("const struct %s,", $3); }
+	| STRUCT IDENTIFIER                         { printf("struct %s,", $2); }
+	| CHAR                                      { printf("char,"); }
+	| CONST CHAR                                { printf("const char,"); }
+	| SIGNED CHAR                               { printf("signed char,"); }
+	| UNSIGNED CHAR                             { printf("unsigned char,"); }
+	| SHORT                                     { printf("short,"); }
+	| SHORT INT                                 { printf("short int,"); }
+	| SIGNED SHORT                              { printf("signed short,"); }
+	| SIGNED SHORT INT                          { printf("signed shot int,"); }
+	| UNSIGNED SHORT                            { printf("unsigned short,"); }
+	| UNSIGNED SHORT INT                        { printf("unsigned short int,"); }
+	| INT                                       { printf("int,"); }
+	| SIGNED                                    { printf("signed,"); }
+	| SIGNED INT                                { printf("signed int,"); }
+	| UNSIGNED                                  { printf("unsigned,"); }
+	| UNSIGNED INT                              { printf("unsigned int,"); }
+	| LONG                                      { printf("long,"); }
+	| LONG INT                                  { printf("long int,"); }
+	| SIGNED LONG                               { printf("signed long,"); }
+	| SIGNED LONG INT                           { printf("signed long int,"); }
+	| UNSIGNED LONG                             { printf("unsigned long,"); }
+	| UNSIGNED LONG INT                         { printf("unsigned long int,"); }
+	| LONG LONG                                 { printf("long long,"); }
+	| LONG LONG INT                             { printf("long long int,"); }  
+	| SIGNED LONG LONG                          { printf("signed long long,"); }
+	| SIGNED LONG LONG INT                      { printf("signed long long int,"); }
+	| UNSIGNED LONG LONG                        { printf("unsigned long long,"); }
+	| UNSIGNED LONG LONG INT                    { printf("unsigned long long int,"); }
+	| VOID                                      { printf("void,"); }
+	| IDENTIFIER AST                            { printf("%s *,", $1); }
+	| UNION IDENTIFIER AST                      { printf("union %s *,", $2); }
+	| CONST IDENTIFIER AST                      { printf("const struct %s,", $2); }
+	| CONST STRUCT IDENTIFIER AST               { printf("const struct %s *,", $3); }
+	| STRUCT IDENTIFIER AST                     { printf("struct %s *,", $2); }
+	| CHAR AST                                  { printf("char *,"); }
+	| CONST CHAR AST                            { printf("const char *,"); }
+	| SIGNED CHAR AST                           { printf("signed char *,"); }
+	| UNSIGNED CHAR AST                         { printf("unsigned char *,"); }
+	| SHORT AST                                 { printf("short *,"); }
+	| SHORT INT AST                             { printf("short int *,"); }
+	| SIGNED SHORT AST                          { printf("signed short *,"); }
+	| SIGNED SHORT INT AST                      { printf("signed shot int *,"); }
+	| UNSIGNED SHORT AST                        { printf("unsigned short *,"); }
+	| UNSIGNED SHORT INT AST                    { printf("unsigned short int *,"); }
+	| INT AST                                   { printf("int *,"); }
+	| SIGNED AST                                { printf("signed *,"); }
+	| SIGNED INT AST                            { printf("signed int *,"); }
+	| UNSIGNED AST                              { printf("unsigned *,"); }
+	| UNSIGNED INT AST                          { printf("unsigned int *,"); }
+	| LONG AST                                  { printf("long *,"); }
+	| LONG INT AST                              { printf("long int *,"); }
+	| SIGNED LONG AST                           { printf("signed long *,"); }
+	| SIGNED LONG INT AST                       { printf("signed long int *,"); }
+	| UNSIGNED LONG AST                         { printf("unsigned long *,"); }
+	| UNSIGNED LONG INT AST                     { printf("unsigned long int *,"); }
+	| LONG LONG AST                             { printf("long long *,"); }
+	| LONG LONG INT AST                         { printf("long long int *,"); }  
+	| SIGNED LONG LONG AST                      { printf("signed long long *,"); }
+	| SIGNED LONG LONG INT AST                  { printf("signed long long int *,"); }
+	| UNSIGNED LONG LONG AST                    { printf("unsigned long long *,"); }
+	| UNSIGNED LONG LONG INT AST                { printf("unsigned long long int *,"); }
+	| CONST VOID AST                            { printf("const void *,"); }
+	| VOID AST                                  { printf("void *,"); }
+	| IDENTIFIER AST AST                        { printf("%s **,", $1); }
+	| CONST IDENTIFIER AST AST                  { printf("const struct %s,", $2); }
+	| CONST STRUCT IDENTIFIER AST AST           { printf("const struct %s **,", $3); }
+	| STRUCT IDENTIFIER AST AST                 { printf("struct %s **,", $2); }
+	| CHAR AST AST                              { printf("char **,"); }
+	| CONST CHAR AST AST                        { printf("const char **,"); }
+	| SIGNED CHAR AST AST                       { printf("signed char **,"); }
+	| UNSIGNED CHAR AST AST                     { printf("unsigned char **,"); }
+	| SHORT AST AST                             { printf("short **,"); }
+	| SHORT INT AST AST                         { printf("short int **,"); }
+	| SIGNED SHORT AST AST                      { printf("signed short **,"); }
+	| SIGNED SHORT INT AST AST                  { printf("signed shot int **,"); }
+	| UNSIGNED SHORT AST AST                    { printf("unsigned short **,"); }
+	| UNSIGNED SHORT INT AST AST                { printf("unsigned short int **,"); }
+	| INT AST AST                               { printf("int **,"); }
+	| SIGNED AST AST                            { printf("signed **,"); }
+	| SIGNED INT AST AST                        { printf("signed int *,"); }
+	| UNSIGNED AST AST                          { printf("unsigned **,"); }
+	| UNSIGNED INT AST AST                      { printf("unsigned int **,"); }
+	| LONG AST AST                              { printf("long **,"); }
+	| LONG INT AST AST                          { printf("long int **,"); }
+	| SIGNED LONG AST AST                       { printf("signed long **,"); }
+	| SIGNED LONG INT AST AST                   { printf("signed long int **,"); }
+	| UNSIGNED LONG AST AST                     { printf("unsigned long **,"); }
+	| UNSIGNED LONG INT AST AST                 { printf("unsigned long int **,"); }
+	| LONG LONG AST AST                         { printf("long long **,"); }
+	| LONG LONG INT AST AST                     { printf("long long int **,"); }  
+	| SIGNED LONG LONG AST AST                  { printf("signed long long **,"); }
+	| SIGNED LONG LONG INT AST AST              { printf("signed long long int **,"); }
+	| UNSIGNED LONG LONG AST AST                { printf("unsigned long long **,"); }
+	| UNSIGNED LONG LONG INT AST AST            { printf("unsigned long long int **,"); }
+	| CONST VOID AST AST                        { printf("const void **,"); }
+	| VOID AST AST                              { printf("void **,"); }
+	;
+%%
+int main() {
+	yyin = stdin;
+	yyparse();
+	return 0;
+}
+
+void yyerror(const char* s) {
+	fprintf(stderr, "Parse error: %s %s,", yylval.sval, s);
+	exit(1);
+}
--- a/scripts/exein/HeaderParser/Makefile
+++ b/scripts/exein/HeaderParser/Makefile
@@ -0,0 +1,19 @@
+hostprogs-y     := HeaderParser
+always          := $(hostprogs-y)
+HeaderParser-objs   := lex.yy.o HeaderParser.tab.o
+HOST_EXTRACFLAGS += -lm
+
+$(obj)/HeaderParser.tab.h: $(src)/HeaderParser.y FORCE
+				bison -o/dev/null --defines=$@ -t -l $<
+
+$(obj)/HeaderParser.tab.c: $(src)/HeaderParser.y FORCE
+				bison -o $@ $<
+
+$(obj)/lex.yy.o: $(obj)/HeaderParser.tab.h
+
+$(obj)/lex.yy.c: $(src)/HeaderParser.l FORCE
+	flex -o $@ $<
+
+# -I needed for generated C source (shipped source)
+HOSTCFLAGS_HeaderParser.tab.o := -I$(src)
+HOSTCFLAGS_lex.yy.o := -I$(src)
--- a/scripts/exein/HeaderParser/HeaderParser.l
+++ b/scripts/exein/HeaderParser/HeaderParser.l
@@ -0,0 +1,128 @@
+%option noyywrap
+
+%{
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "HeaderParser.tab.h"
+
+#define YY_DECL int yylex()
+
+int collect=0, typename=0;
+
+char *buffer;
+
+%}
+
+
+
+%%
+
+"union security_list_options {"	{
+				 collect=1;
+				}
+"struct"			{
+				 if (collect) {
+					 return STRUCT;
+					}
+				}
+"unsigned"			{
+				 if (collect) {
+					 return UNSIGNED;
+					}
+				}
+"long"				{
+				 if (collect) {
+					 return LONG;
+					}
+				}
+"int"				{
+				 if (collect) {
+					 return INT;
+					}
+				}
+"signed"			{
+				 if (collect) {
+					 return SIGNED;
+					}
+				}
+"short"				{
+				 if (collect) {
+					 return SHORT;
+					}
+				}
+"char"				{
+				 if (collect) {
+					 return CHAR;
+					}
+				}
+"void"				{
+				 if (collect) {
+					 return VOID;
+					}
+				}
+"const"                        {
+                                 if (collect) {
+					 return CONST;
+                                        }
+                                }
+"enum"                        {
+                                 if (collect) {
+					 return ENUM;
+                                        }
+                                }
+"union"                        {
+                                 if (collect) {
+					 return UNION;
+                                        }
+                                }
+
+"#ifdef "[A-Z_]+		;//{printf("ifdef skipped\n");}
+"#endif"			;//{printf("endif skipped\n");}
+"__"[a-z]+			;//{printf("annotation skipped\n");}
+"/*"[A-Za-z0-9_ ]*"*/"		;//{printf("skip comments skipped\n");}
+[A-Za-z0-9_]+			{
+				 if (collect) {
+					 yylval.sval=(char *) malloc(256);
+					 strcpy(yylval.sval,yytext);
+					 return IDENTIFIER; 
+					}
+                                }
+"{"				{
+				 if (collect) { 
+					}
+				}
+"}"				{
+				 if (collect) {
+					 collect=0;
+					}
+				}
+"("				{
+				 if (collect) {
+					 return PO; 
+					}
+				}
+")"				{
+				 if (collect) {
+					 return PC;
+					}
+				}
+"*"				{
+				 if (collect) {
+					 return AST;
+					}
+				}
+","				{
+				 if (collect) {
+					 return COMMA;
+					}
+				}
+";"				{
+				 if (collect) { 
+					 return COLON;
+					}
+				}
+[ \t\r\n]			;
+.				;
+
+%%
--- a/scripts/exein/inibuilder/inibuilder.c
+++ b/scripts/exein/inibuilder/inibuilder.c
@@ -0,0 +1,31 @@
+#include <stdio.h>
+#include "../config.h"
+#include <stdlib.h>
+
+
+int main(int argc, char **argv)
+{
+	char keynum=0, secnum=3;
+	sections_t section_head = {0};
+	int tmp;
+
+	if (!((argc!=3)||(argc!=5))) {
+		printf("call:\n\tinibuilder file.ini section_name [key_name key_value]\n");
+		exit(1);
+		}
+
+	read_ini_file(argv[1], &section_head);
+        if (argc==3){
+		if (tmp=add_section(argv[2], &section_head)){
+			printf("section ADD FAIL! (%d)\n", tmp);
+			return 1;
+			}
+		} else {
+		if (tmp=add_key(argv[2],argv[3],argv[4], &section_head)){
+			printf("Key ADD FAIL! in [%s] <- %s=%s - %d\n",argv[2],argv[3],argv[4], tmp);
+			return 1;
+			}
+		}
+	print_ini(&section_head);
+	return 0;
+}
--- a/scripts/exein/inibuilder/Makefile
+++ b/scripts/exein/inibuilder/Makefile
@@ -0,0 +1,6 @@
+hostprogs-y     := inibuilder
+inibuilder-objs    := ../config.o inibuilder.o
+HOST_EXTRACFLAGS += -std=gnu11
+always          := $(hostprogs-y)
+
+
--- a/scripts/exein/mkHookh/mkHookh.c
+++ b/scripts/exein/mkHookh/mkHookh.c
@@ -0,0 +1,103 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include "../config.h"
+#define FILE_BUFFER_SIZE 1048510
+#define MAXCHAR 1024
+
+int main(int argc, char **argv)
+{
+	char keynum, secnum;
+	sections_t *tmp_sec;
+	keys_t *tmp_key;
+	sections_t section_head = {0};
+	sections_t config_head = {0};
+	int pos=0, cur_array_pos=0;
+	FILE *fp;
+	char str[MAXCHAR];
+	char *prev="0";
+	char *prevVal;
+
+
+        if (argc!=4) {
+                printf("call:\n\tmkHookh hooks.ini config.ini [Y/N]\n");
+                exit(1);
+                }
+
+
+	srand(time(NULL));
+	char *H_file=(char *)malloc(FILE_BUFFER_SIZE);
+        memset(H_file,0, FILE_BUFFER_SIZE);
+	read_ini_file(argv[1], &section_head);
+	read_ini_file(argv[2], &config_head);
+
+/*
+  _                    _
+ | |                  | |
+ | |__   ___  __ _  __| | ___ _ __ ___
+ | '_ \ / _ \/ _` |/ _` |/ _ \ '__/ __|
+ | | | |  __/ (_| | (_| |  __/ |  \__ \
+ |_| |_|\___|\__,_|\__,_|\___|_|  |___/
+
+*/
+	pos+=sprintf((H_file+pos),"#include \"exein_nn_defs_comp.h\"\n", prev, prevVal );
+	if (strncmp(argv[3],"Y",1)==0) {
+		int counter=0;
+		for (int i=0;tmp_sec=get_section(&i,&section_head, NUMBER); i++){
+			pos+=sprintf((H_file+pos),"/**********/\n", tmp_sec);
+			for (int j=0; tmp_key=get_key(&i,&j,&section_head, NUMBER_NUMBER); j++){
+				pos+=sprintf((H_file+pos),"#define EXEIN_%s_ID %d\n", KeyName(tmp_key), counter);
+				counter++;
+				}
+			}
+		}
+	pos+=sprintf((H_file+pos),"\n\n/********************************************************************************************************/\n");
+	pos+=sprintf((H_file+pos),"#define EXEIN_0_ARG1_POS  0\n");
+	pos+=sprintf((H_file+pos),"#define HOOK_ID  1\n");
+	pos+=sprintf((H_file+pos),"#define HOOK_CURRENT_PROCESS  1\n");
+	pos+=sprintf((H_file+pos),"#define HOOK_CURRENT_PROCESS_TAG  1\n");
+	for (int i=0;tmp_sec=get_section(&i,&section_head, NUMBER); i++){
+		pos+=sprintf((H_file+pos),"/**********/\n", tmp_sec);
+		for (int j=0; tmp_key=get_key(&i,&j,&section_head, NUMBER_NUMBER); j++){
+
+			pos+=sprintf((H_file+pos),"#define EXEIN_%s_ARG1_POS	EXEIN_%s_ARG1_POS + %s\n", KeyName(tmp_key), prev, prev);
+			pos+=sprintf((H_file+pos),"#define EXEIN_%s_SIZE 	%s\n", KeyName(tmp_key), KeyValue(tmp_key));
+			//cur_array_pos+=atoi(KeyValue(tmp_key));
+                        prev=KeyName(tmp_key);
+			prevVal=KeyValue(tmp_key);
+			}
+		}
+	
+	pos+=sprintf((H_file+pos),"\n\n/********************************************************************************************************/\n");
+	pos+=sprintf((H_file+pos),"\n\n#define EXEIN_NN_INPUT_SIZE EXEIN_%s_ARG1_POS + %s\n", prev, prevVal );
+	pos+=sprintf((H_file+pos),"\n\n/********************************************************************************************************/\n");
+	pos+=sprintf((H_file+pos),"\n\n#define SEEDRND %d\n", rand() );
+
+
+
+/*
+              _               _
+             | |             | |
+   ___  _   _| |_ _ __  _   _| |_
+  / _ \| | | | __| '_ \| | | | __|
+ | (_) | |_| | |_| |_) | |_| | |_
+  \___/ \__,_|\__| .__/ \__,_|\__|
+                 | |
+                 |_|
+*/
+	fp = fopen(KeyValue(get_key("files","header",&config_head, NAME_NAME)), "r");
+	if (fp == NULL){
+		printf("Could not open header file\n");
+		return 1;
+		}
+	while (fgets(str, MAXCHAR, fp) != NULL) printf("%s", str);
+	fclose(fp);
+	puts(H_file);
+        fp = fopen(KeyValue(get_key("files","footer",&config_head, NAME_NAME)), "r");
+        if (fp == NULL){
+                printf("Could not open header file\n");
+                return 1;
+                }
+        while (fgets(str, MAXCHAR, fp) != NULL) printf("%s", str);
+        fclose(fp);
+	return 0;
+}
--- a/scripts/exein/mkHookh/Makefile
+++ b/scripts/exein/mkHookh/Makefile
@@ -0,0 +1,4 @@
+hostprogs-y     := mkHookh
+mkHookh-objs    := ../config.o mkHookh.o
+HOST_EXTRACFLAGS += -std=gnu11
+always          := $(hostprogs-y)

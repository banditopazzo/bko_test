--- a/fs/binfmt_elf.c
+++ b/fs/binfmt_elf.c
@@ -687,12 +687,19 @@
 	} *loc;
 	struct arch_elf_state arch_state = INIT_ARCH_ELF_STATE;
 
+#ifdef CONFIG_SECURITY_EXEIN
+	loff_t shdrpos,tmppos;
+	struct elf_shdr *shdr;
+	char *strtb;
+	void *tmp;
+#endif
+
 	loc = kmalloc(sizeof(*loc), GFP_KERNEL);
 	if (!loc) {
 		retval = -ENOMEM;
 		goto out_ret;
 	}
-	
+
 	/* Get the exec-header */
 	loc->elf_ex = *((struct elfhdr *)bprm->buf);
 
@@ -708,6 +715,30 @@
 	if (!bprm->file->f_op->mmap)
 		goto out;
 
+#ifdef CONFIG_SECURITY_EXEIN
+	if (current->process_tag==0){
+		if (loc->elf_ex.e_shentsize != 0) {
+			shdrpos=(loff_t) loc->elf_ex.e_shoff;
+			shdr  = kmalloc(loc->elf_ex.e_shentsize * loc->elf_ex.e_shnum, GFP_KERNEL);
+			kernel_read(bprm->file, shdrpos, (char *) shdr, loc->elf_ex.e_shentsize * loc->elf_ex.e_shnum);
+			strtb = kmalloc(shdr[loc->elf_ex.e_shstrndx].sh_size, GFP_KERNEL);
+			shdrpos=(loff_t) shdr[loc->elf_ex.e_shstrndx].sh_offset;
+			kernel_read(bprm->file, shdrpos, (char *) strtb, shdr[loc->elf_ex.e_shstrndx].sh_size);
+			for (i=0; i< loc->elf_ex.e_shnum; i++){
+				if (strcmp((strtb+ (shdr + i)->sh_name),".exein")==0){
+					tmp=kmalloc(shdr[i].sh_size, GFP_KERNEL);
+					tmppos=(loff_t) shdr[i].sh_offset;
+					kernel_read(bprm->file, tmppos, (char *) tmp, shdr[i].sh_size);
+					current->process_tag=*((uint16_t *) tmp);printk(KERN_INFO "ExeinLKM - tag %d exists.\n", *((uint16_t *) tmp));
+					kfree(tmp);
+					}
+				}
+			kfree(shdr);
+			kfree(strtb);
+			}
+		}
+#endif
+
 	elf_phdata = load_elf_phdrs(&loc->elf_ex, bprm->file);
 	if (!elf_phdata)
 		goto out;
--- a/kernel/exit.c
+++ b/kernel/exit.c
@@ -59,6 +59,9 @@
 #include <asm/unistd.h>
 #include <asm/pgtable.h>
 #include <asm/mmu_context.h>
+#ifdef CONFIG_SECURITY_EXEIN
+#include <exein.h>
+#endif
 
 static void __unhash_process(struct task_struct *p, bool group_dead)
 {
@@ -898,6 +901,10 @@
 	exit_rcu();
 	TASKS_RCU(__srcu_read_unlock(&tasks_rcu_exit_srcu, tasks_rcu_i));
 
+#ifdef CONFIG_SECURITY_EXEIN
+	if (tsk->process_tag) exein_delete_pids();
+#endif
+
 	do_task_dead();
 }
 EXPORT_SYMBOL_GPL(do_exit);
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -60,6 +60,9 @@
 
 obj-$(CONFIG_CONNECTOR)		+= connector/
 
+#exein
+obj-$(CONFIG_EXEIN_INTERFACE)	+= exein_interface/
+
 # i810fb and intelfb depend on char/agp/
 obj-$(CONFIG_FB_I810)           += video/fbdev/i810/
 obj-$(CONFIG_FB_INTEL)          += video/fbdev/intelfb/
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -202,4 +202,6 @@
 
 source "drivers/fpga/Kconfig"
 
+source "drivers/exein_interface/Kconfig"
+
 endmenu
--- a/drivers/exein_interface/exein_interface.c
+++ b/drivers/exein_interface/exein_interface.c
@@ -0,0 +1,169 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+//#include <asm/uaccess.h>
+#include <linux/module.h>
+#include <net/sock.h>
+#include <linux/netlink.h>
+#include <linux/skbuff.h>
+
+
+#define NETLINK_USER 			31
+//#define EXEIN_PRINT_DEBUG
+#define BUFFLEN 			4096
+#define EXEIN_ONREQUEST                 0x80
+#define EXEIN_LIVE                      0x81
+
+
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_AUTHOR("Exein");
+
+extern int exein_mode;
+extern void *exein_payload_process_ptr;
+extern void *exein_register_status_get_ptr;
+extern void *exein_pid_status_get_ptr;
+extern int exein_interface_ready;
+extern struct sock *exein_nl_sk_lsm;
+extern int exein_rndkey;
+
+static struct proc_dir_entry *ent;
+
+struct sock *nl_sk = NULL;
+
+
+static void nl_recv_msg(struct sk_buff *skb) {
+	struct nlmsghdr *nlh;
+	int pid;
+	struct sk_buff *skb_out;
+	int msg_size;
+	char *msg_ok="ACK";
+	char *strout;
+	int res;
+	int (*exein_payload_process)(void *,int)=exein_payload_process_ptr;
+
+	nlh=(struct nlmsghdr*)skb->data;
+	pid = nlh->nlmsg_pid; /*pid of sending process */
+	#ifdef EXEIN_PRINT_DEBUG
+	printk(KERN_INFO "ExeinLKM - Netlink received from %d\n", pid);
+	#endif
+
+	if ((*exein_payload_process)(nlmsg_data(nlh),pid)) {
+		skb_out = nlmsg_new(strlen(msg_ok),0);
+		if(!skb_out)
+			{
+			printk(KERN_INFO "ExeinLKM - Failed to allocate new skb\n");
+			return;
+			}
+		nlh=nlmsg_put(skb_out,0,0,NLMSG_DONE,strlen(msg_ok),0);
+		NETLINK_CB(skb_out).dst_group = 0; /* not in mcast group */
+		strncpy(nlmsg_data(nlh),msg_ok,strlen(msg_ok));
+		res=nlmsg_unicast(nl_sk,skb_out,pid);
+		if(res<0) printk(KERN_INFO "Error while sending back to user\n");
+		}
+}
+
+static ssize_t exeinwrite(struct file *file, const char __user *ubuf,size_t count, loff_t *ppos)
+{
+	// data=PDE_DATA(file_inode(file)); //takes the data sent to the 
+	if (exein_mode==EXEIN_ONREQUEST){
+		exein_mode=EXEIN_LIVE;
+	        printk( KERN_INFO "ExeinLKM - LSM mode switched in live\n");
+	}else{
+		exein_mode=EXEIN_ONREQUEST;
+		printk( KERN_INFO "ExeinLKM - LSM mode switched in on request\n");
+	}
+	*ppos = count;
+	return count;
+}
+
+static ssize_t exeinread(struct file *file, char __user *ubuf, size_t count, loff_t *ppos)
+{
+	int len=0;
+	char buff[BUFFLEN];
+	char *fn;
+	int (*exein_register_status_get)(char *,int)=exein_register_status_get_ptr;
+	int (*exein_pid_status_get)(char *,int)=exein_pid_status_get_ptr;
+
+	fn=dentry_path_raw(file->f_path.dentry,buff,BUFFLEN);
+
+#ifdef EXEIN_PRINT_DEBUG
+        if (strcmp(fn, "/exein/rndkey")==0){
+		if (*ppos==0){
+			len+=snprintf(buff,BUFFLEN,"%d\n",exein_rndkey);
+			if(copy_to_user(ubuf,buff,len+1)) {
+				return -EFAULT;
+				}
+			*ppos = len;
+			}
+		}
+#endif
+
+        if (strcmp(fn, "/exein/regs")==0){
+                if (*ppos==0){
+			len=exein_register_status_get(buff, BUFFLEN);
+                        if(copy_to_user(ubuf,buff,len+1)) {
+                                return -EFAULT;
+                                }
+                        *ppos = len;
+                        }
+                }
+
+
+	if (strcmp(fn, "/exein/pids")==0){
+		if (*ppos==0){
+			len=exein_pid_status_get(buff, BUFFLEN);
+			if(copy_to_user(ubuf,buff,len+1)) {
+				EFAULT;
+				}
+			*ppos = len;
+			}
+		}
+        return len;
+}
+
+static struct file_operations ops =
+{
+        .owner = THIS_MODULE,
+        .read = exeinread,
+        .write = exeinwrite,
+};
+
+static int init(void)
+{
+	struct netlink_kernel_cfg cfg = {
+		.input = nl_recv_msg,
+		};
+	nl_sk = netlink_kernel_create(&init_net, NETLINK_USER, &cfg);
+	if(!nl_sk)
+		{
+		 printk(KERN_ALERT "ExeinLKM - Error creating socket.\n");
+		 return -10;
+		}
+	exein_nl_sk_lsm=nl_sk ;
+	char *dirname="exein";
+	struct proc_dir_entry *parent;
+	parent=proc_mkdir(dirname,NULL);
+	ent=proc_create("mode_ctl",0660,parent,&ops);
+#ifdef EXEIN_PRINT_DEBUG
+        ent=proc_create("rndkey",0660,parent,&ops);
+#endif
+	ent=proc_create("regs",0660,parent,&ops);
+	exein_interface_ready=1;
+	ent=proc_create("pids",0660,parent,&ops);
+        exein_interface_ready=1;
+
+	printk(KERN_INFO "ExeinLKM - Interface module load complete. Interface ready.\n");
+	return 0;
+}
+
+static void cleanup(void)
+{
+	exein_interface_ready=0;
+        proc_remove(ent);
+}
+
+module_init(init);
+module_exit(cleanup);
+
--- a/drivers/exein_interface/Makefile
+++ b/drivers/exein_interface/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_EXEIN_INTERFACE)			+= exein_interface.o
+
--- a/drivers/exein_interface/Kconfig
+++ b/drivers/exein_interface/Kconfig
@@ -0,0 +1,4 @@
+config EXEIN_INTERFACE
+        tristate "Exein userspace interface support"
+        help
+        This driver provides Exein proc interface
--- a/security/Makefile
+++ b/security/Makefile
@@ -23,6 +23,7 @@
 obj-$(CONFIG_SECURITY_TOMOYO)		+= tomoyo/
 obj-$(CONFIG_SECURITY_APPARMOR)		+= apparmor/
 obj-$(CONFIG_SECURITY_YAMA)		+= yama/
+obj-$(CONFIG_SECURITY_EXEIN)		+= exein/
 obj-$(CONFIG_SECURITY_LOADPIN)		+= loadpin/
 obj-$(CONFIG_CGROUP_DEVICE)		+= device_cgroup.o
 
--- a/security/Kconfig
+++ b/security/Kconfig
@@ -174,6 +174,7 @@
 source security/apparmor/Kconfig
 source security/loadpin/Kconfig
 source security/yama/Kconfig
+source security/exein/Kconfig
 
 source security/integrity/Kconfig
 
--- a/security/exein/exein_struct_mappings.c
+++ b/security/exein/exein_struct_mappings.c
@@ -0,0 +1,270 @@
+#include "exein_struct_mappings.h"
+#include "exein_nn_defs_parts.h"
+
+
+
+uint16_t task_struct_get_pid(struct task_struct *arg1){
+	return arg1->pid;
+}
+
+void exein_map_string_to_features(const char * input, size_t string_length, size_t* index_p, exein_feature_t* features_arr){
+    if(input == NULL){
+        (*index_p)+=string_length;
+        return;
+    }
+
+    #if PARSE_STRINGS > 0
+        size_t i;
+        for (i = 0; i < string_length; i++)
+        {
+            features_arr[(*index_p)++] = input[i];
+        }
+    #endif
+}
+
+
+void exein_map_cred_to_features(const struct cred* input, size_t* index_p, exein_feature_t* features_arr){
+    /* Cred structure */
+    if(input == NULL){
+        (*index_p)+=STRUCT_CRED;
+        return;
+    }
+
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).uid.val;       /* real UID of the task */
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).gid.val;       /* real GID of the task */
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).suid.val;      /* saved UID of the task */
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).sgid.val;      /* saved GID of the task */
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).euid.val;      /* effective UID of the task */
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).egid.val;      /* effective GID of the task */
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).fsuid.val;     /* UID for VFS ops */
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).fsgid.val;     /* GID for VFS ops */
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).securebits;    /* SUID-less security management */
+}
+
+
+void exein_map_fown_struct_to_features(const struct fown_struct* input, size_t* index_p, exein_feature_t* features_arr){
+    /* Fown structure */
+    if(input == NULL){
+        (*index_p)+=STRUCT_FOWN_STRUCT;
+        return;
+    }
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).euid.val;
+}
+
+
+void exein_map_iattr_to_features(const struct iattr* input, size_t* index_p, exein_feature_t* features_arr){
+    /* Inode Attributes structure */
+    if(input == NULL){
+        (*index_p)+=STRUCT_IATTR;
+        return;
+    }
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).ia_valid;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).ia_mode;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).ia_uid.val;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).ia_gid.val;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).ia_size;
+}
+
+
+void exein_map_user_namespace_to_features(const struct user_namespace* input, size_t* index_p, exein_feature_t* features_arr){
+    /* User Namespace structure */
+    if(input == NULL){
+        (*index_p)+=STRUCT_USER_NAMESPACE;
+        return;
+    }
+
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).owner.val;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).group.val;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).flags;
+}
+
+
+void exein_map_vm_area_struct_to_features(const struct vm_area_struct * input, size_t* index_p, exein_feature_t* features_arr){
+    /* VM Area structure */
+    if(input == NULL){
+        (*index_p)+=STRUCT_VM_AREA_STRUCT;
+        return;
+    }
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_start;                  /* Start address within vm_mm. */
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_end;                    /* The first byte after the end address within vm_mm. */
+    //features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_page_prot.pgprot;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_flags;                  /* Flags: https://elixir.bootlin.com/linux/v5.1.11/source/include/linux/mm.h#L197 */
+
+    if(input->vm_mm == NULL){
+        (*index_p)+=STRUCT_VM_AREA_STRUCT-4;
+        return;
+    }
+    //features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->pgd->pgd;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->mm_users.counter;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->data_vm;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->exec_vm;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->stack_vm;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->def_flags;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->start_code;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->start_data;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->end_data;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->start_brk;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->brk;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->start_stack;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->arg_end;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->env_start;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->env_end;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).vm_mm->def_flags;
+}
+
+void exein_map_task_struct_to_features(const struct task_struct* input, size_t* index_p, exein_feature_t* features_arr){
+    /* Task structure */
+
+    /*
+        This is one of the most complex structures
+        Deeper analysis is needed
+    */
+
+    if(input == NULL){
+        (*index_p)+=STRUCT_TASK_STRUCT;
+        return;
+    }
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).flags;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).ptrace;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).pdeath_signal;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).in_execve;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).pid;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).tgid;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).stack;
+    //4.14.151
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).usage.counter;    /* indicates how many object are referencing this task */
+	  features_arr[(*index_p)++] = (exein_feature_t) (*input).static_prio;           /* static_prio is the starting priority which is not affected by the scheduler dynamics */
+    //features_arr[(*index_p)++] = (exein_feature_t) (*input).thread_pid->count.counter;
+
+    // TODO: Map the whole path?
+    // target->nameidata->path
+
+    // TODO: Map the whole inode struct?
+    // target->nameidata->inode
+
+    // TODO: Map the whole cred struct?
+    // input->cred->euid.val         /* effective process uid */
+
+}
+
+
+void exein_map_current_to_features(exein_feature_t* features_arr){
+    /* Identify current process */
+    /* Current is just an instance of strcut task_struct */
+    /* How to get the process name : https://stackoverflow.com/questions/5406942/linux-get-process-name-from-pid-within-kernel */
+    int index = EXEIN_HOOK_CURRENT_PROCESS_ARG1_POS;
+    features_arr[index++]  = (exein_feature_t) current->pid;
+    features_arr[index]  = (exein_feature_t) current->process_tag;
+
+}
+
+
+void exein_map_inode_to_features(const struct inode *input, size_t* index_p, exein_feature_t* features_arr){
+    /* Inode structure */
+    if(input == NULL){
+        (*index_p)+=STRUCT_INODE;
+        return;
+    }
+
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).i_mode;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).i_opflags;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).i_uid.val;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).i_gid.val;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).i_flags;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).i_size;        /* Filesize */
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).i_ino;         /* Inode number */
+}
+
+
+void exein_map_dentry_to_features(const struct dentry *input, size_t* index_p, exein_feature_t* features_arr){
+    /* Dentry structure */
+    if(input == NULL){
+        (*index_p)+=STRUCT_DENTRY;
+        return;
+    }
+
+    //printk(EXEIN_PRINT_LEVEL "MAP dentry to features disabled\n");
+
+    // TODO:  Map the d_name qstr to features
+    // input->d_name;  // this is a struct qstr (quickstring)
+                    // it contains not only the dentry name but also the hash. Which is better in our case
+    // In case we use the full name : exein_map_string_to_features(fullname, 768, index_p, features_arr);
+
+    exein_map_inode_to_features((*input).d_inode, index_p, features_arr);
+}
+
+
+void exein_map_file_to_features(const struct file *input, size_t* index_p, exein_feature_t* features_arr){
+    /* File structure */
+    if(input == NULL){
+        (*index_p)+=STRUCT_FILE;
+        return;
+    }
+
+    exein_map_dentry_to_features((*input).f_path.dentry, index_p, features_arr);
+
+    exein_map_inode_to_features((*input).f_inode, index_p, features_arr);
+
+    exein_map_fown_struct_to_features(&(*input).f_owner, index_p, features_arr);
+
+    u_int32_t trustworthiness = 0;
+
+    // Check if the file has a mnt
+    if (input->f_path.mnt != NULL)
+    {
+        // trustworthiness
+        char buffer[150];
+        char *path;
+
+        //printk(EXEIN_PRINT_LEVEL "MAP dentry path is not implemented [!]\n");
+        // path = dentry_path_raw(input->f_path.mnt->mnt_root, buffer, 150);
+        // if (strcmp("/", path) == 0 ) trustworthiness+=10;
+        // if (strcmp("squashfs",  input->f_path.mnt->mnt_sb->s_type->name) == 0 ) trustworthiness+=5;
+        // if (strcmp("rootfs",    input->f_path.mnt->mnt_sb->s_type->name) == 0 ) trustworthiness+=5;
+        // if (strcmp("cramfs",    input->f_path.mnt->mnt_sb->s_type->name) == 0 ) trustworthiness+=5;
+    }
+
+    features_arr[(*index_p)++] = (exein_feature_t) trustworthiness;
+
+    // features_arr[(*index_p)++] = (exein_feature_t) djb2(input); // Simple hash of the name
+
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).f_flags;
+    features_arr[(*index_p)++] = (exein_feature_t) (*input).f_mode;
+}
+
+
+void exein_map_kernel_cap_t_to_features(const struct kernel_cap_struct* input, size_t* index_p, exein_feature_t* features_arr){
+    if(input == NULL){
+        (*index_p)+=KERNEL_CAP_T;
+        return;
+    }
+
+    size_t i;
+    for (i = 0; i < KERNEL_CAP_T; i++)
+    {
+        features_arr[(*index_p)++] = (exein_feature_t) (*input).cap[i];
+    }
+}
+
+
+void exein_map_linux_binprm_to_features(const struct linux_binprm *input, size_t* index_p, exein_feature_t* features_arr){
+    //printk(EXEIN_PRINT_LEVEL "MAP linux_binprm to features not implemented\n");
+}
+
+//4.14.151
+// void exein_map_fs_parameter_to_features(const struct fs_parameter *input, size_t* index_p, exein_feature_t* features_arr){
+//     printk(EXEIN_PRINT_LEVEL "MAP fs_parameter to features not implemented\n");
+// }
+
+
+void exein_map_path_to_features(const struct path *input, size_t* index_p, exein_feature_t* features_arr){
+    //printk(EXEIN_PRINT_LEVEL "MAP path to features not implemented\n");
+}
+
+
+void exein_map_qstr_to_features(const struct qstr *input, size_t* index_p, exein_feature_t* features_arr){
+    //printk(EXEIN_PRINT_LEVEL "MAP qstr to features not implemented\n");
+}
+
+//4.14.151
+//void exein_map_fs_context_to_features(const struct fs_context * input, size_t* index_p, exein_feature_t* features_arr){}
--- a/security/exein/exein_lsm.c
+++ b/security/exein/exein_lsm.c
@@ -0,0 +1,3273 @@
+/*
+ * exein Linux Security Module
+ *
+ * Author: Alessandro Carminati <alessandro@exein.io>
+ *
+ * Copyright (C) 2019 Exein, SpA.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation.
+ *
+ */
+
+/********************************************************************************************************************************************/
+//#define EXEIN_PRINT_DEBUG
+#define EXEIN_STUFF_DEBUG
+/********************************************************************************************************************************************/
+
+#include "exein_nn_main.h"
+#include "exein_struct_mappings.h"
+#include "exein_nn_defs_comp.h"
+#include "exein_print_level.h"
+#include "exein_lsm.h"
+#include "exein_trust.h"
+
+#include <linux/lsm_hooks.h>
+#include <linux/binfmts.h>
+#include <net/sock.h>
+#include <linux/netlink.h>
+#include <linux/skbuff.h>
+#include <linux/delay.h>
+
+#if NNINPUT_SIZE ==4
+ #define EXEIN_PROT_TAG_POS 4
+#else
+ #define EXEIN_PROT_TAG_POS 3
+#endif
+
+
+#define NN_DEBUG 1
+#define CURRENT_PROCESS_FEATURES 1 // Took as a duplicate from exein_struct_mappings.c as a temporal solution
+#undef EXEIN_FS_CONTEXT_PARSE_PARAM_SWITCH   //this hook, newly implemented, generates some issues / not available on 4.14.151
+#undef EXEIN_FS_CONTEXT_DUP_SWITCH           //not available on 4.14.151
+#undef EXEIN_INODE_GETSECURITY_SWITCH
+#undef EXEIN_TASK_FREE_SWITCH
+#undef EXEIN_SOCKET_SOCK_RCV_SKB_SWITCH
+//#undef EXEIN_TASK_PRCTL_SWITCH
+//#ifdef CONFIG_DUP_TS_FIND_IN_LSM
+//extern int do_dup_td_find(int hook);
+//#endif
+
+//int	exein_debug=0;
+int	exein_mode=EXEIN_ONREQUEST;
+void	*exein_payload_process_ptr;
+void	*exein_register_status_get_ptr, *exein_pid_status_get_ptr;
+int	exein_interface_ready=0;
+struct	sock *exein_nl_sk_lsm=NULL;
+
+DEFINE_SPINLOCK(exein_pid_data_access);
+DEFINE_SPINLOCK(exein_reg_data_access);
+
+DEFINE_HASHTABLE(nl_peers,HASHTABLE_BITS);
+DEFINE_HASHTABLE(pid_repo,HASHTABLE_BITS);
+
+//EXPORT_SYMBOL(exein_debug);
+EXPORT_SYMBOL(exein_mode);
+EXPORT_SYMBOL(exein_payload_process_ptr);
+EXPORT_SYMBOL(exein_interface_ready);
+EXPORT_SYMBOL(exein_nl_sk_lsm);
+EXPORT_SYMBOL(exein_pid_status_get_ptr);
+EXPORT_SYMBOL(exein_register_status_get_ptr);
+
+#ifdef EXEIN_STUFF_DEBUG
+int exein_rndkey=SEEDRND;
+	EXPORT_SYMBOL(exein_rndkey);
+#endif
+
+static int hash_func_4_addrs(PTRSIZE data)
+{ //because the allignment, and other stuffs there's more entrophy starting from bit 5
+    return (data >> 6) & ((1<<HASHTABLE_BITS)-1);
+}
+static int hash_func_4_pids(int data)
+{
+    return data & ((1<<HASHTABLE_BITS)-1);
+}
+
+// this function gets called after a grace period has elapsed to deallocate the unlinked exein_pid_data elements.
+// to deallocate pids elements, the function needs to deallocate the container, ad all the buffers in the round buffer.
+static void pid_data_deferred_deletion(struct rcu_head *rcu) {
+	int 		i;
+	exein_pid_data	*b = container_of(rcu, exein_pid_data, rcu);
+
+//	printk(KERN_INFO "ExeinLSM[%d] - pid_data_deferred_deletion: delete pid_data [%d]@0x%p\n", current->pid, b->pid, b);
+	trace_printk("ExeinLSM[%d] - pid_data_deferred_deletion: delete pid_data [%d]@0x%p\n", current->pid, b->pid, b);
+	for (i=0; i<EXEIN_RINGBUFFER_SIZE; i++) kfree(b->hookdata[i]);
+	kfree(b);
+}
+
+static void reg_data_deferred_deletion(struct rcu_head *rcu) {
+	exein_reg_data  *b = container_of(rcu, exein_reg_data, rcu);
+	kfree(b);
+}
+
+int exein_register_status_get(char *buf, int size){ // TODO: Replace sprintf with snprintf. Use the size argument
+	int pos=0;
+        int bkt_cursor;
+        exein_reg_data *reg_data;
+
+	pos+=sprintf( (buf+pos),"pid, tag, time\n");
+	rcu_read_lock();
+	hash_for_each(nl_peers, bkt_cursor, reg_data, next)
+	pos+=sprintf( (buf+pos),"%d,%d,%llu\n", reg_data->pid, reg_data->tag, reg_data->timestamp);
+	rcu_read_unlock();
+	return pos;
+}
+
+int exein_pid_status_get(char *buf, int size){ // TODO: Replace sprintf with snprintf. Use the size argument
+	int pos=0, peerpid=0;
+	int bkt_cursor, pid_cursor;
+	exein_reg_data *reg_data;
+	exein_pid_data *pid_data;
+
+	pos+=sprintf( (buf+pos),"pid, tag, ts_addr, peer_pid\n");
+	rcu_read_lock();
+	hash_for_each(pid_repo, pid_cursor, pid_data, next){
+		hash_for_each(nl_peers, bkt_cursor, reg_data, next) if (reg_data->tag==pid_data->tag) peerpid=reg_data->pid;
+		pos+=sprintf( (buf+pos),"%d,%d,%x,%d\n", pid_data->pid, pid_data->tag, pid_data->task_struct_addr, peerpid);
+		}
+	rcu_read_unlock();
+	return pos;
+}
+
+
+
+// each time this function is triggered it scans the registration hash and select the first expired item if any.
+// if more than one exein agent is registered, and more than one expires, for example during the shutdown, it could be
+// too much delete everything in a single hook slot.
+void exein_delete_expired_regs(void){
+	int			bkt_cursor, pid_cursor;
+	exein_reg_data		*reg_data;
+	exein_pid_data          *pid_data;
+	int 			reg_2del_found=0;
+
+	// scans registration hashes and find first expired item
+	rcu_read_lock();
+	hash_for_each_rcu(nl_peers, bkt_cursor, reg_data, next){
+		if (jiffies_64-reg_data->timestamp>EXEIN_REG_DURATION){
+			reg_2del_found=1;
+			break;
+			}
+		}
+	rcu_read_unlock();
+
+	if (reg_2del_found){				// if one is found, it is possible to start a critical section with locks.
+							// in this critical section is mandatory to search for the expired regs again,with locks, just to be sure that in
+							// the meantime nothing has changed.
+		spin_lock_bh(&exein_reg_data_access);
+		hash_for_each_rcu(nl_peers, bkt_cursor, reg_data, next){
+			if (jiffies_64-reg_data->timestamp>EXEIN_REG_DURATION){
+				reg_2del_found=1;
+				break;
+				}
+			}
+		if (reg_data){				// if still there, just delete the expired reg, and schedule the function for free the memory.
+			hash_del_rcu(&reg_data->next);
+			call_rcu(&reg_data->rcu, reg_data_deferred_deletion);
+			}
+		spin_unlock_bh(&exein_reg_data_access);	//unlock the data structure either case, and do it asap.
+		if (reg_data){				// if needed, deal with the unlinking of each pid_data element, associated with the previously selected
+							// reg item.
+			spin_lock_bh(&exein_pid_data_access);
+			DODEBUG(KERN_INFO "ExeinLSM - PeerID: %d Tag: %d is expired.\n", reg_data->pid, reg_data->tag, reg_data->timestamp);
+			hash_for_each_rcu(pid_repo, pid_cursor, pid_data, next){ // look at the PIDs we have, if found update the ring buffer
+				DODEBUG(KERN_INFO "ExeinLSM - exein_delete_expired_regs: delete pid_data [%d]@0x%p\n", pid_data->pid,  pid_data);
+				hash_del_rcu(&pid_data->next);
+				call_rcu(&pid_data->rcu, pid_data_deferred_deletion);
+				}
+			spin_unlock_bh(&exein_pid_data_access);
+			}
+
+		}
+}
+
+int exein_send_nl_msg(void *pl, int plsize, pid_t dst_pid){
+	struct sk_buff *skb_out;
+	struct nlmsghdr *nlh;
+	int err;
+
+	DODEBUG(KERN_INFO "ExeinLSM - exein_send_nl_msg pl=%p, size=%d, PID=%d\n", pl, plsize, dst_pid);
+	skb_out = nlmsg_new(sizeof(exein_prot_reply),0); //message to notify new pid.
+	if(!skb_out) {
+		printk(KERN_INFO "ExeinLSM - Failed to allocate new skb\n");
+		return -ENOBUFS; //if this goes wrong, there's no mean in collecting data. MLE won't ask for them
+		}
+	nlh=nlmsg_put(skb_out, 0, 0, NLMSG_DONE, plsize,0);
+	if (!nlh) {
+		nlmsg_free(skb_out);
+		printk(KERN_INFO "ExeinLSM - Failed to nlmsg_put\n");
+		return -ENOBUFS; //if this goes wrong, there's no mean in collecting data. MLE won't ask for them
+		}
+	NETLINK_CB(skb_out).dst_group = 0;
+
+	memcpy(nlmsg_data(nlh), pl, plsize); //TODO: Does not check for buffer overflows when copying to destination (CWE-120). Make sure destination can always hold the source data.
+	err = netlink_unicast(exein_nl_sk_lsm, skb_out, dst_pid, MSG_DONTWAIT); // MSG_DONTWAIT=0x40  //err=nlmsg_unicast(exein_nl_sk_lsm, skb_out, reg_data->pid);
+	if (err<0) {
+		printk(KERN_INFO "ExeinLSM - Failed to send unicast netlink message p=%d, err=%d\n", dst_pid,  err);
+		} else {
+			DODEBUG(KERN_INFO "ExeinLSM - Complete to send unicast netlink message p=%d\n", dst_pid);
+			}
+	return err;
+}
+
+/*return value
+	=0 indicates no answer is needed
+	=1 indicates module must provide ok answer
+	=2 indicates module must provide ko answer
+*/
+static int exein_payload_process(void *data, pid_t pid){
+	int retval=2;
+	int bkt_cursor, pidfound;
+	exein_reg_data *reg_data, *curr_data;
+	u16 curr_tag;
+
+
+	DODEBUG(KERN_INFO "ExeinLSM - exein_payload_process data@%p, from pid=%d\n", data, pid);
+	if ((((exein_prot_req_t *)data)->key == SEEDRND)){
+		switch (((exein_prot_req_t *)data)->message_id){
+		case EXEIN_PROT_REGISTRATION_ID:
+			curr_tag = ((exein_prot_req_t *)data)->tag;
+			DODEBUG(KERN_INFO "ExeinLSM - Registration request for tag [%d] from MLE (PID %d)\n", curr_tag, pid);
+			rcu_read_lock();
+			hash_for_each_rcu(nl_peers, bkt_cursor, curr_data, next){
+				if (curr_data->tag == curr_tag){
+					DODEBUG(KERN_INFO "ExeinLSM - Tag [%d] exists!\n", curr_tag);
+					retval=2;
+					rcu_read_unlock();
+					return retval;
+					}
+				}
+			rcu_read_unlock();
+			reg_data=kmalloc(sizeof(exein_reg_data),GFP_ATOMIC);
+			reg_data->pid=pid;
+			reg_data->tag=((exein_prot_req_t *)data)->tag;
+			reg_data->timestamp=jiffies_64;
+			reg_data->seqn=0;
+			spin_lock_bh(&exein_reg_data_access);
+			hash_add_rcu(nl_peers, &reg_data->next, hash_func_4_pids(reg_data->pid) );
+			spin_unlock_bh(&exein_reg_data_access);
+#ifdef EXEIN_PRINT_DEBUG
+			rcu_read_lock();
+			hash_for_each(nl_peers, bkt_cursor, reg_data, next) printk(KERN_INFO "ExeinLSM - PeerID: %d Tag: %d @time=%llu\n", reg_data->pid, reg_data->tag, reg_data->timestamp);
+			rcu_read_unlock();
+#endif
+			retval=1;
+			break;
+		case EXEIN_PROT_KEEPALIVE_ID: //in this section, the "curr_data->timestamp" is actually written, but considering that modern processors are able to write int64 atomically, this should not concur with any race.
+			rcu_read_lock();
+			hash_for_each_possible(nl_peers, curr_data, next, hash_func_4_pids(pid) ) {
+				if ((curr_data->tag==((exein_prot_req_t *)data)->tag)){
+					curr_data->timestamp=jiffies_64;
+					DODEBUG(KERN_INFO "ExeinLSM - MLE (PID %d) for tag [%d] registration updated\n", pid, ((exein_prot_req_t *)data)->tag);
+					retval=0;
+					rcu_read_unlock();
+					return retval;
+					}
+				}
+			rcu_read_unlock();
+			DODEBUG(KERN_INFO "ExeinLSM - Unknown MLE received: (PID %d) for tag [%d]\n", pid, ((exein_prot_req_t *)data)->tag);
+			retval=0;
+			break;
+		case EXEIN_PROT_BLOCK_ID:
+			DODEBUG(KERN_INFO "ExeinLSM - Block process (%d) request for tag [%d] from MLE (PID %d)\n", ((exein_prot_req_t *)data)->pid, ((exein_prot_req_t *)data)->tag, pid);
+			exein_mark_not_trusted(((exein_prot_req_t *)data)->tag, ((exein_prot_req_t *)data)->pid);
+			retval=0;
+			break;
+		case EXEIN_PROT_DATA_REQ:
+			DODEBUG(KERN_INFO "ExeinLSM - data request from MLE (MLE_PID %d, Requested_PID=%d)\n", pid,((exein_prot_req_t *)data)->pid);
+			//look4 data in the "storage" and send it back
+			pidfound=0;
+			//for each request a message have to be send back.
+			rcu_read_lock();
+			hash_for_each(nl_peers, bkt_cursor, reg_data, next){
+				if (((exein_prot_req_t *)data)->tag==reg_data->tag) {
+					reg_data->pending_request=1;
+					}
+				}
+			rcu_read_unlock();
+			retval=0;
+			break;
+		default:
+			DODEBUG(KERN_INFO "ExeinLSM - Request about tag [%d] from MLE (PID %d) payload pid %d padding %d", ((exein_prot_req_t *)data)->tag, pid, ((exein_prot_req_t *)data)->pid, ((exein_prot_req_t *)data)->padding);
+			retval=0;
+		}
+	} else printk(KERN_INFO "ExeinLSM - Wrong key, request discarded\n");
+
+return retval;
+}
+
+static void commit_data(exein_feature_t *data, int size, uint16_t *NNInput){
+	int bkt_cursor, err, pid_cursor, i, pid_found, reg_found, pl_cursor, buf_cursor;
+	exein_reg_data *reg_data;
+	exein_pid_data *pid_data;
+	exein_prot_reply msg_rpy;
+
+#ifdef EXEIN_PRINT_DEBUG_EXTREME
+	if (data[EXEIN_PROT_TAG_POS]!=0) printk(KERN_INFO "ExeinLSM - Commit data for tag %d\n", data[5]);
+#endif
+	if (data[EXEIN_PROT_TAG_POS]!=0){
+		switch (exein_mode){
+			case EXEIN_ONREQUEST:
+				pid_found=0;
+				reg_found=0;
+				rcu_read_lock();
+				hash_for_each_rcu(nl_peers, bkt_cursor, reg_data, next){
+					if ((data[EXEIN_PROT_TAG_POS]==reg_data->tag)) {
+						reg_found=1;
+						hash_for_each_rcu(pid_repo, pid_cursor, pid_data, next){	// look at the PIDs we have, if found update the ring buffer
+							if (CURRENT_ADDR==pid_data->task_struct_addr){	//check if current is hash item corresponds to the target
+								pid_found=1;
+								break;
+								}
+							}
+						break;
+						}
+					}
+				rcu_read_unlock();
+				if (reg_found) {
+					if (pid_found) {
+						if (pid_data->in_use==1) {
+							DODEBUG(KERN_INFO "ExeinLSM[TS=%llu] - pid[%d] pid_data@0x%p produced %d hook while in use!!!!!!!!!!\n", jiffies_64, current->pid, pid_data, NNInput[EXEIN_HOOK_ID_ARG1_POS]);
+							return;
+							}
+						data[EXEIN_PROT_TAG_POS]=NNInput[EXEIN_HOOK_ID_ARG1_POS];
+//						printk(KERN_INFO "ExeinLSM - commit_data reg_found=%d, pid_found=%d, reg_data=0x%p, pid_data=0x%p\n", reg_found, pid_found, reg_data, pid_data);
+/*ATTENTION HERE*/				spin_lock_bh(&pid_data->ring_buffer_lock); //TODO: verifythe short period between the rcu_read_unlock and the spinlock do ot generates races
+						pid_data->in_use=1;
+						pid_data->index++;
+						pid_data->index&=0x7f;
+						memcpy(pid_data->hookdata[pid_data->index], data, size*sizeof(exein_feature_t));
+						spin_unlock_bh(&pid_data->ring_buffer_lock);
+						if (reg_data->pending_request==1){
+							DODEBUG(KERN_INFO "ExeinLSM - since data feed has been requested, prepare payload to send data back to registered peer\n");
+							msg_rpy.msg_type = EXEIN_PROT_FEED_ID;
+							msg_rpy.seed = SEEDRND;
+							msg_rpy.seq=(u16) reg_data->seqn++;
+							msg_rpy.pid = pid_data->pid;
+							DODEBUG(KERN_INFO "ExeinLSM - Header details: Type=%d, seed=%d, seqn=%d, objpid=%d\n", msg_rpy.msg_type, msg_rpy.seed, msg_rpy.seq, msg_rpy.pid);
+							pl_cursor=0;
+							buf_cursor=pid_data->index;
+							buf_cursor=(buf_cursor+1)&0x7f;
+/*remove*/						if (pid_data->hookdata[pid_data->index]->features[3]==0) printk(KERN_INFO "ExeinLSM - <<WARNING>> <<WARNING>> Last Hook=0 detected <<WARNING>> <<WARNING>>\n");
+
+							for (pl_cursor=0; pl_cursor<EXEIN_RINGBUFFER_SIZE; pl_cursor++){
+								*((u16 *) msg_rpy.payload+pl_cursor)=pid_data->hookdata[buf_cursor]->features[3]; //hookid
+								DODEBUG(KERN_INFO "ExeinLSM - @buf[%d]<-rbuf[%d]=%04x\n", pl_cursor, buf_cursor, pid_data->hookdata[buf_cursor]->features[3]);
+								buf_cursor=(buf_cursor+1)&0x7f;
+								}
+//remove start
+//							{
+//							int offset =0x0;
+//							printk(KERN_INFO ">%d %d %d %d  %d %d %d %d  %d %d %d %d  %d %d %d %d<\n", *((u16 *) msg_rpy.payload+offset+0x0),*((u16 *) msg_rpy.payload+offset+0x1),*((u16 *) msg_rpy.payload+offset+0x2),*((u16 *) msg_rpy.payload+offset+0x3),*((u16 *) msg_rpy.payload+offset+0x4),*((u16 *) msg_rpy.payload+offset+0x5),*((u16 *) msg_rpy.payload+offset+0x6),*((u16 *) msg_rpy.payload+offset+0x7),*((u16 *) msg_rpy.payload+offset+0x8),*((u16 *) msg_rpy.payload+offset+0x9),*((u16 *) msg_rpy.payload+offset+0xa),*((u16 *) msg_rpy.payload+offset+0xb),*((u16 *) msg_rpy.payload+offset+0xc),*((u16 *) msg_rpy.payload+offset+0xd),*((u16 *) msg_rpy.payload+offset+0xe),*((u16 *) msg_rpy.payload+offset+0xf));offset+=0x10;
+//							printk(KERN_INFO ">%d %d %d %d  %d %d %d %d  %d %d %d %d  %d %d %d %d<\n", *((u16 *) msg_rpy.payload+offset+0x0),*((u16 *) msg_rpy.payload+offset+0x1),*((u16 *) msg_rpy.payload+offset+0x2),*((u16 *) msg_rpy.payload+offset+0x3),*((u16 *) msg_rpy.payload+offset+0x4),*((u16 *) msg_rpy.payload+offset+0x5),*((u16 *) msg_rpy.payload+offset+0x6),*((u16 *) msg_rpy.payload+offset+0x7),*((u16 *) msg_rpy.payload+offset+0x8),*((u16 *) msg_rpy.payload+offset+0x9),*((u16 *) msg_rpy.payload+offset+0xa),*((u16 *) msg_rpy.payload+offset+0xb),*((u16 *) msg_rpy.payload+offset+0xc),*((u16 *) msg_rpy.payload+offset+0xd),*((u16 *) msg_rpy.payload+offset+0xe),*((u16 *) msg_rpy.payload+offset+0xf));offset+=0x10;
+//							printk(KERN_INFO ">%d %d %d %d  %d %d %d %d  %d %d %d %d  %d %d %d %d<\n", *((u16 *) msg_rpy.payload+offset+0x0),*((u16 *) msg_rpy.payload+offset+0x1),*((u16 *) msg_rpy.payload+offset+0x2),*((u16 *) msg_rpy.payload+offset+0x3),*((u16 *) msg_rpy.payload+offset+0x4),*((u16 *) msg_rpy.payload+offset+0x5),*((u16 *) msg_rpy.payload+offset+0x6),*((u16 *) msg_rpy.payload+offset+0x7),*((u16 *) msg_rpy.payload+offset+0x8),*((u16 *) msg_rpy.payload+offset+0x9),*((u16 *) msg_rpy.payload+offset+0xa),*((u16 *) msg_rpy.payload+offset+0xb),*((u16 *) msg_rpy.payload+offset+0xc),*((u16 *) msg_rpy.payload+offset+0xd),*((u16 *) msg_rpy.payload+offset+0xe),*((u16 *) msg_rpy.payload+offset+0xf));offset+=0x10;
+//							printk(KERN_INFO ">%d %d %d %d  %d %d %d %d  %d %d %d %d  %d %d %d %d<\n", *((u16 *) msg_rpy.payload+offset+0x0),*((u16 *) msg_rpy.payload+offset+0x1),*((u16 *) msg_rpy.payload+offset+0x2),*((u16 *) msg_rpy.payload+offset+0x3),*((u16 *) msg_rpy.payload+offset+0x4),*((u16 *) msg_rpy.payload+offset+0x5),*((u16 *) msg_rpy.payload+offset+0x6),*((u16 *) msg_rpy.payload+offset+0x7),*((u16 *) msg_rpy.payload+offset+0x8),*((u16 *) msg_rpy.payload+offset+0x9),*((u16 *) msg_rpy.payload+offset+0xa),*((u16 *) msg_rpy.payload+offset+0xb),*((u16 *) msg_rpy.payload+offset+0xc),*((u16 *) msg_rpy.payload+offset+0xd),*((u16 *) msg_rpy.payload+offset+0xe),*((u16 *) msg_rpy.payload+offset+0xf));offset+=0x10;
+//
+//							printk(KERN_INFO ">%d %d %d %d  %d %d %d %d  %d %d %d %d  %d %d %d %d<\n", *((u16 *) msg_rpy.payload+offset+0x0),*((u16 *) msg_rpy.payload+offset+0x1),*((u16 *) msg_rpy.payload+offset+0x2),*((u16 *) msg_rpy.payload+offset+0x3),*((u16 *) msg_rpy.payload+offset+0x4),*((u16 *) msg_rpy.payload+offset+0x5),*((u16 *) msg_rpy.payload+offset+0x6),*((u16 *) msg_rpy.payload+offset+0x7),*((u16 *) msg_rpy.payload+offset+0x8),*((u16 *) msg_rpy.payload+offset+0x9),*((u16 *) msg_rpy.payload+offset+0xa),*((u16 *) msg_rpy.payload+offset+0xb),*((u16 *) msg_rpy.payload+offset+0xc),*((u16 *) msg_rpy.payload+offset+0xd),*((u16 *) msg_rpy.payload+offset+0xe),*((u16 *) msg_rpy.payload+offset+0xf));offset+=0x10;
+//							printk(KERN_INFO ">%d %d %d %d  %d %d %d %d  %d %d %d %d  %d %d %d %d<\n", *((u16 *) msg_rpy.payload+offset+0x0),*((u16 *) msg_rpy.payload+offset+0x1),*((u16 *) msg_rpy.payload+offset+0x2),*((u16 *) msg_rpy.payload+offset+0x3),*((u16 *) msg_rpy.payload+offset+0x4),*((u16 *) msg_rpy.payload+offset+0x5),*((u16 *) msg_rpy.payload+offset+0x6),*((u16 *) msg_rpy.payload+offset+0x7),*((u16 *) msg_rpy.payload+offset+0x8),*((u16 *) msg_rpy.payload+offset+0x9),*((u16 *) msg_rpy.payload+offset+0xa),*((u16 *) msg_rpy.payload+offset+0xb),*((u16 *) msg_rpy.payload+offset+0xc),*((u16 *) msg_rpy.payload+offset+0xd),*((u16 *) msg_rpy.payload+offset+0xe),*((u16 *) msg_rpy.payload+offset+0xf));offset+=0x10;
+//							printk(KERN_INFO ">%d %d %d %d  %d %d %d %d  %d %d %d %d  %d %d %d %d<\n", *((u16 *) msg_rpy.payload+offset+0x0),*((u16 *) msg_rpy.payload+offset+0x1),*((u16 *) msg_rpy.payload+offset+0x2),*((u16 *) msg_rpy.payload+offset+0x3),*((u16 *) msg_rpy.payload+offset+0x4),*((u16 *) msg_rpy.payload+offset+0x5),*((u16 *) msg_rpy.payload+offset+0x6),*((u16 *) msg_rpy.payload+offset+0x7),*((u16 *) msg_rpy.payload+offset+0x8),*((u16 *) msg_rpy.payload+offset+0x9),*((u16 *) msg_rpy.payload+offset+0xa),*((u16 *) msg_rpy.payload+offset+0xb),*((u16 *) msg_rpy.payload+offset+0xc),*((u16 *) msg_rpy.payload+offset+0xd),*((u16 *) msg_rpy.payload+offset+0xe),*((u16 *) msg_rpy.payload+offset+0xf));offset+=0x10;
+//							printk(KERN_INFO ">%d %d %d %d  %d %d %d %d  %d %d %d %d  %d %d %d %d<\n", *((u16 *) msg_rpy.payload+offset+0x0),*((u16 *) msg_rpy.payload+offset+0x1),*((u16 *) msg_rpy.payload+offset+0x2),*((u16 *) msg_rpy.payload+offset+0x3),*((u16 *) msg_rpy.payload+offset+0x4),*((u16 *) msg_rpy.payload+offset+0x5),*((u16 *) msg_rpy.payload+offset+0x6),*((u16 *) msg_rpy.payload+offset+0x7),*((u16 *) msg_rpy.payload+offset+0x8),*((u16 *) msg_rpy.payload+offset+0x9),*((u16 *) msg_rpy.payload+offset+0xa),*((u16 *) msg_rpy.payload+offset+0xb),*((u16 *) msg_rpy.payload+offset+0xc),*((u16 *) msg_rpy.payload+offset+0xd),*((u16 *) msg_rpy.payload+offset+0xe),*((u16 *) msg_rpy.payload+offset+0xf));offset+=0x10;
+//							}
+//remove end
+							err=exein_send_nl_msg(&msg_rpy, sizeof(exein_prot_reply), reg_data->pid); //sending message to userspace that feeds hookIDs for specified PID on Registered TAG.
+							if (err<0) printk(KERN_INFO "ExeinLSM - Failed to send unicast FEED netlink message p=%d, t=%d, seq=%d err=%d\n", reg_data->pid, reg_data->tag, msg_rpy.seq, err);
+								else {
+								reg_data->pending_request=0;
+								DODEBUG(KERN_INFO "ExeinLSM - Feed sent!\n");
+								}
+							}
+						pid_data->in_use=0;
+						} else {//the PID is not found, add a buffer for it and send netlink message about the event.
+							//Setup a netlink packet and send it on the netlink connection.
+//							printk(KERN_INFO "ExeinLSM - commit_data reg_found=%d, pid_found=%d, reg_data=0x%p, pid_data=0x%p\n", reg_found, pid_found, reg_data, pid_data);
+							DODEBUG(KERN_INFO "ExeinLSM - <****> the pid %d is not there it's necessary to insert it. (index=0) <- hookid=%d\n", data[2], data[3]); //to be removed.
+							//add buffer for the new pid
+							data[EXEIN_PROT_TAG_POS]=NNInput[EXEIN_HOOK_ID_ARG1_POS];
+							pid_data=kmalloc(sizeof(exein_pid_data), GFP_ATOMIC); // TODO: consider include this into while loop to be sure memory is allocated
+							pid_data->pid=data[2];				// Issue #2 marked permanently data[2] aka current->pid as not trusted, but at this stage, it is, and there's no alternative to it.
+							pid_data->tag=reg_data->tag;
+							pid_data->index=0;
+							pid_data->task_struct_addr= CURRENT_ADDR;
+							pid_data->in_use=1;
+							spin_lock_init(&pid_data->ring_buffer_lock);
+							for (i=0; i<EXEIN_RINGBUFFER_SIZE; i++) { //allocate all buffers
+								if (!(pid_data->hookdata[i] = kzalloc(sizeof(exein_pid_data_cell), GFP_ATOMIC))){
+									panic("no memory for pid_data ring buffer target_pid=%d, pid_data=%p", data[2], pid_data);
+									}
+								}
+							memcpy(pid_data->hookdata[0], data, size*sizeof(exein_feature_t));//TODO:Does not check for buffer overflows when copying to destination (CWE-120). Make sure destination can always hold the source data.
+
+							spin_lock_bh(&exein_pid_data_access);
+							hash_add_rcu(pid_repo, &pid_data->next, hash_func_4_addrs(pid_data->task_struct_addr) );
+							spin_unlock_bh(&exein_pid_data_access);
+//							printk(KERN_INFO "ExeinLSM[TS=%llu] - pid[%d] just spawned! hookpid_data@0x%p hookNo=%d\n", jiffies_64, current->pid, pid_data, NNInput[EXEIN_HOOK_ID_ARG1_POS]);
+							trace_printk("ExeinLSM[TS=%llu] - pid[%d] just spawned! hookpid_data@0x%p hookNo=%d\n", jiffies_64, current->pid, pid_data, NNInput[EXEIN_HOOK_ID_ARG1_POS]);
+							msg_rpy.msg_type = EXEIN_PROT_NEW_PID;
+							msg_rpy.seed = SEEDRND;
+							msg_rpy.seq=(u16) reg_data->seqn++;
+							msg_rpy.pid= reg_data->pid;
+							*((pid_t *) msg_rpy.payload) = pid_data->pid; // Cannot relay on data[2] aka current->pid which issue #2 proved to be not equal to pid_data->pid.
+							DODEBUG(KERN_INFO "*** ExeinLSM - EXEIN_PROT_NEW_PID p=%d\n", pid_data->pid);
+							err=exein_send_nl_msg(&msg_rpy, sizeof(exein_prot_reply), reg_data->pid); //sending message to userspace that new pid appeared for specified tag.
+							if (err<0) printk(KERN_INFO "ExeinLSM - Failed to send unicast NEW_PID netlink message p=%d, t=%d, seq=%d err=%d\n", reg_data->pid, reg_data->tag, msg_rpy.seq, err);
+								else DODEBUG(KERN_INFO "ExeinLSM - NEW_PID Message sent\n");
+							pid_data->in_use=0;
+							}
+					}
+				break;
+			case EXEIN_LIVE:
+				rcu_read_lock();
+				hash_for_each(nl_peers, bkt_cursor, reg_data, next){
+					if ((data[EXEIN_PROT_TAG_POS]==reg_data->tag)) {
+						data[EXEIN_PROT_TAG_POS]=NNInput[EXEIN_HOOK_ID_ARG1_POS]; //tag is used no more
+						data[size++]=(u16) reg_data->seqn++;
+						err=exein_send_nl_msg(data, size<<1, reg_data->pid);
+						}
+					}
+				rcu_read_unlock();
+				break;
+			default:
+				printk(KERN_ERR "ExeinLSM - LSM is working in an unknown mode!\n");
+			}
+		}
+//#ifdef CONFIG_DUP_TS_FIND_IN_LSM
+//	do_dup_td_find(NNInput[EXEIN_HOOK_ID_ARG1_POS]);
+//#endif
+}
+
+static void exein_prepare_send_data(size_t start_index, size_t end_index, uint16_t *NNInput){
+	exein_feature_t *buffer;
+	int i, pos=0;
+
+	buffer=kmalloc(1024,GFP_ATOMIC);
+	*(buffer+(pos++))=0x7845;							//[0]           Magic Number "Ex"
+	*(buffer+(pos++))=(u16) EXEIN_NN_INPUT_SIZE;					//[1]           Size of the big input array
+	*(buffer+(pos++))=(u16) NNInput[EXEIN_HOOK_CURRENT_PROCESS_ARG1_POS];		//[2]           Current PID
+	*(buffer+(pos++))=(u16) NNInput[EXEIN_HOOK_CURRENT_PROCESS_TAG_ARG1_POS];	//[3]           Current HookID  temporary TAG
+	*(buffer+(pos++))=(u16) start_index;						//[4]           Feature data start position within the array
+	*(buffer+(pos++))=(u16) end_index;						//[5]           Feature data end position within the array
+	for (i=2; i<end_index-start_index+2;i++){					//[6]~[n - n-1] Features
+		*(buffer+(pos++))=(u16) *(NNInput+i);
+		}									//[last]            sequence number
+
+        if (NNInput[EXEIN_HOOK_ID_ARG1_POS]==0) {
+		printk(KERN_INFO "ExeinLSM - hookid=0, start=%d, end=%d, pid=[%d]\n", start_index, end_index, NNInput[EXEIN_HOOK_CURRENT_PROCESS_ARG1_POS]);
+		//dump_stack();
+		}
+	commit_data(buffer, pos, NNInput);
+	kfree(buffer);
+}
+
+void exein_delete_pids(void){ //this function is called inside /kernel/exit.c:do_exit()
+	int			err,i, bkt_cursor;
+	exein_pid_data		*pid_data;
+	exein_reg_data		*reg_data;
+	exein_prot_reply	msg_rpy;
+
+//	printk(KERN_INFO "ExeinLSM[TS=%llu] - exein_delete_pids: delete pid_data [%d]\n", jiffies_64, current->pid);
+	trace_printk("ExeinLSM[TS=%llu] - exein_delete_pids: delete pid_data [%d] l4 %x(%d)\n", jiffies_64, current->pid, CURRENT_ADDR, sizeof(CURRENT_ADDR) );
+	if ((exein_mode==EXEIN_ONREQUEST)&&(current->process_tag!=0)){
+		rcu_read_lock();
+		hash_for_each_possible_rcu(pid_repo, pid_data, next, hash_func_4_addrs(CURRENT_ADDR) ){ // look at the PIDs we have, if found update the ring buffer
+			if (CURRENT_ADDR==pid_data->task_struct_addr){
+				if (pid_data) trace_printk("ExeinLSM[TS=%llu] - exein_delete_pids(found): pid_data=(pid=%d, ts_addr=%x, tag=%d, [...])\n", jiffies_64, pid_data->pid, pid_data->task_struct_addr, pid_data->tag);
+				hash_for_each_rcu(nl_peers, bkt_cursor, reg_data, next){
+					if (pid_data->tag==reg_data->tag) {
+						printk(KERN_INFO "ExeinLSM[TS=%llu] - exein_delete_pids: PID[%d] found @0x%p owned by %d at 0x%p\n", jiffies_64, current->pid, pid_data, reg_data->pid, reg_data);
+						trace_printk("ExeinLSM[TS=%llu] - exein_delete_pids: PID[%d] found @0x%p owned by %d at 0x%p\n", jiffies_64, current->pid, pid_data, reg_data->pid, reg_data);
+						break;
+						}
+					}
+				break;
+				}
+			}
+		rcu_read_unlock();
+		if ( pid_data && reg_data){
+//			printk(KERN_INFO "ExeinLSM - exein_delete_pids: send notification to %d pid %d died\n", reg_data->pid, current->pid);
+			printk(KERN_INFO "ExeinLSM - pid=%d is no more. Send a message back to tell it pid_data=%px, reg_data=%px\n",current->pid, pid_data, reg_data);
+			pid_data->in_use=1;
+			msg_rpy.msg_type = EXEIN_PROT_DEL_PID;
+			msg_rpy.seed = SEEDRND;
+			msg_rpy.seq=(u16) reg_data->seqn++;
+			msg_rpy.pid=reg_data->pid;
+			*((pid_t *) msg_rpy.payload) = pid_data->pid;
+			err=exein_send_nl_msg(&msg_rpy, sizeof(exein_prot_reply), reg_data->pid);
+			if (err<0) printk(KERN_INFO "ExeinLSM - Failed to send unicast DEL_PID netlink message p=%d, t=%d, seq=%d err=%d\n", reg_data->pid, reg_data->tag, msg_rpy.seq, err);
+			DODEBUG("ExeinLSM - pid %d removed from storage\n", current->pid);
+			spin_lock_bh(&exein_pid_data_access);
+			hash_del_rcu(&pid_data->next);
+			spin_unlock_bh(&exein_pid_data_access);
+			call_rcu(&pid_data->rcu, pid_data_deferred_deletion);
+//			printk(KERN_INFO "ExeinLSM[TS=%llu] - exein_delete_pids: delete pid_data [%d]@0x%p<\n", jiffies_64, pid_data->pid, pid_data);
+			trace_printk("ExeinLSM[TS=%llu] - exein_delete_pids: delete pid_data [%d]@0x%p<\n", jiffies_64, pid_data->pid, pid_data);
+			} else {
+				trace_printk("ExeinLSM[TS=%llu] - exein_delete_pids: WEIRD pid_data=%px, reg_data=%px\n", jiffies_64, pid_data, reg_data);
+				if (pid_data) trace_printk("ExeinLSM[TS=%llu] - exein_delete_pids: pid_data=(pid=%d, ts_addr=%x, tag=%d, [...])\n", jiffies_64, pid_data->pid, pid_data->task_struct_addr, pid_data->tag);
+				}
+		}
+}
+
+/**********************************************************************************************************************/
+#ifdef EXEIN_CAPGET_SWITCH
+static int exein_capget(struct task_struct *target, kernel_cap_t *effective, kernel_cap_t *inheritable, kernel_cap_t *permitted )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_CAPGET_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_CAPGET_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_task_struct_to_features(target, &feature_index, NNInput);
+    exein_map_kernel_cap_t_to_features(effective, &feature_index, NNInput);
+    exein_map_kernel_cap_t_to_features(inheritable, &feature_index, NNInput);
+    exein_map_kernel_cap_t_to_features(permitted, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_CAPGET_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_CAPSET_SWITCH
+static int exein_capset(struct cred *new, const struct cred *old, const kernel_cap_t *effective, const kernel_cap_t *inheritable, const kernel_cap_t *permitted )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_CAPSET_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_CAPSET_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_cred_to_features(new, &feature_index, NNInput);
+    exein_map_cred_to_features(old, &feature_index, NNInput);
+    exein_map_kernel_cap_t_to_features(effective, &feature_index, NNInput);
+    exein_map_kernel_cap_t_to_features(inheritable, &feature_index, NNInput);
+    exein_map_kernel_cap_t_to_features(permitted, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_CAPSET_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_CAPABLE_SWITCH
+//4.14.151
+static int exein_capable(const struct cred *cred, struct user_namespace *ns, int cap, int opts )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_CAPABLE_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_CAPABLE_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_cred_to_features(cred, &feature_index, NNInput);
+    exein_map_user_namespace_to_features(ns, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) cap;
+    NNInput[feature_index++] = (exein_feature_t) opts;
+    feature_index=arg1_pos+EXEIN_CAPABLE_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_BPRM_SET_CREDS_SWITCH
+static int exein_bprm_set_creds(struct linux_binprm *bprm )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_BPRM_SET_CREDS_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_BPRM_SET_CREDS_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_linux_binprm_to_features(bprm, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_BPRM_SET_CREDS_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_BPRM_CHECK_SECURITY_SWITCH
+static int exein_bprm_check_security(struct linux_binprm *bprm )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_BPRM_CHECK_SECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_BPRM_CHECK_SECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_linux_binprm_to_features(bprm, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_BPRM_CHECK_SECURITY_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_BPRM_COMMITTING_CREDS_SWITCH
+static void exein_bprm_committing_creds(struct linux_binprm *bprm )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_BPRM_COMMITTING_CREDS_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_BPRM_COMMITTING_CREDS_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_linux_binprm_to_features(bprm, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_BPRM_COMMITTING_CREDS_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_BPRM_COMMITTED_CREDS_SWITCH
+static void exein_bprm_committed_creds(struct linux_binprm *bprm )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_BPRM_COMMITTED_CREDS_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_BPRM_COMMITTED_CREDS_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_linux_binprm_to_features(bprm, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_BPRM_COMMITTED_CREDS_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_FS_CONTEXT_DUP_SWITCH
+static int exein_fs_context_dup(struct fs_context *fc, struct fs_context *src_sc )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_FS_CONTEXT_DUP_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_FS_CONTEXT_DUP_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_fs_context_to_features(fc, &feature_index, NNInput);
+    exein_map_fs_context_to_features(src_sc, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_FS_CONTEXT_DUP_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_FS_CONTEXT_PARSE_PARAM_SWITCH
+static int exein_fs_context_parse_param(struct fs_context *fc, struct fs_parameter *param )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_FS_CONTEXT_PARSE_PARAM_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_FS_CONTEXT_PARSE_PARAM_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_fs_context_to_features(fc, &feature_index, NNInput);
+    exein_map_fs_parameter_to_features(param, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_FS_CONTEXT_PARSE_PARAM_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_PATH_UNLINK_SWITCH
+static int exein_path_unlink(const struct path *dir, struct dentry *dentry )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_PATH_UNLINK_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_PATH_UNLINK_ARG1_POS;
+    size_t feature_index = 3;
+
+//    exein_map_path_to_features(dir, &feature_index, NNInput);
+//    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_PATH_UNLINK_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_PATH_MKDIR_SWITCH
+static int exein_path_mkdir(const struct path *dir, struct dentry *dentry, umode_t mode )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_PATH_MKDIR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_PATH_MKDIR_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_path_to_features(dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) mode;
+    feature_index=arg1_pos+EXEIN_PATH_MKDIR_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_PATH_RMDIR_SWITCH
+static int exein_path_rmdir(const struct path *dir, struct dentry *dentry )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_PATH_RMDIR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_PATH_RMDIR_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_path_to_features(dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_PATH_RMDIR_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_PATH_MKNOD_SWITCH
+static int exein_path_mknod(const struct path *dir, struct dentry *dentry, umode_t mode, unsigned int dev )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_PATH_MKNOD_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_PATH_MKNOD_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_path_to_features(dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) mode;
+    NNInput[feature_index++] = (exein_feature_t) dev;
+    feature_index=arg1_pos+EXEIN_PATH_MKNOD_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_PATH_TRUNCATE_SWITCH
+static int exein_path_truncate(const struct path *path )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_PATH_TRUNCATE_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_PATH_TRUNCATE_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_path_to_features(path, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_PATH_TRUNCATE_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_PATH_SYMLINK_SWITCH
+static int exein_path_symlink(const struct path *dir, struct dentry *dentry, const char *old_name )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_PATH_SYMLINK_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_PATH_SYMLINK_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_path_to_features(dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    exein_map_string_to_features(old_name, DUMMY_STRING_MAX_LENGTH ,&feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_PATH_SYMLINK_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_PATH_LINK_SWITCH
+static int exein_path_link(struct dentry *old_dentry, const struct path *new_dir, struct dentry *new_dentry )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_PATH_LINK_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_PATH_LINK_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_dentry_to_features(old_dentry, &feature_index, NNInput);
+    exein_map_path_to_features(new_dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(new_dentry, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_PATH_LINK_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_PATH_RENAME_SWITCH
+static int exein_path_rename(const struct path *old_dir, struct dentry *old_dentry, const struct path *new_dir, struct dentry *new_dentry )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_PATH_RENAME_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_PATH_RENAME_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_path_to_features(old_dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(old_dentry, &feature_index, NNInput);
+    exein_map_path_to_features(new_dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(new_dentry, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_PATH_RENAME_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_PATH_CHMOD_SWITCH
+static int exein_path_chmod(const struct path *path, umode_t mode )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_PATH_CHMOD_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_PATH_CHMOD_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_path_to_features(path, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) mode;
+    feature_index=arg1_pos+EXEIN_PATH_CHMOD_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_PATH_CHOWN_SWITCH
+static int exein_path_chown(const struct path *path, kuid_t uid, kgid_t gid )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_PATH_CHOWN_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_PATH_CHOWN_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_path_to_features(path, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) uid.val;
+    NNInput[feature_index++] = (exein_feature_t) gid.val;
+    feature_index=arg1_pos+EXEIN_PATH_CHOWN_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_PATH_CHROOT_SWITCH
+static int exein_path_chroot(const struct path *path )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_PATH_CHROOT_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_PATH_CHROOT_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_path_to_features(path, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_PATH_CHROOT_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_ALLOC_SECURITY_SWITCH
+static int exein_inode_alloc_security(struct inode *inode )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_ALLOC_SECURITY_ID;
+//    printk(KERN_INFO "EXEIN_INODE_ALLOC_SECURITY hookid=%d, pid=%d\n", NNInput[EXEIN_HOOK_ID_ARG1_POS], NNInput[EXEIN_HOOK_CURRENT_PROCESS_ARG1_POS]);
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_ALLOC_SECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(inode, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_ALLOC_SECURITY_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_FREE_SECURITY_SWITCH
+static void exein_inode_free_security(struct inode *inode )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_FREE_SECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_FREE_SECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(inode, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_FREE_SECURITY_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_INIT_SECURITY_SWITCH
+static int exein_inode_init_security(struct inode *inode, struct inode *dir, const struct qstr *qstr, const char **name, void **value, size_t *len )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_INIT_SECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_INIT_SECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(inode, &feature_index, NNInput);
+    exein_map_inode_to_features(dir, &feature_index, NNInput);
+    exein_map_qstr_to_features(qstr, &feature_index, NNInput);
+    exein_map_string_to_features(*name, DUMMY_STRING_MAX_LENGTH, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) *len;
+    feature_index=arg1_pos+EXEIN_INODE_INIT_SECURITY_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_CREATE_SWITCH
+static int exein_inode_create(struct inode *dir, struct dentry *dentry, umode_t mode )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_CREATE_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_CREATE_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) mode;
+    feature_index=arg1_pos+EXEIN_INODE_CREATE_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_LINK_SWITCH
+static int exein_inode_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_LINK_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_LINK_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_dentry_to_features(old_dentry, &feature_index, NNInput);
+    exein_map_inode_to_features(dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(new_dentry, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_LINK_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_UNLINK_SWITCH
+static int exein_inode_unlink(struct inode *dir, struct dentry *dentry )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_UNLINK_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_UNLINK_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_UNLINK_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_SYMLINK_SWITCH
+static int exein_inode_symlink(struct inode *dir, struct dentry *dentry, const char *old_name )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_SYMLINK_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_SYMLINK_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    exein_map_string_to_features(old_name, DUMMY_STRING_MAX_LENGTH, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_SYMLINK_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_MKDIR_SWITCH
+static int exein_inode_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_MKDIR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_MKDIR_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) mode;
+    feature_index=arg1_pos+EXEIN_INODE_MKDIR_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_RMDIR_SWITCH
+static int exein_inode_rmdir(struct inode *dir, struct dentry *dentry )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_RMDIR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_RMDIR_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_RMDIR_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_MKNOD_SWITCH
+static int exein_inode_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_MKNOD_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_MKNOD_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) mode;
+    NNInput[feature_index++] = (exein_feature_t) dev;
+    feature_index=arg1_pos+EXEIN_INODE_MKNOD_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_RENAME_SWITCH
+static int exein_inode_rename(struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_RENAME_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_RENAME_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(old_dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(old_dentry, &feature_index, NNInput);
+    exein_map_inode_to_features(new_dir, &feature_index, NNInput);
+    exein_map_dentry_to_features(new_dentry, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_RENAME_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_READLINK_SWITCH
+static int exein_inode_readlink(struct dentry *dentry )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_READLINK_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_READLINK_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_READLINK_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_FOLLOW_LINK_SWITCH
+static int exein_inode_follow_link(struct dentry *dentry, struct inode *inode, bool rcu )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_FOLLOW_LINK_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_FOLLOW_LINK_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    exein_map_inode_to_features(inode, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) rcu;
+    feature_index=arg1_pos+EXEIN_INODE_FOLLOW_LINK_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_PERMISSION_SWITCH
+static int exein_inode_permission(struct inode *inode, int mask )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_PERMISSION_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_PERMISSION_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(inode, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) mask;
+    feature_index=arg1_pos+EXEIN_INODE_PERMISSION_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_SETATTR_SWITCH
+static int exein_inode_setattr(struct dentry *dentry, struct iattr *attr )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_SETATTR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_SETATTR_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    exein_map_iattr_to_features(attr, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_SETATTR_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_GETATTR_SWITCH
+static int exein_inode_getattr(const struct path *path )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_GETATTR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_GETATTR_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_path_to_features(path, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_GETATTR_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_SETATTR_SWITCH
+static int exein_inode_setxattr(struct dentry *dentry, const char *name, const void *value, size_t size, int flags )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_SETATTR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_SETATTR_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    exein_map_string_to_features(name, DUMMY_STRING_MAX_LENGTH, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) size;
+    NNInput[feature_index++] = (exein_feature_t) flags;
+    feature_index=arg1_pos+EXEIN_INODE_SETATTR_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_POST_SETXATTR_SWITCH
+static void exein_inode_post_setxattr(struct dentry *dentry, const char *name, const void *value, size_t size, int flags )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_POST_SETXATTR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_POST_SETXATTR_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    exein_map_string_to_features(name, DUMMY_STRING_MAX_LENGTH, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) size;
+    NNInput[feature_index++] = (exein_feature_t) flags;
+    feature_index=arg1_pos+EXEIN_INODE_POST_SETXATTR_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_GETATTR_SWITCH
+static int exein_inode_getxattr(struct dentry *dentry, const char *name )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_GETATTR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_GETATTR_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    exein_map_string_to_features(name, DUMMY_STRING_MAX_LENGTH, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_GETATTR_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_LISTXATTR_SWITCH
+static int exein_inode_listxattr(struct dentry *dentry )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_LISTXATTR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_LISTXATTR_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_LISTXATTR_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_REMOVEXATTR_SWITCH
+static int exein_inode_removexattr(struct dentry *dentry, const char *name )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_REMOVEXATTR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_REMOVEXATTR_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    exein_map_string_to_features(name, DUMMY_STRING_MAX_LENGTH, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_REMOVEXATTR_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_NEED_KILLPRIV_SWITCH
+static int exein_inode_need_killpriv(struct dentry *dentry )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_NEED_KILLPRIV_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_NEED_KILLPRIV_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_NEED_KILLPRIV_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_KILLPRIV_SWITCH
+static int exein_inode_killpriv(struct dentry *dentry )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_KILLPRIV_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_KILLPRIV_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_KILLPRIV_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_GETSECURITY_SWITCH
+static int exein_inode_getsecurity(struct inode *inode, const char *name, void **buffer, bool alloc )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_GETSECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_GETSECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(inode, &feature_index, NNInput);
+    exein_map_string_to_features(name, DUMMY_STRING_MAX_LENGTH, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) alloc;
+    feature_index=arg1_pos+EXEIN_INODE_GETSECURITY_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_SETSECURITY_SWITCH
+static int exein_inode_setsecurity(struct inode *inode, const char *name, const void *value, size_t size, int flags )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_SETSECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_SETSECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(inode, &feature_index, NNInput);
+    exein_map_string_to_features(name, DUMMY_STRING_MAX_LENGTH, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) size;
+    NNInput[feature_index++] = (exein_feature_t) flags;
+    feature_index=arg1_pos+EXEIN_INODE_SETSECURITY_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_LISTSECURITY_SWITCH
+static int exein_inode_listsecurity(struct inode *inode, char *buffer, size_t buffer_size )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_LISTSECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_LISTSECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(inode, &feature_index, NNInput);
+    exein_map_string_to_features(buffer, buffer_size, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_LISTSECURITY_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_GETSECID_SWITCH
+static void exein_inode_getsecid(struct inode *inode, u32 *secid )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_GETSECID_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_GETSECID_ID;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(inode, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) *secid;
+    feature_index=arg1_pos+EXEIN_INODE_GETSECID_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_COPY_UP_SWITCH
+static int exein_inode_copy_up(struct dentry *src, struct cred **new )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_COPY_UP_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_COPY_UP_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_dentry_to_features(src, &feature_index, NNInput);
+    exein_map_cred_to_features(*new, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_COPY_UP_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_COPY_UP_XATTR_SWITCH
+static int exein_inode_copy_up_xattr(const char *name )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_COPY_UP_XATTR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_COPY_UP_XATTR_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_string_to_features(name, DUMMY_STRING_MAX_LENGTH, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_COPY_UP_XATTR_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+/**
+ * exein_file_open - validate file_open calls
+ * @file: descriptor of the file
+ *
+ * stores the filename counter in the rbtree
+ * Returns 0 .
+ */
+#ifdef EXEIN_FILE_OPEN_SWITCH
+//4.14.151
+static int exein_file_open(struct file *file, const struct cred *cred)
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_FILE_OPEN_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_FILE_OPEN_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_file_to_features(file, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_FILE_OPEN_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_FILE_PERMISSION_SWITCH
+static int exein_file_permission(struct file *file, int mask)
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_FILE_PERMISSION_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_FILE_PERMISSION_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_file_to_features(file, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) mask;
+    feature_index=arg1_pos+EXEIN_FILE_PERMISSION_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_FILE_ALLOC_SECURITY_SWITCH
+static int exein_file_alloc_security(struct file *file )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_FILE_ALLOC_SECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_FILE_ALLOC_SECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_file_to_features(file, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_FILE_ALLOC_SECURITY_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_FILE_FREE_SECURITY_SWITCH
+static void exein_file_free_security(struct file *file )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_FILE_FREE_SECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_FILE_FREE_SECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_file_to_features(file, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_FILE_FREE_SECURITY_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_FILE_IOCTL_SWITCH
+static int exein_file_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_FILE_IOCTL_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_FILE_IOCTL_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_file_to_features(file, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) cmd;
+    NNInput[feature_index++] = (exein_feature_t) arg;
+    feature_index=arg1_pos+EXEIN_FILE_IOCTL_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_FILE_MPROTECT_SWITCH
+static int exein_file_mprotect(struct vm_area_struct *vma, unsigned long reqprot, unsigned long prot )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_FILE_MPROTECT_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_FILE_MPROTECT_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_vm_area_struct_to_features(vma, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) reqprot;
+    NNInput[feature_index++] = (exein_feature_t) prot;
+    feature_index=arg1_pos+EXEIN_FILE_MPROTECT_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_FILE_LOCK_SWITCH
+static int exein_file_lock(struct file *file, unsigned int cmd )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_FILE_LOCK_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_FILE_LOCK_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_file_to_features(file, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) cmd;
+    feature_index=arg1_pos+EXEIN_FILE_LOCK_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_FILE_FCNTL_SWITCH
+static int exein_file_fcntl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_FILE_FCNTL_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_FILE_FCNTL_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_file_to_features(file, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) cmd;
+    NNInput[feature_index++] = (exein_feature_t) arg;
+    feature_index=arg1_pos+EXEIN_FILE_FCNTL_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_FILE_SET_FOWNER_SWITCH
+static void exein_file_set_fowner(struct file *file )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_FILE_SET_FOWNER_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_FILE_SET_FOWNER_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_file_to_features(file, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_FILE_SET_FOWNER_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_FILE_SEND_SIGIOTASK_SWITCH
+static int exein_file_send_sigiotask(struct task_struct *tsk, struct fown_struct *fown, int sig )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_FILE_SEND_SIGIOTASK_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_FILE_SEND_SIGIOTASK_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_task_struct_to_features(tsk, &feature_index, NNInput);
+    exein_map_fown_struct_to_features(fown, &feature_index, NNInput);
+    NNInput[feature_index++] = (exein_feature_t) sig;
+    feature_index=arg1_pos+EXEIN_FILE_SEND_SIGIOTASK_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_FILE_RECEIVE_SWITCH
+static int exein_file_receive(struct file *file )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_FILE_RECEIVE_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_FILE_RECEIVE_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_file_to_features(file, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_FILE_RECEIVE_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_INVALIDATE_SECCTX_SWITCH
+static void exein_inode_invalidate_secctx(struct inode *inode )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_INVALIDATE_SECCTX_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_INVALIDATE_SECCTX_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(inode, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_INVALIDATE_SECCTX_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_NOTIFYSECCTX_SWITCH
+static int exein_inode_notifysecctx(struct inode *inode, void *ctx, u32 ctxlen )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_NOTIFYSECCTX_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_NOTIFYSECCTX_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(inode, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_NOTIFYSECCTX_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_SETSECCTX_SWITCH
+static int exein_inode_setsecctx(struct dentry *dentry, void *ctx, u32 ctxlen )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_SETSECCTX_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_SETSECCTX_ARG1_POS;
+    size_t feature_index = 3;
+
+    exein_map_dentry_to_features(dentry, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_SETSECCTX_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_INODE_GETSECCTX_SWITCH
+static int exein_inode_getsecctx(struct inode *inode, void **ctx, u32 *ctxlen )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_INODE_GETSECCTX_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_INODE_GETSECCTX_ID;
+    size_t feature_index = 3;
+
+    exein_map_inode_to_features(inode, &feature_index, NNInput);
+    feature_index=arg1_pos+EXEIN_INODE_GETSECCTX_SIZE;
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+/********************************************************************************************/
+
+#ifdef EXEIN_SOCKET_POST_CREATE_SWITCH
+static int exein_socket_post_create(struct socket * arg1, int arg2, int arg3, int arg4, int arg5 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_POST_CREATE_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_POST_CREATE_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_POST_CREATE_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_SOCKETPAIR_SWITCH
+static int exein_socket_socketpair(struct socket * arg1, struct socket * arg2 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_SOCKETPAIR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_SOCKETPAIR_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_SOCKETPAIR_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_BIND_SWITCH
+static int exein_socket_bind(struct socket * arg1, struct sockaddr * arg2, int arg3 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_BIND_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_BIND_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_BIND_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_CONNECT_SWITCH
+static int exein_socket_connect(struct socket * arg1, struct sockaddr * arg2, int arg3 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_CONNECT_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_CONNECT_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_CONNECT_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_LISTEN_SWITCH
+static int exein_socket_listen(struct socket * arg1, int arg2 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_LISTEN_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_LISTEN_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_LISTEN_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_ACCEPT_SWITCH
+static int exein_socket_accept(struct socket * arg1, struct socket * arg2 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_ACCEPT_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_ACCEPT_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_ACCEPT_SIZE;
+/* end ---- specific mappings*/
+
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_SENDMSG_SWITCH
+static int exein_socket_sendmsg(struct socket * arg1, struct msghdr * arg2, int arg3 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_SENDMSG_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_SENDMSG_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_SENDMSG_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_RECVMSG_SWITCH
+static int exein_socket_recvmsg(struct socket * arg1, struct msghdr * arg2, int arg3, int arg4 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_RECVMSG_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_RECVMSG_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_RECVMSG_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_GETSOCKNAME_SWITCH
+static int exein_socket_getsockname(struct socket * arg1 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_GETSOCKNAME_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_GETSOCKNAME_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_GETSOCKNAME_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_GETPEERNAME_SWITCH
+static int exein_socket_getpeername(struct socket * arg1 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_GETPEERNAME_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_GETPEERNAME_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_GETPEERNAME_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_GETSOCKOPT_SWITCH
+static int exein_socket_getsockopt(struct socket * arg1, int arg2, int arg3 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_GETSOCKOPT_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_GETSOCKOPT_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_GETSOCKOPT_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_SETSOCKOPT_SWITCH
+static int exein_socket_setsockopt(struct socket * arg1, int arg2, int arg3 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_SETSOCKOPT_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_SETSOCKOPT_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_SETSOCKOPT_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_SHUTDOWN_SWITCH
+static int exein_socket_shutdown(struct socket * arg1, int arg2 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_SHUTDOWN_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_SHUTDOWN_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_SHUTDOWN_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_SOCK_RCV_SKB_SWITCH
+static int exein_socket_sock_rcv_skb(struct sock * arg1, struct sk_buff * arg2 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_SOCK_RCV_SKB_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_SOCK_RCV_SKB_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_SOCK_RCV_SKB_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_GETPEERSEC_STREAM_SWITCH
+static int exein_socket_getpeersec_stream(struct socket * arg1, char * arg2, int * arg3, unsigned arg4 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_GETPEERSEC_STREAM_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_GETPEERSEC_STREAM_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_GETPEERSEC_STREAM_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SOCKET_GETPEERSEC_DGRAM_SWITCH
+static int exein_socket_getpeersec_dgram(struct socket * arg1, struct sk_buff * arg2, u32 * arg3 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SOCKET_GETPEERSEC_DGRAM_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SOCKET_GETPEERSEC_DGRAM_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SOCKET_GETPEERSEC_DGRAM_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SK_ALLOC_SECURITY_SWITCH
+static int exein_sk_alloc_security(struct sock * arg1, int arg2, gfp_t arg3 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SK_ALLOC_SECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SK_ALLOC_SECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SK_ALLOC_SECURITY_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SK_FREE_SECURITY_SWITCH
+static void exein_sk_free_security(struct sock * arg1 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SK_FREE_SECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SK_FREE_SECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SK_FREE_SECURITY_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SK_CLONE_SECURITY_SWITCH
+static void exein_sk_clone_security(const struct sock * arg1, struct sock * arg2 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SK_CLONE_SECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SK_CLONE_SECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SK_CLONE_SECURITY_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SK_GETSECID_SWITCH
+static void exein_sk_getsecid(struct sock * arg1, u32 * arg2 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SK_GETSECID_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SK_GETSECID_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SK_GETSECID_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_BPF_SWITCH
+static int exein_bpf(int arg1, union bpf_attr * arg2, unsigned int arg3 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_BPF_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_BPF_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_BPF_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_BPF_MAP_SWITCH
+static int exein_bpf_map(struct bpf_map * arg1, fmode_t arg2 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_BPF_MAP_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_BPF_MAP_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_BPF_MAP_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_BPF_PROG_SWITCH
+static int exein_bpf_prog(struct bpf_prog * arg1 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_BPF_PROG_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_BPF_PROG_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_BPF_PROG_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_BPF_MAP_ALLOC_SECURITY_SWITCH
+static int exein_bpf_map_alloc_security(struct bpf_map * arg1 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_BPF_MAP_ALLOC_SECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_BPF_MAP_ALLOC_SECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_BPF_MAP_ALLOC_SECURITY_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_BPF_MAP_FREE_SECURITY_SWITCH
+static void exein_bpf_map_free_security(struct bpf_map * arg1 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_BPF_MAP_FREE_SECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_BPF_MAP_FREE_SECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_BPF_MAP_FREE_SECURITY_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_BPF_PROG_ALLOC_SECURITY_SWITCH
+static int exein_bpf_prog_alloc_security(struct bpf_prog_aux * arg1 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_BPF_PROG_ALLOC_SECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_BPF_PROG_ALLOC_SECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_BPF_PROG_ALLOC_SECURITY_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_BPF_PROG_FREE_SECURITY_SWITCH
+static void exein_bpf_prog_free_security(struct bpf_prog_aux * arg1 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_BPF_PROG_FREE_SECURITY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_BPF_PROG_FREE_SECURITY_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_BPF_PROG_FREE_SECURITY_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_ALLOC_SWITCH
+static int exein_task_alloc(struct task_struct * arg1, unsigned long arg2 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_ALLOC_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_ALLOC_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_ALLOC_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_FREE_SWITCH
+static void exein_task_free(struct task_struct * arg1 )
+{
+	exein_feature_t		NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+	NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_FREE_ID;
+	exein_map_current_to_features(NNInput);
+	size_t arg1_pos = EXEIN_TASK_FREE_ARG1_POS;
+	size_t feature_index = 3;
+/* start -- specific mappings*/ 
+	NNInput[3] = task_struct_get_pid(arg1);
+	feature_index=arg1_pos+EXEIN_TASK_FREE_SIZE;
+/* end ---- specific mappings*/
+	exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+	playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_FIX_SETUID_SWITCH
+static int exein_task_fix_setuid(struct cred * arg1, const struct cred * arg2, int arg3 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_FIX_SETUID_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_FIX_SETUID_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_FIX_SETUID_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_SETPGID_SWITCH
+static int exein_task_setpgid(struct task_struct * arg1, pid_t arg2 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_SETPGID_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_SETPGID_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_SETPGID_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_GETPGID_SWITCH
+static int exein_task_getpgid(struct task_struct * arg1 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_GETPGID_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_GETPGID_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_GETPGID_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_GETSID_SWITCH
+static int exein_task_getsid(struct task_struct * arg1 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_GETSID_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_GETSID_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_GETSID_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_GETSECID_SWITCH
+static void exein_task_getsecid(struct task_struct * arg1, u32 * arg2 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_GETSECID_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_GETSECID_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_GETSECID_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_SETNICE_SWITCH
+static int exein_task_setnice(struct task_struct * arg1, int arg2 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_SETNICE_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_SETNICE_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_SETNICE_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_SETIOPRIO_SWITCH
+static int exein_task_setioprio(struct task_struct * arg1, int arg2 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_SETIOPRIO_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_SETIOPRIO_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_SETIOPRIO_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_GETIOPRIO_SWITCH
+static int exein_task_getioprio(struct task_struct * arg1 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_GETIOPRIO_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_GETIOPRIO_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_GETIOPRIO_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_PRLIMIT_SWITCH
+static int exein_task_prlimit(const struct cred * arg1, const struct cred * arg2, unsigned int arg3 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_PRLIMIT_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_PRLIMIT_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_PRLIMIT_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_SETRLIMIT_SWITCH
+static int exein_task_setrlimit(struct task_struct * arg1, unsigned int arg2, struct rlimit * arg3 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_SETRLIMIT_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_SETRLIMIT_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_SETRLIMIT_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_SETSCHEDULER_SWITCH
+static int exein_task_setscheduler(struct task_struct * arg1 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_SETSCHEDULER_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_SETSCHEDULER_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_SETSCHEDULER_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_GETSCHEDULER_SWITCH
+static int exein_task_getscheduler(struct task_struct * arg1 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_GETSCHEDULER_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_GETSCHEDULER_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_GETSCHEDULER_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_MOVEMEMORY_SWITCH
+static int exein_task_movememory(struct task_struct * arg1 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_MOVEMEMORY_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_MOVEMEMORY_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_MOVEMEMORY_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_KILL_SWITCH
+//4.14.151
+static int exein_task_kill(struct task_struct * arg1, struct siginfo * arg2, int arg3, u32 secid)
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_KILL_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_KILL_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_KILL_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_PRCTL_SWITCH
+static int exein_task_prctl(int arg1, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_PRCTL_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_PRCTL_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_PRCTL_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_TASK_TO_INODE_SWITCH
+static void exein_task_to_inode(struct task_struct * arg1, struct inode * arg2 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_TASK_TO_INODE_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_TASK_TO_INODE_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_TASK_TO_INODE_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_GETPROCATTR_SWITCH
+static int exein_getprocattr(struct task_struct * arg1, char * arg2, char ** arg3 )
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_GETPROCATTR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_GETPROCATTR_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_GETPROCATTR_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+#ifdef EXEIN_SETPROCATTR_SWITCH
+static int exein_setprocattr   (struct task_struct *p, char *arg1, void *arg2,  size_t arg3)
+{
+	exein_feature_t NNInput[EXEIN_NN_MAX_SIZE];
+
+#ifdef EXEIN_PRINT_DEBUG
+#endif
+    NNInput[EXEIN_HOOK_ID_ARG1_POS] = EXEIN_SETPROCATTR_ID;
+    exein_map_current_to_features(NNInput);
+    size_t arg1_pos = EXEIN_SETPROCATTR_ARG1_POS;
+    size_t feature_index = 3;
+
+/* start -- specific mappings*/
+    feature_index=arg1_pos+EXEIN_SETPROCATTR_SIZE;
+/* end ---- specific mappings*/
+
+    exein_prepare_send_data(arg1_pos, feature_index, NNInput);
+    return playnn(NNInput);
+}
+#endif
+
+
+
+/* Hooks setup */ static struct security_hook_list exein_hooks[] = {
+#ifdef EXEIN_CAPGET_SWITCH
+     LSM_HOOK_INIT(capget,                                exein_capget ),
+#endif
+#ifdef EXEIN_CAPSET_SWITCH
+     LSM_HOOK_INIT(capset,                                exein_capset ),
+#endif
+#ifdef EXEIN_CAPABLE_SWITCH
+     LSM_HOOK_INIT(capable,                               exein_capable ),
+#endif
+#ifdef EXEIN_BPRM_SET_CREDS_SWITCH
+     LSM_HOOK_INIT(bprm_set_creds,                        exein_bprm_set_creds ),
+#endif
+#ifdef EXEIN_BPRM_CHECK_SECURITY_SWITCH
+     LSM_HOOK_INIT(bprm_check_security,                   exein_bprm_check_security ),
+#endif
+#ifdef EXEIN_BPRM_COMMITTING_CREDS_SWITCH
+     LSM_HOOK_INIT(bprm_committing_creds,                 exein_bprm_committing_creds ),
+#endif
+#ifdef EXEIN_BPRM_COMMITTED_CREDS_SWITCH
+     LSM_HOOK_INIT(bprm_committed_creds,                  exein_bprm_committed_creds ),
+#endif
+#ifdef EXEIN_FS_CONTEXT_DUP_SWITCH
+     LSM_HOOK_INIT(fs_context_dup,                        exein_fs_context_dup ),
+#endif
+#ifdef EXEIN_FS_CONTEXT_PARSE_PARAM_SWITCH
+   LSM_HOOK_INIT(fs_context_parse_param,                  exein_fs_context_parse_param ),
+#endif
+#ifdef EXEIN_PATH_UNLINK_SWITCH
+     LSM_HOOK_INIT(path_unlink,                           exein_path_unlink ),
+#endif
+#ifdef EXEIN_PATH_MKDIR_SWITCH
+     LSM_HOOK_INIT(path_mkdir,                            exein_path_mkdir ),
+#endif
+#ifdef EXEIN_PATH_RMDIR_SWITCH
+     LSM_HOOK_INIT(path_rmdir,                            exein_path_rmdir ),
+#endif
+#ifdef EXEIN_PATH_MKNOD_SWITCH
+     LSM_HOOK_INIT(path_mknod,                            exein_path_mknod ),
+#endif
+#ifdef EXEIN_PATH_TRUNCATE_SWITCH
+     LSM_HOOK_INIT(path_truncate,                         exein_path_truncate ),
+#endif
+#ifdef EXEIN_PATH_SYMLINK_SWITCH
+     LSM_HOOK_INIT(path_symlink,                          exein_path_symlink ),
+#endif
+#ifdef EXEIN_PATH_LINK_SWITCH
+     LSM_HOOK_INIT(path_link,                             exein_path_link ),
+#endif
+#ifdef EXEIN_PATH_RENAME_SWITCH
+     LSM_HOOK_INIT(path_rename,                           exein_path_rename ),
+#endif
+#ifdef EXEIN_PATH_CHMOD_SWITCH
+     LSM_HOOK_INIT(path_chmod,                            exein_path_chmod ),
+#endif
+#ifdef EXEIN_PATH_CHOWN_SWITCH
+     LSM_HOOK_INIT(path_chown,                            exein_path_chown ),
+#endif
+#ifdef EXEIN_PATH_CHROOT_SWITCH
+     LSM_HOOK_INIT(path_chroot,                           exein_path_chroot ),
+#endif
+#ifdef EXEIN_INODE_ALLOC_SECURITY_SWITCH
+     LSM_HOOK_INIT(inode_alloc_security,                  exein_inode_alloc_security ),
+#endif
+#ifdef EXEIN_INODE_FREE_SECURITY_SWITCH
+     LSM_HOOK_INIT(inode_free_security,                   exein_inode_free_security ),
+#endif
+#ifdef EXEIN_INODE_INIT_SECURITY_SWITCH
+     LSM_HOOK_INIT(inode_init_security,                   exein_inode_init_security ),
+#endif
+#ifdef EXEIN_INODE_CREATE_SWITCH
+     LSM_HOOK_INIT(inode_create,                          exein_inode_create ),
+#endif
+#ifdef EXEIN_INODE_LINK_SWITCH
+     LSM_HOOK_INIT(inode_link,                            exein_inode_link ),
+#endif
+#ifdef EXEIN_INODE_UNLINK_SWITCH
+     LSM_HOOK_INIT(inode_unlink,                          exein_inode_unlink ),
+#endif
+#ifdef EXEIN_INODE_SYMLINK_SWITCH
+     LSM_HOOK_INIT(inode_symlink,                         exein_inode_symlink ),
+#endif
+#ifdef EXEIN_INODE_MKDIR_SWITCH
+     LSM_HOOK_INIT(inode_mkdir,                           exein_inode_mkdir ),
+#endif
+#ifdef EXEIN_INODE_RMDIR_SWITCH
+     LSM_HOOK_INIT(inode_rmdir,                           exein_inode_rmdir ),
+#endif
+#ifdef EXEIN_INODE_MKNOD_SWITCH
+     LSM_HOOK_INIT(inode_mknod,                           exein_inode_mknod ),
+#endif
+#ifdef EXEIN_INODE_RENAME_SWITCH
+     LSM_HOOK_INIT(inode_rename,                          exein_inode_rename ),
+#endif
+#ifdef EXEIN_INODE_READLINK_SWITCH
+     LSM_HOOK_INIT(inode_readlink,                        exein_inode_readlink ),
+#endif
+#ifdef EXEIN_INODE_FOLLOW_LINK_SWITCH
+     LSM_HOOK_INIT(inode_follow_link,                     exein_inode_follow_link ),
+#endif
+#ifdef EXEIN_INODE_PERMISSION_SWITCH
+     LSM_HOOK_INIT(inode_permission,                      exein_inode_permission ),
+#endif
+#ifdef EXEIN_INODE_SETATTR_SWITCH
+     LSM_HOOK_INIT(inode_setattr,                         exein_inode_setattr ),
+#endif
+#ifdef EXEIN_INODE_GETATTR_SWITCH
+     LSM_HOOK_INIT(inode_getattr,                         exein_inode_getattr ),
+#endif
+#ifdef EXEIN_INODE_SETXATTR_SWITCH
+     LSM_HOOK_INIT(inode_setxattr,                        exein_inode_setxattr ),
+#endif
+#ifdef EXEIN_INODE_POST_SETXATTR_SWITCH
+     LSM_HOOK_INIT(inode_post_setxattr,                   exein_inode_post_setxattr ),
+#endif
+#ifdef EXEIN_INODE_GETXATTR_SWITCH
+     LSM_HOOK_INIT(inode_getxattr,                        exein_inode_getxattr ),
+#endif
+#ifdef EXEIN_INODE_LISTXATTR_SWITCH
+     LSM_HOOK_INIT(inode_listxattr,                       exein_inode_listxattr ),
+#endif
+#ifdef EXEIN_INODE_REMOVEXATTR_SWITCH
+     LSM_HOOK_INIT(inode_removexattr,                     exein_inode_removexattr ),
+#endif
+#ifdef EXEIN_INODE_NEED_KILLPRIV_SWITCH
+     LSM_HOOK_INIT(inode_need_killpriv,                   exein_inode_need_killpriv ),
+#endif
+#ifdef EXEIN_INODE_KILLPRIV_SWITCH
+     LSM_HOOK_INIT(inode_killpriv,                        exein_inode_killpriv ),
+#endif
+#ifdef EXEIN_INODE_GETSECURITY_SWITCH
+     LSM_HOOK_INIT(inode_getsecurity,                     exein_inode_getsecurity ),
+#endif
+#ifdef EXEIN_INODE_SETSECURITY_SWITCH
+     LSM_HOOK_INIT(inode_setsecurity,                     exein_inode_setsecurity ),
+#endif
+#ifdef EXEIN_INODE_LISTSECURITY_SWITCH
+     LSM_HOOK_INIT(inode_listsecurity,                    exein_inode_listsecurity ),
+#endif
+#ifdef EXEIN_INODE_GETSECID_SWITCH
+     LSM_HOOK_INIT(inode_getsecid,                        exein_inode_getsecid ),
+#endif
+#ifdef EXEIN_INODE_COPY_UP_SWITCH
+     LSM_HOOK_INIT(inode_copy_up,                         exein_inode_copy_up ),
+#endif
+#ifdef EXEIN_INODE_COPY_UP_XATTR_SWITCH
+     LSM_HOOK_INIT(inode_copy_up_xattr,                   exein_inode_copy_up_xattr ),
+#endif
+#ifdef EXEIN_FILE_PERMISSION_SWITCH
+     LSM_HOOK_INIT(file_permission,                       exein_file_permission ),
+#endif
+#ifdef EXEIN_FILE_ALLOC_SECURITY_SWITCH
+     LSM_HOOK_INIT(file_alloc_security,                   exein_file_alloc_security ),
+#endif
+#ifdef EXEIN_FILE_FREE_SECURITY_SWITCH
+     LSM_HOOK_INIT(file_free_security,                    exein_file_free_security ),
+#endif
+#ifdef EXEIN_FILE_IOCTL_SWITCH
+     LSM_HOOK_INIT(file_ioctl,                            exein_file_ioctl ),
+#endif
+#ifdef EXEIN_FILE_MPROTECT_SWITCH
+     LSM_HOOK_INIT(file_mprotect,                         exein_file_mprotect ),
+#endif
+#ifdef EXEIN_FILE_LOCK_SWITCH
+     LSM_HOOK_INIT(file_lock,                             exein_file_lock ),
+#endif
+#ifdef EXEIN_FILE_FCNTL_SWITCH
+     LSM_HOOK_INIT(file_fcntl,                            exein_file_fcntl ),
+#endif
+#ifdef EXEIN_FILE_SET_FOWNER_SWITCH
+     LSM_HOOK_INIT(file_set_fowner,                       exein_file_set_fowner ),
+#endif
+#ifdef EXEIN_FILE_SEND_SIGIOTASK_SWITCH
+     LSM_HOOK_INIT(file_send_sigiotask,                   exein_file_send_sigiotask ),
+#endif
+#ifdef EXEIN_FILE_RECEIVE_SWITCH
+     LSM_HOOK_INIT(file_receive,                          exein_file_receive ),
+#endif
+#ifdef EXEIN_FILE_OPEN_SWITCH
+     LSM_HOOK_INIT(file_open,                             exein_file_open ),
+#endif
+#ifdef EXEIN_INODE_INVALIDATE_SECCTX_SWITCH
+     LSM_HOOK_INIT(inode_invalidate_secctx,               exein_inode_invalidate_secctx ),
+#endif
+#ifdef EXEIN_INODE_NOTIFYSECCTX_SWITCH
+     LSM_HOOK_INIT(inode_notifysecctx,                    exein_inode_notifysecctx ),
+#endif
+#ifdef EXEIN_INODE_SETSECCTX_SWITCH
+     LSM_HOOK_INIT(inode_setsecctx,                       exein_inode_setsecctx ),
+#endif
+#ifdef EXEIN_INODE_GETSECCTX_SWITCH
+     LSM_HOOK_INIT(inode_getsecctx,                       exein_inode_getsecctx ),
+#endif
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#ifdef EXEIN_SOCKET_POST_CREATE_SWITCH
+    LSM_HOOK_INIT(socket_post_create,	exein_socket_post_create ),
+#endif
+
+#ifdef EXEIN_SOCKET_SOCKETPAIR_SWITCH
+    LSM_HOOK_INIT(socket_socketpair,	exein_socket_socketpair ),
+#endif
+
+#ifdef EXEIN_SOCKET_BIND_SWITCH
+    LSM_HOOK_INIT(socket_bind,	exein_socket_bind ),
+#endif
+
+#ifdef EXEIN_SOCKET_CONNECT_SWITCH
+    LSM_HOOK_INIT(socket_connect,	exein_socket_connect ),
+#endif
+
+#ifdef EXEIN_SOCKET_LISTEN_SWITCH
+    LSM_HOOK_INIT(socket_listen,	exein_socket_listen ),
+#endif
+
+#ifdef EXEIN_SOCKET_ACCEPT_SWITCH
+    LSM_HOOK_INIT(socket_accept,	exein_socket_accept ),
+#endif
+
+#ifdef EXEIN_SOCKET_SENDMSG_SWITCH
+    LSM_HOOK_INIT(socket_sendmsg,	exein_socket_sendmsg ),
+#endif
+
+#ifdef EXEIN_SOCKET_RECVMSG_SWITCH
+    LSM_HOOK_INIT(socket_recvmsg,	exein_socket_recvmsg ),
+#endif
+
+#ifdef EXEIN_SOCKET_GETSOCKNAME_SWITCH
+    LSM_HOOK_INIT(socket_getsockname,	exein_socket_getsockname ),
+#endif
+
+#ifdef EXEIN_SOCKET_GETPEERNAME_SWITCH
+    LSM_HOOK_INIT(socket_getpeername,	exein_socket_getpeername ),
+#endif
+
+#ifdef EXEIN_SOCKET_GETSOCKOPT_SWITCH
+    LSM_HOOK_INIT(socket_getsockopt,	exein_socket_getsockopt ),
+#endif
+
+#ifdef EXEIN_SOCKET_SETSOCKOPT_SWITCH
+    LSM_HOOK_INIT(socket_setsockopt,	exein_socket_setsockopt ),
+#endif
+
+#ifdef EXEIN_SOCKET_SHUTDOWN_SWITCH
+    LSM_HOOK_INIT(socket_shutdown,	exein_socket_shutdown ),
+#endif
+
+#ifdef EXEIN_SOCKET_SOCK_RCV_SKB_SWITCH
+    LSM_HOOK_INIT(socket_sock_rcv_skb,	exein_socket_sock_rcv_skb ),
+#endif
+
+#ifdef EXEIN_SOCKET_GETPEERSEC_STREAM_SWITCH
+    LSM_HOOK_INIT(socket_getpeersec_stream,	exein_socket_getpeersec_stream ),
+#endif
+
+#ifdef EXEIN_SOCKET_GETPEERSEC_DGRAM_SWITCH
+    LSM_HOOK_INIT(socket_getpeersec_dgram,	exein_socket_getpeersec_dgram ),
+#endif
+
+#ifdef EXEIN_SK_ALLOC_SECURITY_SWITCH
+    LSM_HOOK_INIT(sk_alloc_security,	exein_sk_alloc_security ),
+#endif
+
+#ifdef EXEIN_SK_FREE_SECURITY_SWITCH
+    LSM_HOOK_INIT(sk_free_security,	exein_sk_free_security ),
+#endif
+
+#ifdef EXEIN_SK_CLONE_SECURITY_SWITCH
+    LSM_HOOK_INIT(sk_clone_security,	exein_sk_clone_security ),
+#endif
+
+#ifdef EXEIN_SK_GETSECID_SWITCH
+    LSM_HOOK_INIT(sk_getsecid,	exein_sk_getsecid ),
+#endif
+
+#ifdef EXEIN_BPF_SWITCH
+    LSM_HOOK_INIT(bpf,	exein_bpf ),
+#endif
+
+#ifdef EXEIN_BPF_MAP_SWITCH
+    LSM_HOOK_INIT(bpf_map,	exein_bpf_map ),
+#endif
+
+#ifdef EXEIN_BPF_PROG_SWITCH
+    LSM_HOOK_INIT(bpf_prog,	exein_bpf_prog ),
+#endif
+
+#ifdef EXEIN_BPF_MAP_ALLOC_SECURITY_SWITCH
+    LSM_HOOK_INIT(bpf_map_alloc_security,	exein_bpf_map_alloc_security ),
+#endif
+
+#ifdef EXEIN_BPF_MAP_FREE_SECURITY_SWITCH
+    LSM_HOOK_INIT(bpf_map_free_security,	exein_bpf_map_free_security ),
+#endif
+
+#ifdef EXEIN_BPF_PROG_ALLOC_SECURITY_SWITCH
+    LSM_HOOK_INIT(bpf_prog_alloc_security,	exein_bpf_prog_alloc_security ),
+#endif
+
+#ifdef EXEIN_BPF_PROG_FREE_SECURITY_SWITCH
+    LSM_HOOK_INIT(bpf_prog_free_security,	exein_bpf_prog_free_security ),
+#endif
+
+#ifdef EXEIN_TASK_ALLOC_SWITCH
+    LSM_HOOK_INIT(task_alloc,	exein_task_alloc ),
+#endif
+
+#ifdef EXEIN_TASK_FREE_SWITCH
+    LSM_HOOK_INIT(task_free,	exein_task_free ),
+#endif
+
+#ifdef EXEIN_TASK_FIX_SETUID_SWITCH
+    LSM_HOOK_INIT(task_fix_setuid,	exein_task_fix_setuid ),
+#endif
+
+#ifdef EXEIN_TASK_SETPGID_SWITCH
+    LSM_HOOK_INIT(task_setpgid,	exein_task_setpgid ),
+#endif
+
+#ifdef EXEIN_TASK_GETPGID_SWITCH
+    LSM_HOOK_INIT(task_getpgid,	exein_task_getpgid ),
+#endif
+
+#ifdef EXEIN_TASK_GETSID_SWITCH
+    LSM_HOOK_INIT(task_getsid,	exein_task_getsid ),
+#endif
+
+#ifdef EXEIN_TASK_GETSECID_SWITCH
+    LSM_HOOK_INIT(task_getsecid,	exein_task_getsecid ),
+#endif
+
+#ifdef EXEIN_TASK_SETNICE_SWITCH
+    LSM_HOOK_INIT(task_setnice,	exein_task_setnice ),
+#endif
+
+#ifdef EXEIN_TASK_SETIOPRIO_SWITCH
+    LSM_HOOK_INIT(task_setioprio,	exein_task_setioprio ),
+#endif
+
+#ifdef EXEIN_TASK_GETIOPRIO_SWITCH
+    LSM_HOOK_INIT(task_getioprio,	exein_task_getioprio ),
+#endif
+
+#ifdef EXEIN_TASK_PRLIMIT_SWITCH
+    LSM_HOOK_INIT(task_prlimit,	exein_task_prlimit ),
+#endif
+
+#ifdef EXEIN_TASK_SETRLIMIT_SWITCH
+    LSM_HOOK_INIT(task_setrlimit,	exein_task_setrlimit ),
+#endif
+
+#ifdef EXEIN_TASK_SETSCHEDULER_SWITCH
+    LSM_HOOK_INIT(task_setscheduler,	exein_task_setscheduler ),
+#endif
+
+#ifdef EXEIN_TASK_GETSCHEDULER_SWITCH
+    LSM_HOOK_INIT(task_getscheduler,	exein_task_getscheduler ),
+#endif
+
+#ifdef EXEIN_TASK_MOVEMEMORY_SWITCH
+    LSM_HOOK_INIT(task_movememory,	exein_task_movememory ),
+#endif
+
+#ifdef EXEIN_TASK_KILL_SWITCH
+    LSM_HOOK_INIT(task_kill,	exein_task_kill ),
+#endif
+
+#ifdef EXEIN_TASK_PRCTL_SWITCH
+    LSM_HOOK_INIT(task_prctl,	exein_task_prctl ),
+#endif
+
+#ifdef EXEIN_TASK_TO_INODE_SWITCH
+    LSM_HOOK_INIT(task_to_inode,	exein_task_to_inode ),
+#endif
+
+#ifdef EXEIN_GETPROCATTR_SWITCH
+    LSM_HOOK_INIT(getprocattr,	exein_getprocattr ),
+#endif
+
+#ifdef EXEIN_SETPROCATTR_SWITCH
+    LSM_HOOK_INIT(setprocattr,	exein_setprocattr ),
+#endif
+};
+
+static int __init exein_init(void)
+{
+	pr_info("ExeinLSM - lsm is active: seed [%d]\n",SEEDRND);
+        exein_payload_process_ptr	=	&exein_payload_process;
+	exein_register_status_get_ptr	=	&exein_register_status_get;
+	exein_pid_status_get_ptr	=	&exein_pid_status_get;
+	security_add_hooks(exein_hooks, ARRAY_SIZE(exein_hooks));
+	hash_init(nl_peers);
+	hash_init(pid_repo);
+	return 0;
+}
+
+//4.14.151
+security_initcall(exein_init);
+
+//5.1.11
+// DEFINE_LSM(exein) = {
+// 	.name = "exein",
+// 	.init = exein_init,
+// };
--- a/security/exein/exein_nn_defs_parts.h
+++ b/security/exein/exein_nn_defs_parts.h
@@ -0,0 +1,101 @@
+/*
+   ------
+  / *    *
+ /   *  *  *
+(------     *
+ \   *  *  *
+  \ *    *
+   ------
+Exein
+*/
+#include <uapi/linux/capability.h>
+
+#define	DUMMY_STRING_MAX_LENGTH     0
+
+#define CURRENT_PROCESS_FEATURES    1
+#define BOOL                        1
+#define CHAR                        1
+#define CONST_CHAR                  CHAR
+#define CONST_STRUCT_CRED           STRUCT_CRED
+#define CONST_STRUCT_KERNEL_CAP_T   KERNEL_CAP_T
+#define CONST_STRUCT_PATH           1 //temporary
+#define CONST_STRUCT_QSTR           STRUCT_QSTR
+#define CONST_STRUCT_SUPER_BLOCK    1 //temporary
+#define CONST_STRUCT_TIMESPEC64     1 //temporary
+#define CONST_STRUCT_TIMEZONE       1 //temporary
+#define CONST_VOID                  1 //temporary
+#define CONST_STRUCT_REQUEST_SOCK   STRUCT_REQUEST_SOCK
+#define CONST_STRUCT_FLOWI          STRUCT_FLOWI
+#define CONST_STRUCT_SOCK           STRUCT_SOCK
+#define UNION_BPF_ATTR              1 //temporary
+#define DEV_T                       1 //temporary
+#define ENUM_KERNEL_LOAD_DATA_ID    1 //temporary
+#define ENUM_KERNEL_READ_FILE_ID    1 //temporary
+#define GFP_T                       1 //temporary
+#define INT                         1
+#define KERNEL_CAP_T                2 //_KERNEL_CAPABILITY_U32S
+#define KGID_T                      1 //temporary
+#define KUID_T                      1 //temporary
+#define LOFF_T                      1 //temporary
+#define LONG                        1 //temporary
+#define PID_T                       1 //temporary
+#define SHORT                       1 //temporary
+#define SIZE_T                      1 //temporary
+#define KEY_REF_T                   1 //temporary
+#define FMODE_T                     1 //temporary
+#define STRUCT_CRED                 9
+#define STRUCT_DENTRY               1 //temporary was 0
+#define STRUCT_FILE                 STRUCT_DENTRY + STRUCT_INODE + STRUCT_FOWN_STRUCT + 1
+#define STRUCT_FOWN_STRUCT          1
+#define STRUCT_FS_CONTEXT           DUMMY_STRING_MAX_LENGTH + STRUCT_DENTRY + STRUCT_USER_NAMESPACE + STRUCT_CRED + DUMMY_STRING_MAX_LENGTH + DUMMY_STRING_MAX_LENGTH + 6
+#define STRUCT_FS_PARAMETER         1 //temporary was 0
+#define STRUCT_IATTR                5
+#define STRUCT_INODE                7
+//4.14.151
+#define STRUCT_SIGINFO       1 //temporary
+#define STRUCT_KERN_IPC_PERM        1 //temporary
+#define STRUCT_LINUX_BINPRM         1 //temporary was 0
+#define STRUCT_MM_STRUCT            1 //temporary
+#define STRUCT_MSG_MSG              1 //temporary
+#define STRUCT_QSTR                 1 //temporary was 0
+#define STRUCT_RLIMIT               1 //temporary
+#define STRUCT_SEQ_FILE             1 //temporary
+#define STRUCT_SUPER_BLOCK          1 //temporary
+#define STRUCT_TASK_STRUCT         10
+#define STRUCT_USER_NAMESPACE       3
+#define STRUCT_VFSMOUNT             1 //temporary
+#define STRUCT_VM_AREA_STRUCT      20
+#define STRUCT_AUDIT_KRULE          1 //temporary
+//4.14.151
+#define STRUCT_AUDIT_CONTEXT        1 //temporary
+#define STRUCT_XFRM_STATE           1 //temporary
+#define STRUCT_XFRM_USER_SEC_CTX    1 //temporary
+#define STRUCT_XFRM_SEC_CTX         1 //temporary
+#define STRUCT_SOCK                 1 //temporary
+#define STRUCT_XFRM_POLICY          1 //temporary
+#define STRUCT_MSGHDR               1 //temporary
+#define STRUCT_SOCKADDR             1 //temporary
+#define STRUCT_SOCKET               1 //temporary
+#define STRUCT_KEY                  1 //temporary
+#define STRUCT_SK_BUFF              1 //temporary
+#define STRUCT_REQUEST_SOCK         1 //temporary
+#define STRUCT_SEMBUF               1 //temporary
+#define STRUCT_BPF_PROG_AUX         1 //temporary
+#define STRUCT_BPF_PROG             1 //temporary
+#define STRUCT_BPF_MAP              1 //temporary
+#define STRUCT_SCTP_ENDPOINT        1 //temporary
+#define STRUCT_FLOWI                1 //temporary
+#define UMODE_T                     1 //temporary
+#define UNSIGNED_INT                1
+#define UNSIGNED_LONG               1 //temporary
+#define VOID                        1 //temporary
+#define UNSIGNED                    1 //temporary
+#define U8                          1 //temporary
+#define U16                         1 //temporary
+#define U32                         1 //temporary
+#define U64                         1 //temporary
+//4.14.151
+#define STRUCT_SECURITY_MNT_OPTS    1 //temporary
+#define STRUCT_SEM_ARRAY            1 //temporary
+#define STRUCT_MSG_QUEUE            1 //temporary
+#define STRUCT_SHMID_KERNEL         1 //temporary
--- a/security/exein/Makefile
+++ b/security/exein/Makefile
@@ -0,0 +1,53 @@
+obj-$(CONFIG_SECURITY_EXEIN) := exein.o
+exein-y := exein_lsm.o exein_nn_main.o exein_struct_mappings.o exein_trust.o exein_nn_data.o
+ccflags-y := -Wno-declaration-after-statement -Wno-unused-function
+
+$(addprefix $(obj)/,$(exein-y)): $(obj)/exein_nn_defs.h
+$(addprefix $(obj)/,$(exein-y)): $(obj)/mkHookh_data/hooks.csv
+$(addprefix $(obj)/,$(exein-y)): $(obj)/mkHookh_data/hookspart.ini
+$(addprefix $(obj)/,$(exein-y)): $(obj)/exein_nn_defs_comp.h
+
+quiet_cmd_mkHooksh = GENH	$(srctree)/exein_nn_defs.h
+	cmd_mkHooksh = $(obj)/../../scripts/exein/mkHookh/mkHookh \
+			$(obj)/mkHookh_data/hooks.ini \
+			$(obj)/mkHookh_data/config.ini A >$(srctree)/security/exein/exein_nn_data.c && \
+			$(obj)/../../scripts/exein/mkHookh/mkHookh \
+			$(obj)/mkHookh_data/hooks.ini \
+			$(obj)/mkHookh_data/config.ini Y >$(srctree)/security/exein/exein_nn_defs.h && \
+			chmod +x $(srctree)/scripts/exein/make_define_aliases.sh && \
+			$(srctree)/scripts/exein/make_define_aliases.sh >>$(srctree)/security/exein/exein_nn_defs.h
+
+quiet_cmd_mkHookhcomp = GENH	$(srctree)/exein_nn_defs_comp.h
+	cmd_mkHookhcomp = $(obj)/../../scripts/exein/mkHookhcomp/mkHookhcomp $(obj)/mkHookh_data/hookspart.ini $(obj)/mkHookh_data/config.ini >$(srctree)/security/exein/exein_nn_defs_comp.h
+
+quiet_cmd_csv2ini = MKINI	$(obj)/mkHookh_data/hookspart.ini
+	cmd_csv2ini = chmod +x $(srctree)/scripts/exein/csv2ini.sh && $(srctree)/scripts/exein/csv2ini.sh $(obj)/mkHookh_data/hooks.csv >$(obj)/mkHookh_data/hookspart.ini
+
+quiet_cmd_HeaderParser = PARSE	$(obj)/mkHookh_data/hooks.csv
+	cmd_HeaderParser = $(obj)/../../scripts/exein/HeaderParser/HeaderParser < $(srctree)/include/linux/lsm_hooks.h >$(obj)/mkHookh_data/hooks.csv
+
+
+
+targets += exein_nn_defs.h
+targets += hooks.csv
+targets += hookspart.ini
+targets += exein_nn_defs_comp.h
+
+$(obj)/exein_nn_defs_comp.h: $(obj)/mkHookh_data/hookspart.ini
+	$(call if_changed,mkHookhcomp)
+
+$(obj)/exein_nn_defs.h $(obj)/exein_nn_data.c: FORCE
+ifeq ($(wildcard $(obj)/mkHookh_data/.),)
+	cp -r $(srctree)/security/exein/mkHookh_data/ $(obj)
+endif
+	$(call if_changed,mkHooksh)
+
+$(obj)/mkHookh_data/hookspart.ini: $(obj)/mkHookh_data/hooks.csv
+	$(call if_changed,csv2ini)
+
+$(obj)/mkHookh_data/hooks.csv: FORCE
+	$(call if_changed,HeaderParser)
+
+$(obj)/exein_nn_defs.h: FORCE
+
+FORCE: ;
--- a/security/exein/exein_trust.h
+++ b/security/exein/exein_trust.h
@@ -0,0 +1,6 @@
+#include <linux/list.h>
+
+#include "exein_types.h"
+#include "exein_print_level.h"
+
+void exein_mark_not_trusted(uint16_t tag, pid_t pid);
--- a/security/exein/exein_lsm.h
+++ b/security/exein/exein_lsm.h
@@ -0,0 +1,83 @@
+#include <linux/types.h>
+#include <linux/hashtable.h>
+#include <linux/spinlock_types.h>
+#define EXEIN_REG_DURATION		2500
+#define EXEIN_PROT_REGISTRATION_ID	1
+#define EXEIN_PROT_KEEPALIVE_ID		2
+#define EXEIN_PROT_FEED_ID		3
+#define EXEIN_PROT_BLOCK_ID		4
+#define EXEIN_PROT_DATA_REQ		5
+#define EXEIN_PROT_NEW_PID		6
+#define EXEIN_PROT_DEL_PID		7
+#define EXEIN_PID_POS			1
+#define EXEIN_NN_MAX_SIZE		50
+#define EXEIN_RINGBUFFER_SIZE		(1<<7)
+#define EXEIN_FEATURE_NUM_MAX		35
+#define HASHTABLE_BITS			5
+
+#define EXEIN_ONREQUEST			0x80
+#define EXEIN_LIVE			0x81
+
+#ifdef EXEIN_PRINT_DEBUG
+#define DODEBUG( ... ) printk( __VA_ARGS__ );
+#else
+#define DODEBUG( ... ) do { } while(0)
+#endif
+
+#ifdef __LP64__
+#define CURRENT_ADDR ((u64) current)
+#define PTRSIZE u64
+#else
+#define CURRENT_ADDR ((u32) current)
+#define PTRSIZE u32
+#endif
+
+typedef struct {
+        u32			key;
+        u8			message_id;
+        u8			padding;
+        u16			tag;
+        pid_t			pid;
+} exein_prot_req_t;
+
+typedef struct {
+	u16			tag;
+	u64			timestamp;
+	pid_t			pid;
+	uint16_t		pending_request;
+	u16			seqn;
+	struct hlist_node	next;
+	struct rcu_head         rcu;
+} exein_reg_data;
+
+void exein_delete_expired_regs(void);
+
+typedef struct {
+	u16			features[EXEIN_FEATURE_NUM_MAX];
+} exein_pid_data_cell;
+
+typedef struct {
+	pid_t			pid;
+#ifdef __LP64__
+	u64			task_struct_addr;
+#else
+	u32			task_struct_addr;
+#endif
+	u16			tag;
+	exein_pid_data_cell	*hookdata[EXEIN_RINGBUFFER_SIZE];
+	spinlock_t 		ring_buffer_lock;
+	int			index;
+	int			in_use;
+	struct hlist_node	next;
+	struct rcu_head		rcu;
+} exein_pid_data;
+
+typedef struct {
+	u16			msg_type;
+	u32			seed;
+	u16			seq;
+	pid_t			pid;
+	u16			payload[EXEIN_RINGBUFFER_SIZE];
+} exein_prot_reply;
+
+
--- a/security/exein/Kconfig
+++ b/security/exein/Kconfig
@@ -0,0 +1,32 @@
+config SECURITY_EXEIN
+	bool "Exein Linux Security Module"
+	depends on SECURITY
+	default n
+	help
+	  This selects exein, bla bla bla
+
+config SECURITY_EXEIN_RANDOMFOREST
+        bool "Implement Machine learning engine using random forest"
+        depends on SECURITY_EXEIN
+        default n
+        select SIGNATURE
+        help
+          Bla Bla.
+
+
+config SECURITY_EXEIN_NEURALNETWORK
+        bool "Implement Machine learning engine using Recurrent neural network"
+        depends on SECURITY_EXEIN
+        default n
+        select SIGNATURE
+        help
+          Bla Bla.
+
+config SECURITY_EXEIN_SQUEEZE
+        bool "Optimization needed to squueze the LSM into small boxes"
+        depends on SECURITY_EXEIN
+        default n
+        select SIGNATURE
+        help
+          Bla Bla.
+
--- a/security/exein/exein_nn_main.h
+++ b/security/exein/exein_nn_main.h
@@ -0,0 +1,5 @@
+#include "exein_types.h"
+#include "exein_nn_defs_parts.h"
+#include "exein_nn_defs.h" // Autogenerated file
+
+int playnn(exein_feature_t *NNInput);
--- a/security/exein/exein_print_level.h
+++ b/security/exein/exein_print_level.h
@@ -0,0 +1,6 @@
+/*
+    KERN_DEBUG   won't show on console
+    KERN_INFO    will print everything on console by default
+*/
+
+#define EXEIN_PRINT_LEVEL KERN_INFO
--- a/security/exein/exein_types.h
+++ b/security/exein/exein_types.h
@@ -0,0 +1,19 @@
+#include <linux/types.h>
+#include <linux/list.h>
+
+#ifndef EXEIN_TYPES_INCLUDED
+#define EXEIN_TYPES_INCLUDED
+
+#define NNINPUT_SIZE 2
+typedef u16 exein_feature_t;
+
+
+// define struct
+typedef struct {
+    uint16_t tag;
+    pid_t pid;
+    int val;
+    struct list_head list;
+} exein_trust_t;
+
+#endif
--- a/security/exein/exein_struct_mappings.h
+++ b/security/exein/exein_struct_mappings.h
@@ -0,0 +1,44 @@
+#include <linux/types.h>
+#include <linux/cred.h>             // cred
+#include <linux/fs.h>               // fown_struct, iattr,
+#include <linux/binfmts.h>          // linux_binprm
+#include <linux/user_namespace.h>
+#include <linux/mount.h>            // vfsmount
+#include <linux/sched.h>
+//5.1.11
+//#include <linux/fs_context.h>       // fs_context, fs_parameter
+#include <linux/capability.h>       //  kernel_cap_struct
+#include <linux/path.h>             // path
+#include <linux/uidgid.h>           // kuid_t
+
+//4.14.151
+#include <linux/sem.h>           // sem_array
+#include "../../kernel/audit.h"
+
+#include "exein_types.h"
+#include "exein_nn_defs.h"
+#include "exein_print_level.h"
+
+#define PARSE_STRINGS 0
+#define DUMMY_STRING_MAX_LENGTH 10
+
+uint16_t task_struct_get_pid(struct task_struct *arg1);
+void exein_map_current_to_features(exein_feature_t* features_arr);
+
+void exein_map_string_to_features(const char* string,   size_t string_max_length,   size_t* index_p,   exein_feature_t* features_arr);
+
+void exein_map_cred_to_features(            const struct cred* input,               size_t* index_p,   exein_feature_t* features_arr);
+void exein_map_fown_struct_to_features(     const struct fown_struct* input,        size_t* index_p,   exein_feature_t* features_arr);
+void exein_map_iattr_to_features(           const struct iattr* input,              size_t* index_p,   exein_feature_t* features_arr);
+void exein_map_user_namespace_to_features(  const struct user_namespace* input,     size_t* index_p,   exein_feature_t* features_arr);
+void exein_map_vm_area_struct_to_features(  const struct vm_area_struct* input,     size_t* index_p,   exein_feature_t* features_arr);
+void exein_map_task_struct_to_features(     const struct task_struct* input,        size_t* index_p,   exein_feature_t* features_arr);
+//void exein_map_fs_context_to_features(      const struct fs_context* input,         size_t* index_p,   exein_feature_t* features_arr);
+void exein_map_inode_to_features(           const struct inode* input,              size_t* index_p,   exein_feature_t* features_arr);
+void exein_map_dentry_to_features(          const struct dentry* input,             size_t* index_p,   exein_feature_t* features_arr);
+void exein_map_file_to_features(            const struct file* input,               size_t* index_p,   exein_feature_t* features_arr);
+void exein_map_kernel_cap_t_to_features(    const struct kernel_cap_struct* input,  size_t* index_p,   exein_feature_t* features_arr);
+void exein_map_linux_binprm_to_features(    const struct linux_binprm* input,       size_t* index_p,   exein_feature_t* features_arr);
+//void exein_map_fs_parameter_to_features(    const struct fs_parameter* input,       size_t* index_p,   exein_feature_t* features_arr);
+void exein_map_path_to_features(            const struct path* input,               size_t* index_p,   exein_feature_t* features_arr);
+void exein_map_qstr_to_features(            const struct qstr* input,               size_t* index_p,   exein_feature_t* features_arr);
--- a/security/exein/exein_nn_main.c
+++ b/security/exein/exein_nn_main.c
@@ -0,0 +1,11 @@
+#include "exein_nn_main.h"
+#include <linux/string.h>
+#include "exein_lsm.h"
+#include "exein_nn_defs.h"
+
+int playnn(exein_feature_t *NNInput)
+{
+	exein_delete_expired_regs();
+//	printk(KERN_INFO "#[%d,%d,%d,%d]R%d\n", *(NNInput),*(NNInput+1),*(NNInput+2), *(NNInput+3), hook_default_values[*(NNInput+2)]);
+	return hook_default_values[*NNInput];
+}
--- a/security/exein/exein_trust.c
+++ b/security/exein/exein_trust.c
@@ -0,0 +1,13 @@
+#include <linux/slab.h>
+#include <linux/gfp.h>
+#include "exein_types.h"
+#include "exein_trust.h"
+#include <linux/sched.h>
+
+void exein_mark_not_trusted(uint16_t tag, pid_t pid){
+	int ret = kill_pid(find_vpid(pid), SIGKILL, 1);
+	if (ret < 0) {
+		printk(KERN_INFO "error kill pid\n");
+		}
+	printk(KERN_CRIT "EXEIN MARKED PROCESS AS NOT TRUSTED [tag:%d pid:%d]\n", tag, pid);
+}
--- a/security/exein/mkHookh_data/banner.txt
+++ b/security/exein/mkHookh_data/banner.txt
@@ -0,0 +1,15 @@
+/*******************************************************************************************************
+     _  _   _ _____ ___   ___ ___ _  _ ___ ___    _ _____ ___ ___
+    /_\| | | |_   _/ _ \ / __| __| \| | __| _ \  /_\_   _| __|   \
+   / _ \ |_| | | || (_) | (_ | _|| .` | _||   / / _ \| | | _|| |) |
+  /_/ \_\___/  |_| \___/ \___|___|_|\_|___|_|_\/_/ \_\_| |___|___/                         _ _
+   __| |___   _ _  ___| |_   __| |_  __ _ _ _  __ _ ___  (_) |_   _ __  __ _ _ _ _  _ __ _| | |_  _
+  / _` / _ \ | ' \/ _ \  _| / _| ' \/ _` | ' \/ _` / -_) | |  _| | '  \/ _` | ' \ || / _` | | | || |
+  \__,_\___/ |_||_\___/\__| \__|_||_\__,_|_||_\__, \___| |_|\__| |_|_|_\__,_|_||_\_,_\__,_|_|_|\_, |
+                                               |___/                                            |__/
+  DO NOT CHANGE THIS [!]
+  This file has been generated during the build process
+  To change this refer to the config.ini and hooks.ini files inside the mkHookh_data directory
+********************************************************************************************************/
+
+
--- a/security/exein/mkHookh_data/config.ini
+++ b/security/exein/mkHookh_data/config.ini
@@ -0,0 +1,12 @@
+[files]
+header=./security/exein/mkHookh_data/banner.txt
+footer=./security/exein/mkHookh_data/banner.txt
+
+[hooksInit]
+FS_CONTEXT_PARSE_PARAM= -ENOPARAM
+INODE_GETSECURITY= -EOPNOTSUPP
+TASK_PRCTL= -ENOSYS
+GETPROCATTR= -EINVAL
+SETPROCATTR= -EINVAL
+SECID_TO_SECCTX= -EOPNOTSUPP
+XFRM_STATE_POL_FLOW_MATCH=  1
--- a/security/exein/mkHookh_data/hooks.ini
+++ b/security/exein/mkHookh_data/hooks.ini
@@ -0,0 +1,221 @@
+[ID]
+HOOK_ID=1
+HOOK_CURRENT_PROCESS=1
+HOOK_CURRENT_PROCESS_TAG=1
+
+[PTRACE_HOOKS]
+PTRACE_ACCESS_CHECK=PTRACE_ACCESS_CHECK
+PTRACE_TRACEME=PTRACE_TRACEME
+
+[CAP_HOOKS]
+CAPGET=CAPGET
+CAPSET=CAPSET
+CAPABLE=CAPABLE
+
+[EXEC_HOOKS]
+BPRM_SET_CREDS=BPRM_SET_CREDS
+BPRM_CHECK_SECURITY=BPRM_CHECK_SECURITY
+BPRM_COMMITTING_CREDS=BPRM_COMMITTING_CREDS
+BPRM_COMMITTED_CREDS=BPRM_COMMITTED_CREDS
+
+[DISKIO_HOOKS]
+SB_ALLOC_SECURITY=SB_ALLOC_SECURITY
+SB_FREE_SECURITY=SB_FREE_SECURITY
+SB_REMOUNT=SB_REMOUNT
+SB_KERN_MOUNT=SB_KERN_MOUNT
+SB_SHOW_OPTIONS=SB_SHOW_OPTIONS
+SB_STATFS=SB_STATFS
+SB_MOUNT=SB_MOUNT
+SB_UMOUNT=SB_UMOUNT
+SB_PIVOTROOT=SB_PIVOTROOT
+SB_SET_MNT_OPTS=SB_SET_MNT_OPTS
+SB_CLONE_MNT_OPTS=SB_CLONE_MNT_OPTS
+DENTRY_INIT_SECURITY=DENTRY_INIT_SECURITY
+DENTRY_CREATE_FILES_AS=DENTRY_CREATE_FILES_AS
+PATH_UNLINK=PATH_UNLINK
+PATH_MKDIR=PATH_MKDIR
+PATH_RMDIR=PATH_RMDIR
+PATH_MKNOD=PATH_MKNOD
+PATH_TRUNCATE=PATH_TRUNCATE
+PATH_SYMLINK=PATH_SYMLINK
+PATH_LINK=PATH_LINK
+PATH_RENAME=PATH_RENAME
+PATH_CHMOD=PATH_CHMOD
+PATH_CHOWN=PATH_CHOWN
+PATH_CHROOT=PATH_CHROOT
+INODE_ALLOC_SECURITY=INODE_ALLOC_SECURITY
+INODE_FREE_SECURITY=INODE_FREE_SECURITY
+INODE_INIT_SECURITY=INODE_INIT_SECURITY
+INODE_CREATE=INODE_CREATE
+INODE_LINK=INODE_LINK
+INODE_UNLINK=INODE_UNLINK
+INODE_SYMLINK=INODE_SYMLINK
+INODE_MKDIR=INODE_MKDIR
+INODE_RMDIR=INODE_RMDIR
+INODE_MKNOD=INODE_MKNOD
+INODE_RENAME=INODE_RENAME
+INODE_READLINK=INODE_READLINK
+INODE_FOLLOW_LINK=INODE_FOLLOW_LINK
+INODE_PERMISSION=INODE_PERMISSION
+INODE_SETATTR=INODE_SETATTR
+INODE_GETATTR=INODE_GETATTR
+INODE_SETXATTR=INODE_SETXATTR
+INODE_POST_SETXATTR=INODE_POST_SETXATTR
+INODE_GETXATTR=INODE_GETXATTR
+INODE_LISTXATTR=INODE_LISTXATTR
+INODE_REMOVEXATTR=INODE_REMOVEXATTR
+INODE_NEED_KILLPRIV=INODE_NEED_KILLPRIV
+INODE_KILLPRIV=INODE_KILLPRIV
+INODE_GETSECURITY=INODE_GETSECURITY
+INODE_SETSECURITY=INODE_SETSECURITY
+INODE_LISTSECURITY=INODE_LISTSECURITY
+INODE_GETSECID=INODE_GETSECID
+INODE_COPY_UP=INODE_COPY_UP
+INODE_COPY_UP_XATTR=INODE_COPY_UP_XATTR
+INODE_INVALIDATE_SECCTX=INODE_INVALIDATE_SECCTX
+INODE_NOTIFYSECCTX=INODE_NOTIFYSECCTX
+INODE_GETSECCTX=INODE_GETSECCTX
+INODE_SETSECCTX=INODE_SETSECCTX
+FILE_PERMISSION=FILE_PERMISSION
+FILE_ALLOC_SECURITY=FILE_ALLOC_SECURITY
+FILE_FREE_SECURITY=FILE_FREE_SECURITY
+FILE_IOCTL=FILE_IOCTL
+FILE_MPROTECT=FILE_MPROTECT
+FILE_LOCK=FILE_LOCK
+FILE_FCNTL=FILE_FCNTL
+FILE_SET_FOWNER=FILE_SET_FOWNER
+FILE_SEND_SIGIOTASK=FILE_SEND_SIGIOTASK
+FILE_RECEIVE=FILE_RECEIVE
+FILE_OPEN=FILE_OPEN
+
+[MEMORY_HOOKS]
+MMAP_ADDR=MMAP_ADDR
+MMAP_FILE=MMAP_FILE
+
+[TASK_HOOKS]
+TASK_FIX_SETUID=TASK_FIX_SETUID
+TASK_SETPGID=TASK_SETPGID
+TASK_GETPGID=TASK_GETPGID
+TASK_GETSID=TASK_GETSID
+TASK_GETSECID=TASK_GETSECID
+TASK_SETNICE=TASK_SETNICE
+TASK_SETIOPRIO=TASK_SETIOPRIO
+TASK_GETIOPRIO=TASK_GETIOPRIO
+TASK_SETRLIMIT=TASK_SETRLIMIT
+TASK_SETSCHEDULER=TASK_SETSCHEDULER
+TASK_GETSCHEDULER=TASK_GETSCHEDULER
+TASK_MOVEMEMORY=TASK_MOVEMEMORY
+TASK_KILL=TASK_KILL
+TASK_PRCTL=TASK_PRCTL
+TASK_TO_INODE=TASK_TO_INODE
+GETPROCATTR=GETPROCATTR
+SETPROCATTR=SETPROCATTR
+
+[TUNNEL_HOOKS]
+TUN_DEV_ALLOC_SECURITY=TUN_DEV_ALLOC_SECURITY
+TUN_DEV_FREE_SECURITY=TUN_DEV_FREE_SECURITY
+TUN_DEV_CREATE=TUN_DEV_CREATE
+TUN_DEV_ATTACH_QUEUE=TUN_DEV_ATTACH_QUEUE
+TUN_DEV_ATTACH=TUN_DEV_ATTACH
+TUN_DEV_OPEN=TUN_DEV_OPEN
+XFRM_POLICY_ALLOC_SECURITY=XFRM_POLICY_ALLOC_SECURITY
+XFRM_POLICY_CLONE_SECURITY=XFRM_POLICY_CLONE_SECURITY
+XFRM_POLICY_FREE_SECURITY=XFRM_POLICY_FREE_SECURITY
+XFRM_POLICY_DELETE_SECURITY=XFRM_POLICY_DELETE_SECURITY
+XFRM_STATE_ALLOC=XFRM_STATE_ALLOC
+XFRM_STATE_ALLOC_ACQUIRE=XFRM_STATE_ALLOC_ACQUIRE
+XFRM_STATE_FREE_SECURITY=XFRM_STATE_FREE_SECURITY
+XFRM_STATE_DELETE_SECURITY=XFRM_STATE_DELETE_SECURITY
+XFRM_POLICY_LOOKUP=XFRM_POLICY_LOOKUP
+XFRM_STATE_POL_FLOW_MATCH=XFRM_STATE_POL_FLOW_MATCH
+XFRM_DECODE_SESSION=XFRM_DECODE_SESSION
+KEY_ALLOC=KEY_ALLOC
+KEY_FREE=KEY_FREE
+KEY_PERMISSION=KEY_PERMISSION
+KEY_GETSECURITY=KEY_GETSECURITY
+
+[NETWORK_HOOKS]
+SOCKET_POST_CREATE=SOCKET_POST_CREATE
+SOCKET_BIND=SOCKET_BIND
+SOCKET_CONNECT=SOCKET_CONNECT
+SOCKET_LISTEN=SOCKET_LISTEN
+SOCKET_ACCEPT=SOCKET_ACCEPT
+SOCKET_SENDMSG=SOCKET_SENDMSG
+SOCKET_RECVMSG=SOCKET_RECVMSG
+SOCKET_GETSOCKNAME=SOCKET_GETSOCKNAME
+SOCKET_GETPEERNAME=SOCKET_GETPEERNAME
+SOCKET_GETSOCKOPT=SOCKET_GETSOCKOPT
+SOCKET_SETSOCKOPT=SOCKET_SETSOCKOPT
+SOCKET_SHUTDOWN=SOCKET_SHUTDOWN
+SOCKET_GETPEERSEC_STREAM=SOCKET_GETPEERSEC_STREAM
+SOCKET_GETPEERSEC_DGRAM=SOCKET_GETPEERSEC_DGRAM
+SK_ALLOC_SECURITY=SK_ALLOC_SECURITY
+SK_FREE_SECURITY=SK_FREE_SECURITY
+SK_CLONE_SECURITY=SK_CLONE_SECURITY
+SK_GETSECID=SK_GETSECID
+
+[INTERPROCESSPROC_HOOKS]
+IPC_PERMISSION=IPC_PERMISSION
+IPC_GETSECID=IPC_GETSECID
+MSG_MSG_ALLOC_SECURITY=MSG_MSG_ALLOC_SECURITY
+MSG_MSG_FREE_SECURITY=MSG_MSG_FREE_SECURITY
+MSG_QUEUE_ALLOC_SECURITY=MSG_QUEUE_ALLOC_SECURITY
+MSG_QUEUE_FREE_SECURITY=MSG_QUEUE_FREE_SECURITY
+MSG_QUEUE_ASSOCIATE=MSG_QUEUE_ASSOCIATE
+MSG_QUEUE_MSGCTL=MSG_QUEUE_MSGCTL
+MSG_QUEUE_MSGSND=MSG_QUEUE_MSGSND
+MSG_QUEUE_MSGRCV=MSG_QUEUE_MSGRCV
+SHM_ALLOC_SECURITY=SHM_ALLOC_SECURITY
+SHM_FREE_SECURITY=SHM_FREE_SECURITY
+SHM_ASSOCIATE=SHM_ASSOCIATE
+SHM_SHMCTL=SHM_SHMCTL
+SHM_SHMAT=SHM_SHMAT
+BINDER_SET_CONTEXT_MGR=BINDER_SET_CONTEXT_MGR
+BINDER_TRANSACTION=BINDER_TRANSACTION
+BINDER_TRANSFER_BINDER=BINDER_TRANSFER_BINDER
+BINDER_TRANSFER_FILE=BINDER_TRANSFER_FILE
+NETLINK_SEND=NETLINK_SEND
+UNIX_STREAM_CONNECT=UNIX_STREAM_CONNECT
+UNIX_MAY_SEND=UNIX_MAY_SEND
+
+[SEMAPHORES_HOOKS]
+SEM_ALLOC_SECURITY=SEM_ALLOC_SECURITY
+SEM_FREE_SECURITY=SEM_FREE_SECURITY
+SEM_ASSOCIATE=SEM_ASSOCIATE
+SEM_SEMCTL=SEM_SEMCTL
+SEM_SEMOP=SEM_SEMOP
+
+[SECCONNS_HOOKS]
+SECMARK_RELABEL_PACKET=SECMARK_RELABEL_PACKET
+SECMARK_REFCOUNT_INC=SECMARK_REFCOUNT_INC
+SECMARK_REFCOUNT_DEC=SECMARK_REFCOUNT_DEC
+INET_CONN_REQUEST=INET_CONN_REQUEST
+INET_CSK_CLONE=INET_CSK_CLONE
+INET_CONN_ESTABLISHED=INET_CONN_ESTABLISHED
+
+[KERNEL_HOOKS]
+KERNEL_ACT_AS=KERNEL_ACT_AS
+KERNEL_CREATE_FILES_AS=KERNEL_CREATE_FILES_AS
+KERNEL_MODULE_REQUEST=KERNEL_MODULE_REQUEST
+KERNEL_READ_FILE=KERNEL_READ_FILE
+KERNEL_POST_READ_FILE=KERNEL_POST_READ_FILE
+CRED_ALLOC_BLANK=CRED_ALLOC_BLANK
+CRED_FREE=CRED_FREE
+CRED_PREPARE=CRED_PREPARE
+CRED_TRANSFER=CRED_TRANSFER
+ISMACLABEL=ISMACLABEL
+SECID_TO_SECCTX=SECID_TO_SECCTX
+SECCTX_TO_SECID=SECCTX_TO_SECID
+RELEASE_SECCTX=RELEASE_SECCTX
+SOCK_GRAFT=SOCK_GRAFT
+REQ_CLASSIFY_FLOW=REQ_CLASSIFY_FLOW
+AUDIT_RULE_INIT=AUDIT_RULE_INIT
+AUDIT_RULE_KNOWN=AUDIT_RULE_KNOWN
+AUDIT_RULE_MATCH=AUDIT_RULE_MATCH
+AUDIT_RULE_FREE=AUDIT_RULE_FREE
+QUOTACTL=QUOTACTL
+QUOTA_ON=QUOTA_ON
+SYSLOG=SYSLOG
+SETTIME=SETTIME
+VM_ENOUGH_MEMORY=VM_ENOUGH_MEMORY
+D_INSTANTIATE=D_INSTANTIATE
--- a/scripts/Makefile
+++ b/scripts/Makefile
@@ -45,6 +45,7 @@
 subdir-$(CONFIG_SECURITY_SELINUX) += selinux
 subdir-$(CONFIG_DTC)         += dtc
 subdir-$(CONFIG_GDB_SCRIPTS) += gdb
+subdir-$(CONFIG_SECURITY_EXEIN) += exein
 
 # Let clean descend into subdirs
 subdir-	+= basic kconfig package gcc-plugins
--- a/scripts/exein/make_define_aliases.sh
+++ b/scripts/exein/make_define_aliases.sh
@@ -0,0 +1,5 @@
+#!/bin/sh
+sed -n '/union security_list_options {/,/};/p' include/linux/lsm_hooks.h |\
+egrep "\(.*\)\(|^#" |\
+sed -r 's/.*\(\*(.*)\)\(.*/\1/' |\
+gawk -f scripts/exein/hooks_define.awk
--- a/scripts/exein/Makefile
+++ b/scripts/exein/Makefile
@@ -0,0 +1,2 @@
+subdir-y := mkHookh HeaderParser mkHookhcomp inibuilder
+MAKEFLAGS := -j 1
--- a/scripts/exein/list.h
+++ b/scripts/exein/list.h
@@ -0,0 +1,310 @@
+#ifndef _LINUX_LIST_H
+#define _LINUX_LIST_H
+
+#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
+
+#define container_of(ptr, type, member) ( { \
+        const typeof( ((type *)0)->member ) *__mptr = (ptr); \
+        (type *)( (char *)__mptr - offsetof(type,member) ); } )
+
+static inline void prefetch(const void *x) {;}
+static inline void prefetchw(const void *x) {;}
+
+#define LIST_POISON1  ((void *) 0x00100100)
+#define LIST_POISON2  ((void *) 0x00200200)
+
+struct list_head {
+        struct list_head *next, *prev;
+};
+
+#define LIST_HEAD_INIT(name) { &(name), &(name) }
+
+#define LIST_HEAD(name) \
+        struct list_head name = LIST_HEAD_INIT(name)
+
+#define INIT_LIST_HEAD(ptr) do { \
+        (ptr)->next = (ptr); (ptr)->prev = (ptr); \
+} while (0)
+
+/*
+* Insert a new entry between two known consecutive entries.
+*
+* This is only for internal list manipulation where we know
+* the prev/next entries already!
+*/
+static inline void __list_add(struct list_head *new,
+                              struct list_head *prev,
+                              struct list_head *next)
+{
+        next->prev = new;
+        new->next = next;
+        new->prev = prev;
+        prev->next = new;
+}
+
+/**
+* list_add - add a new entry
+* @new: new entry to be added
+* @head: list head to add it after
+*
+* Insert a new entry after the specified head.
+* This is good for implementing stacks.
+*/
+static inline void list_add(struct list_head *new, struct list_head *head)
+{
+        __list_add(new, head, head->next);
+}
+
+/**
+* list_add_tail - add a new entry
+* @new: new entry to be added
+* @head: list head to add it before
+*
+* Insert a new entry before the specified head.
+* This is useful for implementing queues.
+*/
+static inline void list_add_tail(struct list_head *new, struct list_head *head)
+{
+        __list_add(new, head->prev, head);
+}
+
+static inline void __list_del(struct list_head * prev, struct list_head * next)
+{
+        next->prev = prev;
+        prev->next = next;
+}
+
+static inline void list_del(struct list_head *entry)
+{
+        __list_del(entry->prev, entry->next);
+        entry->next = LIST_POISON1;
+        entry->prev = LIST_POISON2;
+}
+
+static inline void list_del_init(struct list_head *entry)
+{
+        __list_del(entry->prev, entry->next);
+        INIT_LIST_HEAD(entry);
+}
+
+static inline void list_move(struct list_head *list, struct list_head *head)
+{
+        __list_del(list->prev, list->next);
+        list_add(list, head);
+}
+
+static inline void list_move_tail(struct list_head *list,
+                                  struct list_head *head)
+{
+        __list_del(list->prev, list->next);
+        list_add_tail(list, head);
+}
+
+static inline int list_empty(const struct list_head *head)
+{
+        return head->next == head;
+}
+
+static inline int list_empty_careful(const struct list_head *head)
+{
+        struct list_head *next = head->next;
+        return (next == head) && (next == head->prev);
+}
+
+static inline void __list_splice(struct list_head *list,
+                                 struct list_head *head)
+{
+        struct list_head *first = list->next;
+        struct list_head *last = list->prev;
+        struct list_head *at = head->next;
+
+        first->prev = head;
+        head->next = first;
+
+        last->next = at;
+        at->prev = last;
+}
+
+/**
+* list_splice - join two lists
+* @list: the new list to add.
+* @head: the place to add it in the first list.
+*/
+static inline void list_splice(struct list_head *list, struct list_head *head)
+{
+        if (!list_empty(list))
+                __list_splice(list, head);
+}
+
+/**
+* list_splice_init - join two lists and reinitialise the emptied list.
+* @list: the new list to add.
+* @head: the place to add it in the first list.
+*
+* The list at @list is reinitialised
+*/
+static inline void list_splice_init(struct list_head *list,
+                                    struct list_head *head)
+{
+        if (!list_empty(list)) {
+                __list_splice(list, head);
+                INIT_LIST_HEAD(list);
+        }
+}
+
+#define list_entry(ptr, type, member) container_of(ptr, type, member)
+
+
+#define list_for_each(pos, head) \
+        for (pos = (head)->next; prefetch(pos->next), pos != (head); \
+                pos = pos->next)
+
+#define __list_for_each(pos, head) \
+        for (pos = (head)->next; pos != (head); pos = pos->next)
+
+#define list_for_each_prev(pos, head) \
+        for (pos = (head)->prev; prefetch(pos->prev), pos != (head); \
+                pos = pos->prev)
+
+#define list_for_each_safe(pos, n, head) \
+        for (pos = (head)->next, n = pos->next; pos != (head); \
+                pos = n, n = pos->next)
+
+#define list_for_each_entry(pos, head, member)                                \
+        for (pos = list_entry((head)->next, typeof(*pos), member);        \
+             prefetch(pos->member.next), &pos->member != (head);         \
+             pos = list_entry(pos->member.next, typeof(*pos), member))
+
+#define list_for_each_entry_reverse(pos, head, member)                        \
+        for (pos = list_entry((head)->prev, typeof(*pos), member);        \
+             prefetch(pos->member.prev), &pos->member != (head);         \
+             pos = list_entry(pos->member.prev, typeof(*pos), member))
+
+#define list_prepare_entry(pos, head, member) \
+        ((pos) ? : list_entry(head, typeof(*pos), member))
+
+#define list_for_each_entry_continue(pos, head, member)                 \
+        for (pos = list_entry(pos->member.next, typeof(*pos), member);        \
+             prefetch(pos->member.next), &pos->member != (head);        \
+             pos = list_entry(pos->member.next, typeof(*pos), member))
+
+#define list_for_each_entry_safe(pos, n, head, member)                        \
+        for (pos = list_entry((head)->next, typeof(*pos), member),        \
+                n = list_entry(pos->member.next, typeof(*pos), member);        \
+             &pos->member != (head);                                         \
+             pos = n, n = list_entry(n->member.next, typeof(*n), member))
+
+//HASH LIST
+struct hlist_head {
+        struct hlist_node *first;
+};
+
+struct hlist_node {
+        struct hlist_node *next, **pprev;
+};
+
+#define HLIST_HEAD_INIT { .first = NULL }
+#define HLIST_HEAD(name) struct hlist_head name = {  .first = NULL }
+#define INIT_HLIST_HEAD(ptr) ((ptr)->first = NULL)
+#define INIT_HLIST_NODE(ptr) ((ptr)->next = NULL, (ptr)->pprev = NULL)
+
+static inline int hlist_unhashed(const struct hlist_node *h)
+{
+        return !h->pprev;
+}
+
+static inline int hlist_empty(const struct hlist_head *h)
+{
+        return !h->first;
+}
+
+static inline void __hlist_del(struct hlist_node *n)
+{
+        struct hlist_node *next = n->next;
+        struct hlist_node **pprev = n->pprev;
+        *pprev = next;
+        if (next)
+                next->pprev = pprev;
+}
+
+static inline void hlist_del(struct hlist_node *n)
+{
+        __hlist_del(n);
+        n->next = LIST_POISON1;
+        n->pprev = LIST_POISON2;
+}
+
+static inline void hlist_del_init(struct hlist_node *n)
+{
+        if (n->pprev)  {
+                __hlist_del(n);
+                INIT_HLIST_NODE(n);
+        }
+}
+
+static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h)
+{
+        struct hlist_node *first = h->first;
+        n->next = first;
+        if (first)
+                first->pprev = &n->next;
+        h->first = n;
+        n->pprev = &h->first;
+}
+
+
+/* next must be != NULL */
+static inline void hlist_add_before(struct hlist_node *n,
+                                        struct hlist_node *next)
+{
+        n->pprev = next->pprev;
+        n->next = next;
+        next->pprev = &n->next;
+        *(n->pprev) = n;
+}
+
+static inline void hlist_add_after(struct hlist_node *n,
+                                        struct hlist_node *next)
+{
+        next->next = n->next;
+        n->next = next;
+        next->pprev = &n->next;
+
+        if(next->next)
+                next->next->pprev  = &next->next;
+}
+
+#define hlist_entry(ptr, type, member) container_of(ptr,type,member)
+
+#define hlist_for_each(pos, head) \
+        for (pos = (head)->first; pos && ({ prefetch(pos->next); 1; }); \
+             pos = pos->next)
+
+#define hlist_for_each_safe(pos, n, head) \
+        for (pos = (head)->first; pos && ({ n = pos->next; 1; }); \
+             pos = n)
+
+#define hlist_for_each_entry(tpos, pos, head, member)                         \
+        for (pos = (head)->first;                                         \
+             pos && ({ prefetch(pos->next); 1;}) &&                         \
+                ({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \
+             pos = pos->next)
+
+#define hlist_for_each_entry_continue(tpos, pos, member)                 \
+        for (pos = (pos)->next;                                                 \
+             pos && ({ prefetch(pos->next); 1;}) &&                         \
+                ({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \
+             pos = pos->next)
+
+#define hlist_for_each_entry_from(tpos, pos, member)                         \
+        for (; pos && ({ prefetch(pos->next); 1;}) &&                         \
+                ({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \
+             pos = pos->next)
+
+#define hlist_for_each_entry_safe(tpos, pos, n, head, member)                  \
+        for (pos = (head)->first;                                         \
+             pos && ({ n = pos->next; 1; }) &&                                  \
+                ({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \
+             pos = n)
+
+#endif
--- a/scripts/exein/config.h
+++ b/scripts/exein/config.h
@@ -0,0 +1,83 @@
+#ifndef INI_FILE_H_
+#define INI_FILE_H_
+
+#include <net/if.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <string.h>
+#include <sys/types.h>
+#include "list.h"
+
+#define NAME_NAME     0
+#define NAME_NUMBER   1
+#define NUMBER_NAME   2
+#define NUMBER_NUMBER 3
+
+#define NAME          0
+#define NUMBER        1
+
+#define LEFT_BRACE '['
+#define RIGHT_BRACE ']'
+#define COMMENT ';'
+#define SIGN_OF_EQUAL "=="
+
+#define BASE_URL_FIRST_GROUP 3
+
+#define LINE_LEN 256
+
+#define SectionName(ptr) (ptr)!=NULL?(ptr)->section:"NA"
+#define KeyValue(ptr) (ptr)!=NULL?(ptr)->value:"NA"
+#define KeyName(ptr) (ptr)!=NULL?(ptr)->key:"NA"
+
+/** @brief max length of each value */
+#define VALUE_LEN 256
+
+typedef struct keys {
+	struct list_head node;
+	char value[VALUE_LEN];
+	char key[VALUE_LEN];
+	int id;
+}keys_t;
+
+typedef struct sections{
+	struct list_head node;
+	char section[VALUE_LEN];
+	keys_t *keys;
+}sections_t;
+
+typedef struct group_range {
+	int begin;
+	int end;
+	int group_num;
+}group_range_t;
+
+extern group_range_t *g_group;
+/** @brief the end of each line */
+#define NEW_LINE(c) ('\n' == c || '\r' == c)? 1 : 0
+
+/** @brief delete the end-of-line indicator */
+#define DELE_NEW_LINE_INDICATOR(buffer, len) 	\
+									if (NEW_LINE(buffer[len - 1])) { \
+										if (NEW_LINE(buffer[len - 2])) \
+											buffer[len - 2] = '\0';   \
+										else  						\
+											buffer[len - 1] = '\0';\
+									}	
+
+#define STRING_COMPARE(x, equ, y) (strcmp(x, y) equ 0)
+
+int delete_line_break_indicator(char *buffer);
+void print_error(char *err_msg);
+int read_file_content(const char *file, sections_t *section_head);
+int read_ini_file(char * filename, sections_t *section_head);
+sections_t *get_section(void *section, sections_t *section_head, char method);
+keys_t *get_key(void *section, void *key, sections_t *section_head, char method);
+int add_section(char *section_name, sections_t *section_head);
+int add_key(char *section_name, char *key_name, char *key_value, sections_t *section_head);
+void print_ini(sections_t *section_head);
+
+#define CONFIG_FILE "./config.ini"
+
+#endif //end of INI_FILE_H_
+
--- a/scripts/exein/Kconfig
+++ b/scripts/exein/Kconfig
@@ -0,0 +1,6 @@
+config SECURITY_EXEIN
+	bool "Exein rules the IT"
+	depends on SECURITY
+	default n
+	help
+	  This selects exein, bla bla bla
--- a/scripts/exein/config.c
+++ b/scripts/exein/config.c
@@ -0,0 +1,394 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <string.h>
+#include <ctype.h>
+#include <errno.h>
+#include "config.h"
+#include "list.h"
+
+/*
+ * INTERNAL - NOT EXPORTED
+ */
+void print_error(char *err_msg)
+{
+	printf("%s\n", err_msg);
+	exit(0);
+}
+
+/*
+ * @brief delete_line_break_indicator
+ * @buffer[in,out]
+ * @NOTE:
+ * detete the last one or two character which is '\n' or 'r'
+ * INTERNAL - NOT EXPORTED
+ */
+int delete_line_break_indicator(char *buffer)
+{
+	int len = strlen(buffer), i, j = len - 1;
+	for (i = j; i >= 0; i--) {
+		if (!isspace(buffer[i])) {
+			if (i == j) {
+				break;
+			}
+			else {
+				buffer[i + 1] = '\0';
+				break;
+			}
+		}
+	}
+
+	DELE_NEW_LINE_INDICATOR(buffer, len);
+#if 0
+	if (NEW_LINE(buffer[len - 1])) {
+		if (NEW_LINE(buffer[len - 2]))
+			buffer[len - 2] = '\0';
+		else
+			buffer[len - 1] = '\0';
+	}
+#endif
+	return 0;
+}
+
+/*
+ * @read_file_content
+ * @file         [in] the direcotry of category.ini
+ * @section_head [in,out]
+ * Return 1 on success and populates the section_heads, 0 elsewhere.
+ */
+int read_file_content(const char *file, sections_t *section_head)
+{
+	FILE *fp = NULL;
+	char * ret_buf, contents[LINE_LEN] = {0}, *saveptr = NULL, *pcon = contents;
+	sections_t *section_node = NULL;
+	keys_t *keys;
+
+	assert(file !=NULL);
+
+	if ((fp = fopen(file,"r")) == NULL) {
+		fprintf(stderr, "Open [%s] %s\n", file ,strerror(errno));
+		return 0;
+	}
+
+	while (fgets(pcon, LINE_LEN, fp)){
+		/** @brief skip all the space character that contains
+			('\r', '\n', '\f', '\t', '\v')
+		*/
+		while (isspace(*pcon)) {
+			pcon++;
+			}
+
+		/** @brief find the section '[]' */
+		if (*pcon == LEFT_BRACE) {
+			if ((ret_buf = strchr(pcon, RIGHT_BRACE))) {
+				if ((section_node = (sections_t *)malloc(sizeof(sections_t))) == NULL) {
+					perror("MALLOC:");
+					return 0;
+					}
+				memset(section_node, 0, sizeof(sections_t));
+				memcpy(section_node->section, pcon + 1, ret_buf - pcon - 1);
+				list_add_tail(&section_node->node, &section_head->node);
+				}else {
+					print_error("syntex error , there are need ']'");
+					}
+			}else if (*pcon == COMMENT) {
+				/** @brief this is a comment line and ignore it */
+				continue;
+				}else {
+
+				/** @brief find all the keys and value which under the section found */
+				if (section_node == NULL) {
+					print_error("syntex error, there are no '[]'");
+					}
+
+				int i = 0;
+				if (section_node->keys == NULL) {
+					if ((section_node->keys = (keys_t *)malloc(sizeof(keys_t))) == NULL){
+						perror("MALLOC:");
+						return 0;
+						}
+				memset(section_node->keys, 0, sizeof(keys_t));
+				INIT_LIST_HEAD(&section_node->keys->node);
+				}
+			if ((keys = (keys_t *)malloc(sizeof(keys_t))) == NULL) {
+				perror("MALLOC:");
+				exit(0);
+				}
+			memset(keys, 0, sizeof(keys_t));
+
+			while ((ret_buf = strtok_r(pcon, SIGN_OF_EQUAL, &saveptr))) {
+				if (i == 0) {
+					delete_line_break_indicator(ret_buf);
+					memcpy(keys->key, ret_buf, strlen(ret_buf)); }else if (i == 1) {
+					delete_line_break_indicator(ret_buf);
+					memcpy(keys->value, ret_buf, strlen(ret_buf));
+					}
+				pcon = NULL;
+				i++;
+				}
+
+			if (i == 0) {
+				free(keys);
+				}else list_add_tail(&keys->node, &section_node->keys->node);
+			}
+
+		memset(contents, 0, LINE_LEN);
+		pcon = contents;
+	}
+
+	fclose(fp);
+	return 1;
+}
+
+/*
+ * @get_section
+ * @section      [in]
+ * @section_head [in] the struct which stores the head of section list
+ * @method       [in] defines the type of data specified to access the structure. 
+ *                    Valid methods includes: NAME, NUMBER.
+ * Return a pointer to the section having the specified characteristics if found; NULL elsewhere.
+ */
+
+sections_t *get_section(void *section, sections_t *section_head, char method)
+{
+	assert(section != NULL);
+	assert(section_head != NULL);
+	assert(method <= NUMBER);
+
+	struct list_head *pos = NULL;
+	sections_t * tmp_node = NULL;
+
+	switch (method) {
+		case NAME:
+		list_for_each(pos, &section_head->node) {
+			tmp_node = (sections_t *)container_of(pos, sections_t, node);
+			if (STRING_COMPARE((char *)section, ==, tmp_node->section)) {
+				return tmp_node;
+				}
+			}
+		break;
+		case NUMBER:
+		{
+		int ct=0;
+		list_for_each(pos, &section_head->node) {
+			tmp_node = (sections_t *)container_of(pos, sections_t, node);
+			if (ct==*((int *)section)) {
+				return tmp_node;
+				}
+			ct++;
+			}
+		}
+		break;
+		}
+	return NULL;
+}
+
+/*
+ * @add_section
+ * @section_name [in]
+ * @section_head [in/out] the struct which stores the head of section list
+ * Return 0 on success others on failure
+ *        1 section exist
+ *        2 memory alloc fail
+ */
+
+int add_section(char *section_name, sections_t *section_head){
+	sections_t *section_node = NULL;
+
+	if (get_section(section_name, section_head, NAME)){
+		return 1;
+		}
+	if ((section_node = (sections_t *)malloc(sizeof(sections_t))) == NULL) {
+		return 2;
+		}
+	memset(section_node, 0, sizeof(sections_t));
+	memcpy(section_node->section, section_name, strlen(section_name));
+	list_add_tail(&section_node->node, &section_head->node);
+	return 0;
+}
+
+/*
+typedef struct keys {
+        struct list_head node;
+        char value[VALUE_LEN];
+        char key[VALUE_LEN];
+        int id;
+}keys_t;
+
+typedef struct sections{
+        struct list_head node;
+        char section[VALUE_LEN];
+        keys_t *keys;
+}sections_t;
+*/
+
+
+/*
+ * @add_key
+ * @key_name [in]
+ * @key_value [in]
+ * @section_head [in/out] the struct which stores the head of section list
+ * Return 0 on success others on failure
+ *        1 section not found
+ *        2 memory alloc fail
+ */
+
+int add_key(char *section_name, char *key_name, char *key_value, sections_t *section_head){
+        sections_t *section_node;
+	keys_t *tmp_key;
+
+        if (!(section_node=get_section(section_name, section_head, NAME))){
+		fflush(stdout);
+                return 1;
+                }
+
+	fflush(stdout);
+	if ((tmp_key = (keys_t *)malloc(sizeof(keys_t))) == NULL){
+		return 2;
+		}
+	memset(tmp_key, 0, sizeof(keys_t));
+	memcpy(tmp_key->key, key_name, strlen(key_name));
+	memcpy(tmp_key->value, key_value, strlen(key_value));
+
+        if (section_node->keys == NULL) {
+		if ((section_node->keys = (keys_t *)malloc(sizeof(keys_t))) == NULL){
+                	return 2;
+                	}
+		memset(section_node->keys, 0, sizeof(keys_t));
+		INIT_LIST_HEAD(&section_node->keys->node);
+		}
+	list_add_tail(&tmp_key->node, &section_node->keys->node);
+        return 0;
+}
+
+
+
+
+/*
+ * @get_key
+ * @section      [in]
+ * @key          [in]
+ * @section_head [in] the struct which stores the head of section list
+ * @method       [in] defines the type of data specified to access the structure. 
+ *                    Valid methods includes: NAME_NAME, NAME_NUMBER, NUMBER_NAME, NUMBER_NUMBER.
+ * Returns a pointer to the specified key laying in the specified section if found, NULL elsewhere.
+ */
+
+keys_t *get_key(void *section, void *key, sections_t *section_head, char method)
+{
+	assert(section != NULL);
+	assert(section_head != NULL);
+	assert(key != NULL);
+	assert(method <= NUMBER_NUMBER);
+
+	struct list_head *pos = NULL, *pos_child = NULL;
+	sections_t * tmp_node = NULL;
+	keys_t *tmp_key = NULL;
+
+
+	switch (method) {
+		case NAME_NAME:
+		list_for_each(pos, &section_head->node) {
+			tmp_node = (sections_t *)container_of(pos, sections_t, node);
+			if (STRING_COMPARE((char *)section, ==, tmp_node->section)) {
+				list_for_each(pos_child, &tmp_node->keys->node) {
+					tmp_key = (keys_t *)container_of(pos_child, keys_t, node);
+					if (STRING_COMPARE((char *)key, ==, tmp_key->key)) {
+						return tmp_key;
+						}
+					}
+				}
+			}
+		break;
+		case NAME_NUMBER:
+		{
+		int ct=0;
+		list_for_each(pos, &section_head->node) {
+			tmp_node = (sections_t *)container_of(pos, sections_t, node);
+			if (STRING_COMPARE((char *)section, ==, tmp_node->section)) {
+				list_for_each(pos_child, &tmp_node->keys->node) {
+					tmp_key = (keys_t *)container_of(pos_child, keys_t, node);
+					if (*((int *)key)==ct) {
+						return tmp_key;
+						}
+					ct++;
+					}
+				}
+			}
+		}
+		break;
+		case NUMBER_NAME:
+		{
+		int ct=0;
+		list_for_each(pos, &section_head->node) {
+			tmp_node = (sections_t *)container_of(pos, sections_t, node);
+			if (*((int *) section)==ct) {
+				list_for_each(pos_child, &tmp_node->keys->node) {
+					tmp_key = (keys_t *)container_of(pos_child, keys_t, node);
+					if (STRING_COMPARE((char *)key, ==, tmp_key->key)) {
+						return tmp_key;
+						}
+					}
+				}
+			ct++;
+			}
+		}
+		break;
+		case NUMBER_NUMBER:
+		{
+		int ctk=0,cts=0;
+		list_for_each(pos, &section_head->node) {
+			tmp_node = (sections_t *)container_of(pos, sections_t, node);
+			if (*((int *) section)==cts)  {
+				list_for_each(pos_child, &tmp_node->keys->node) {
+					tmp_key = (keys_t *)container_of(pos_child, keys_t, node);
+					if (*((int *)key)==ctk) {
+						return tmp_key;
+						}
+					ctk++;
+					}
+				}
+			cts++;
+			}
+		}
+		break;
+		}
+	return NULL;
+}
+
+void print_ini(sections_t *section_head){
+	sections_t *tmp_sec;
+	keys_t *tmp_key;
+
+	for (char i=0;(tmp_sec=get_section(&i,section_head, NUMBER)); i++){
+//		printf("[%s] debug: key=%p\n", SectionName(tmp_sec), tmp_sec->keys);
+		printf("[%s]\n", SectionName(tmp_sec));
+		if (tmp_sec->keys){
+	                for (char j=0;(tmp_key=get_key(&i,&j,section_head, NUMBER_NUMBER)); j++){
+        	                printf("%s=%s\n", KeyName(tmp_key), KeyValue(tmp_key));
+                	        }
+			}
+                }
+}
+
+
+
+
+/*
+ * @read_ini_file
+ * @filename[in] the name of *.ini file
+ * @section_head[in,out]
+ */
+int read_ini_file(char * filename, sections_t *section_head)
+{
+//	char buffer[VALUE_LEN] = {0};
+	/** @brief init the head of list */
+	INIT_LIST_HEAD(&section_head->node);
+
+
+	/** @brief parse the whole .ini file and
+		store information in section_head list */
+	read_file_content(filename, section_head);
+
+	return 0;
+}
--- a/scripts/exein/hooks_define.awk
+++ b/scripts/exein/hooks_define.awk
@@ -0,0 +1,11 @@
+BEGIN {
+       config="NONE";
+      }
+{
+ if ($1== "#ifdef") config=$2; 
+               else if ($1== "#endif") config="NONE"; 
+                                  else {
+                                        str=sprintf( (config=="NONE")?"#define EXEIN_%2$s_SWITCH":"#ifdef %s\n#define EXEIN_%s_SWITCH\n#endif",config, toupper($0));
+                                        print str;
+                                       }
+ }
--- a/scripts/exein/csv2ini.sh
+++ b/scripts/exein/csv2ini.sh
@@ -0,0 +1,18 @@
+#!/bin/bash
+[ "$#" -ne 1 ] && echo "$0 hooks.csv" && exit 1;
+IFS=$'\n';
+for i in $(cat $1); do
+    type=$(echo $i | cut -d, -f1);
+    name=$(echo $i | cut -d, -f2);
+    echo "[$name]";
+    echo "type=\"$type\"";
+    count=1;
+    tmp=$(echo $i | cut -d, -f3-);
+    IFS=$',';
+    for j in $tmp; do
+          echo "arg${count}=\"${j}\"";
+          count=$((count+1));
+          done;
+    echo;
+    IFS=$'\n';
+    done
--- a/scripts/exein/inibuilder/Makefile
+++ b/scripts/exein/inibuilder/Makefile
@@ -0,0 +1,6 @@
+hostprogs-y     := inibuilder
+inibuilder-objs    := ../config.o inibuilder.o
+HOST_EXTRACFLAGS += -std=gnu11
+always          := $(hostprogs-y)
+
+
--- a/scripts/exein/inibuilder/inibuilder.c
+++ b/scripts/exein/inibuilder/inibuilder.c
@@ -0,0 +1,31 @@
+#include <stdio.h>
+#include "../config.h"
+#include <stdlib.h>
+
+
+int main(int argc, char **argv)
+{
+	char keynum=0, secnum=3;
+	sections_t section_head = {0};
+	int tmp;
+
+	if (!((argc!=3)||(argc!=5))) {
+		printf("call:\n\tinibuilder file.ini section_name [key_name key_value]\n");
+		exit(1);
+		}
+
+	read_ini_file(argv[1], &section_head);
+        if (argc==3){
+		if (tmp=add_section(argv[2], &section_head)){
+			printf("section ADD FAIL! (%d)\n", tmp);
+			return 1;
+			}
+		} else {
+		if (tmp=add_key(argv[2],argv[3],argv[4], &section_head)){
+			printf("Key ADD FAIL! in [%s] <- %s=%s - %d\n",argv[2],argv[3],argv[4], tmp);
+			return 1;
+			}
+		}
+	print_ini(&section_head);
+	return 0;
+}
--- a/scripts/exein/mkHookh/Makefile
+++ b/scripts/exein/mkHookh/Makefile
@@ -0,0 +1,4 @@
+hostprogs-y     := mkHookh
+mkHookh-objs    := ../config.o mkHookh.o
+HOST_EXTRACFLAGS += -std=gnu11
+always          := $(hostprogs-y)
--- a/scripts/exein/mkHookh/mkHookh.c
+++ b/scripts/exein/mkHookh/mkHookh.c
@@ -0,0 +1,119 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+#include "../config.h"
+#define FILE_BUFFER_SIZE 1048510
+#define MAXCHAR 1024
+
+char *hookval(char *key, sections_t *data){
+	keys_t *tmp_key;
+	for (int i=0;tmp_key=get_key("hooksInit",&i,data, NAME_NUMBER); i++){
+		if (strcmp(key,KeyName(tmp_key))==0) return KeyValue(tmp_key);
+		}
+	return "0";
+}
+
+
+int main(int argc, char **argv)
+{
+	char keynum, secnum;
+	sections_t *tmp_sec;
+	keys_t *tmp_key;
+	sections_t section_head = {0};
+	sections_t config_head = {0};
+	int pos=0, hva_pos=0, cur_array_pos=0;
+	FILE *fp;
+	char str[MAXCHAR];
+	char *prev="0";
+	char *prevVal;
+
+	if (argc!=4) {
+		printf("call:\n\tmkHookh hooks.ini config.ini [Y/N/A]\n");
+		exit(1);
+		}
+
+
+	srand(time(NULL));
+	char *H_file=(char *)malloc(FILE_BUFFER_SIZE);
+	char *hook_default_value_array=(char *)malloc(FILE_BUFFER_SIZE);
+	memset(H_file,0, FILE_BUFFER_SIZE);
+	read_ini_file(argv[1], &section_head);
+	read_ini_file(argv[2], &config_head);
+
+/*
+  _                    _
+ | |                  | |
+ | |__   ___  __ _  __| | ___ _ __ ___
+ | '_ \ / _ \/ _` |/ _` |/ _ \ '__/ __|
+ | | | |  __/ (_| | (_| |  __/ |  \__ \
+ |_| |_|\___|\__,_|\__,_|\___|_|  |___/
+
+*/
+	pos+=sprintf((H_file+pos),"#ifndef _EXEIN_NN_DEFS_H\n" );
+	pos+=sprintf((H_file+pos),"#define _EXEIN_NN_DEFS_H\n" );
+	pos+=sprintf((H_file+pos),"#include \"exein_nn_defs_comp.h\"\n" );
+	if ((strncmp(argv[3],"Y",1)==0)||(strncmp(argv[3],"A",1)==0)) {
+		int counter=0;
+		for (int i=0;tmp_sec=get_section(&i,&section_head, NUMBER); i++){
+			pos+=sprintf((H_file+pos),"/**********/\n");
+			for (int j=0; tmp_key=get_key(&i,&j,&section_head, NUMBER_NUMBER); j++){
+				pos+=sprintf((H_file+pos),"#define EXEIN_%s_ID %d\n", KeyName(tmp_key), counter);
+				hva_pos+=sprintf( (hook_default_value_array+hva_pos),"%s,%s", hookval(KeyName(tmp_key), &config_head), (counter&7)==7?"\n\t":" ");
+				counter++;
+				}
+			}
+		*(hook_default_value_array+hva_pos)=0;
+		}
+	pos+=sprintf((H_file+pos),"\n\n/********************************************************************************************************/\n");
+	pos+=sprintf((H_file+pos),"#define EXEIN_0_ARG1_POS  0\n");
+	pos+=sprintf((H_file+pos),"#define HOOK_ID  1\n");
+	pos+=sprintf((H_file+pos),"#define HOOK_CURRENT_PROCESS  1\n");
+	pos+=sprintf((H_file+pos),"#define HOOK_CURRENT_PROCESS_TAG  1\n");
+	for (int i=0;tmp_sec=get_section(&i,&section_head, NUMBER); i++){
+		pos+=sprintf((H_file+pos),"/**********/\n");
+		for (int j=0; tmp_key=get_key(&i,&j,&section_head, NUMBER_NUMBER); j++){
+			pos+=sprintf((H_file+pos),"#define EXEIN_%s_ARG1_POS	EXEIN_%s_ARG1_POS + %s\n", KeyName(tmp_key), prev, prev);
+			pos+=sprintf((H_file+pos),"#define EXEIN_%s_SIZE 	%s\n", KeyName(tmp_key), KeyValue(tmp_key));
+			prev=KeyName(tmp_key);
+			prevVal=KeyValue(tmp_key);
+			}
+		}
+	pos+=sprintf((H_file+pos),"\n\n/********************************************************************************************************/\n");
+	pos+=sprintf((H_file+pos),"\n\n#define EXEIN_NN_INPUT_SIZE EXEIN_%s_ARG1_POS + %s\n", prev, prevVal );
+	pos+=sprintf((H_file+pos),"\n\n/********************************************************************************************************/\n");
+	pos+=sprintf((H_file+pos),"\n\n#define SEEDRND %d\n", rand() );
+	pos+=sprintf((H_file+pos),"\n\n\textern const int hook_default_values[];\n");
+	pos+=sprintf((H_file+pos),"\n\n#endif\n");
+/*
+              _               _
+             | |             | |
+   ___  _   _| |_ _ __  _   _| |_
+  / _ \| | | | __| '_ \| | | | __|
+ | (_) | |_| | |_| |_) | |_| | |_
+  \___/ \__,_|\__| .__/ \__,_|\__|
+                 | |
+                 |_|
+*/
+	fp = fopen(KeyValue(get_key("files","header",&config_head, NAME_NAME)), "r");
+	if (fp == NULL){
+		printf("Could not open header file\n");
+		return 1;
+		}
+	while (fgets(str, MAXCHAR, fp) != NULL) printf("%s", str);
+	fclose(fp);
+
+	if (strncmp(argv[3],"A",1)!=0)puts(H_file);
+		else {
+			printf("#include <uapi/asm-generic/errno.h>\n\n" );
+			printf("/*hooks default values begin*/\n\tint hook_default_values[]={\n\t%s};\n/*hooks default values end*/\n",hook_default_value_array);
+			}
+
+	fp = fopen(KeyValue(get_key("files","footer",&config_head, NAME_NAME)), "r");
+	if (fp == NULL){
+		printf("Could not open header file\n");
+		return 1;
+		}
+	while (fgets(str, MAXCHAR, fp) != NULL) printf("%s", str);
+	fclose(fp);
+	return 0;
+}
--- a/scripts/exein/mkHookhcomp/mkHookhcomp.c
+++ b/scripts/exein/mkHookhcomp/mkHookhcomp.c
@@ -0,0 +1,116 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <strings.h>
+#include <ctype.h>
+#include "../config.h"
+
+
+//#define EXEIN_COMPSIZE_PRINT
+#define FILE_BUFFER_SIZE 1048510
+#define MAXCHAR 1024
+
+char *getMainType(char *s){
+	char i;
+	for (i=0; i<strlen(s);i++) {
+		*(s+i)= *(s+i)==' '?'_':*(s+i);
+		}
+	while ((*(s+i)=='"') || (*(s+i)=='_') || (*(s+i)=='*')  || (*(s+i)=='\x00')) i--;
+	*(s+i+1)='\x00';
+
+//	if (*(s+i-2)=='*') *(s+i-3)='\x00';
+//                      else *(s+i-1)='\x00';
+	return s+1;
+}
+
+int main(int argc, char **argv)
+{
+	char keynum, secnum;
+	sections_t *tmp_sec;
+	keys_t *tmp_key;
+	sections_t section_head = {0};
+	sections_t config_head = {0};
+	int pos=0, cur_array_pos=0;
+	FILE *fp;
+	char str[MAXCHAR];
+	char *tmp_str;
+
+
+	char *H_file=(char *)malloc(FILE_BUFFER_SIZE);
+	memset(H_file,0, FILE_BUFFER_SIZE);
+
+	if (argc!=3) {
+		printf("call:\n\tmkHookhcomp hookspart.ini config.ini\n");
+		exit(1);
+		}
+
+	read_ini_file(argv[1], &section_head);
+	read_ini_file(argv[2], &config_head);
+
+/*
+  _                    _
+ | |                  | |
+ | |__   ___  __ _  __| | ___ _ __ ___
+ | '_ \ / _ \/ _` |/ _` |/ _ \ '__/ __|
+ | | | |  __/ (_| | (_| |  __/ |  \__ \
+ |_| |_|\___|\__,_|\__,_|\___|_|  |___/
+
+*/
+	for (int i=0;tmp_sec=get_section(&i,&section_head, NUMBER); i++){
+		int flag=0;
+		tmp_str=SectionName(tmp_sec);
+		for (int t=0; t<strlen(tmp_str);t++) *(tmp_str+t)= toupper((unsigned char) *(tmp_str+t));
+		pos+=sprintf((H_file+pos),"#define %s    ", tmp_str);
+		for (int j=0; tmp_key=get_key(&i,&j,&section_head, NUMBER_NUMBER); j++){
+                        tmp_str=KeyName(tmp_key);
+			if (strcmp(tmp_str,"type")) {
+				 int tmp=j+1;
+				 tmp_str=KeyValue(tmp_key);
+				 for (int t=0; t<strlen(tmp_str);t++) *(tmp_str+t)= toupper((unsigned char) *(tmp_str+t));
+				 pos+=sprintf((H_file+pos),get_key(&i,&tmp,&section_head, NUMBER_NUMBER)?"%s + ":"%s", getMainType(tmp_str));
+				 flag=1;
+				}
+			}
+		 pos+=sprintf((H_file+pos),flag==0?" 0\n":"\n");
+		 flag=0;
+		}
+#ifdef EXEIN_COMPSIZE_PRINT
+	pos+=sprintf((H_file+pos),"/********************************************|DEBUG START|********************************************/\n");
+	for (int i=0;tmp_sec=get_section(&i,&section_head, NUMBER); i++){
+		tmp_str=SectionName(tmp_sec);
+		for (int t=0; t<strlen(tmp_str);t++) *(tmp_str+t)= toupper((unsigned char) *(tmp_str+t));
+		pos+=sprintf((H_file+pos),"#ifdef %s\n", tmp_str);
+		pos+=sprintf((H_file+pos),"#define SYMNAME \"%s\"\n", tmp_str);
+		pos+=sprintf((H_file+pos),"#define EVALUATE_ %s\n", tmp_str);
+		pos+=sprintf((H_file+pos),"#include \"eval_p_sym.h\"\n");
+		pos+=sprintf((H_file+pos),"#endif\n");
+		}
+	pos+=sprintf((H_file+pos),"/********************************************|DEBUG END|********************************************/\n");
+#endif
+
+/*
+              _               _
+             | |             | |
+   ___  _   _| |_ _ __  _   _| |_
+  / _ \| | | | __| '_ \| | | | __|
+ | (_) | |_| | |_| |_) | |_| | |_
+  \___/ \__,_|\__| .__/ \__,_|\__|
+                 | |
+                 |_|
+*/
+	fp = fopen(KeyValue(get_key("files","header",&config_head, NAME_NAME)), "r");
+	if (fp == NULL){
+		printf("Could not open header file\n");
+		return 1;
+		}
+	while (fgets(str, MAXCHAR, fp) != NULL) printf("%s", str);
+	fclose(fp);
+	puts(H_file);
+        fp = fopen(KeyValue(get_key("files","footer",&config_head, NAME_NAME)), "r");
+        if (fp == NULL){
+                printf("Could not open header file\n");
+                return 1;
+                }
+        while (fgets(str, MAXCHAR, fp) != NULL) printf("%s", str);
+        fclose(fp);
+	return 0;
+}
--- a/scripts/exein/mkHookhcomp/Makefile
+++ b/scripts/exein/mkHookhcomp/Makefile
@@ -0,0 +1,4 @@
+hostprogs-y     := mkHookhcomp
+mkHookhcomp-objs    := ../config.o mkHookhcomp.o
+HOST_EXTRACFLAGS += -std=gnu11
+always          := $(hostprogs-y)
--- a/scripts/exein/HeaderParser/Makefile
+++ b/scripts/exein/HeaderParser/Makefile
@@ -0,0 +1,19 @@
+hostprogs-y     := HeaderParser
+always          := $(hostprogs-y)
+HeaderParser-objs   := lex.yy.o HeaderParser.tab.o
+HOST_EXTRACFLAGS += -lm
+
+$(obj)/HeaderParser.tab.h: $(src)/HeaderParser.y FORCE
+				bison -o/dev/null --defines=$@ -t -l $<
+
+$(obj)/HeaderParser.tab.c: $(src)/HeaderParser.y FORCE
+				bison -o $@ $<
+
+$(obj)/lex.yy.o: $(obj)/HeaderParser.tab.h
+
+$(obj)/lex.yy.c: $(src)/HeaderParser.l FORCE
+	flex -o $@ $<
+
+# -I needed for generated C source (shipped source)
+HOSTCFLAGS_HeaderParser.tab.o := -I$(src)
+HOSTCFLAGS_lex.yy.o := -I$(src)
--- a/scripts/exein/HeaderParser/HeaderParser.y
+++ b/scripts/exein/HeaderParser/HeaderParser.y
@@ -0,0 +1,163 @@
+%{
+
+#include <stdio.h>
+#include <stdlib.h>
+
+extern int yylex();
+extern int yyparse();
+extern FILE* yyin;
+
+void yyerror(const char* s);
+%}
+
+%union {
+	int ival;
+	float fval;
+	char *sval;
+}
+
+
+%token PO PC COLON COMMA STRUCT UNSIGNED CONST INT LONG SIGNED SHORT CHAR VOID AST ENUM UNION
+%token<sval> ARGNAME ARGTYPE FUNNAME TYPE IDENTIFIER
+%type<sval> statement arguments argument type argname funname
+
+%%
+
+definitions:  /* empty */
+	|definitions instruction
+	;
+
+instruction: COLON                                  
+	|statement COLON                            { printf("\n");}
+	;
+
+statement:  type funname PO arguments               
+	;
+
+arguments: argument
+	| arguments argument                        
+	;
+
+argument: type argname                              
+	| VOID PC                                   
+	;
+
+argname: IDENTIFIER COMMA                           
+	|IDENTIFIER PC                              
+	;
+funname: PO AST IDENTIFIER PC                       { printf("%s,", $3); }
+
+
+type: IDENTIFIER                                    { printf("%s,", $1); }
+	| UNION IDENTIFIER                          { printf("union %s,", $2); }
+	| ENUM IDENTIFIER                           { printf("enum %s,", $2); }
+	| CONST IDENTIFIER                          { printf("const  %s,", $2); }
+	| CONST STRUCT IDENTIFIER                   { printf("const struct %s,", $3); }
+	| STRUCT IDENTIFIER                         { printf("struct %s,", $2); }
+	| CHAR                                      { printf("char,"); }
+	| CONST CHAR                                { printf("const char,"); }
+	| SIGNED CHAR                               { printf("signed char,"); }
+	| UNSIGNED CHAR                             { printf("unsigned char,"); }
+	| SHORT                                     { printf("short,"); }
+	| SHORT INT                                 { printf("short int,"); }
+	| SIGNED SHORT                              { printf("signed short,"); }
+	| SIGNED SHORT INT                          { printf("signed shot int,"); }
+	| UNSIGNED SHORT                            { printf("unsigned short,"); }
+	| UNSIGNED SHORT INT                        { printf("unsigned short int,"); }
+	| INT                                       { printf("int,"); }
+	| SIGNED                                    { printf("signed,"); }
+	| SIGNED INT                                { printf("signed int,"); }
+	| UNSIGNED                                  { printf("unsigned,"); }
+	| UNSIGNED INT                              { printf("unsigned int,"); }
+	| LONG                                      { printf("long,"); }
+	| LONG INT                                  { printf("long int,"); }
+	| SIGNED LONG                               { printf("signed long,"); }
+	| SIGNED LONG INT                           { printf("signed long int,"); }
+	| UNSIGNED LONG                             { printf("unsigned long,"); }
+	| UNSIGNED LONG INT                         { printf("unsigned long int,"); }
+	| LONG LONG                                 { printf("long long,"); }
+	| LONG LONG INT                             { printf("long long int,"); }  
+	| SIGNED LONG LONG                          { printf("signed long long,"); }
+	| SIGNED LONG LONG INT                      { printf("signed long long int,"); }
+	| UNSIGNED LONG LONG                        { printf("unsigned long long,"); }
+	| UNSIGNED LONG LONG INT                    { printf("unsigned long long int,"); }
+	| VOID                                      { printf("void,"); }
+	| IDENTIFIER AST                            { printf("%s *,", $1); }
+	| UNION IDENTIFIER AST                      { printf("union %s *,", $2); }
+	| CONST IDENTIFIER AST                      { printf("const struct %s,", $2); }
+	| CONST STRUCT IDENTIFIER AST               { printf("const struct %s *,", $3); }
+	| STRUCT IDENTIFIER AST                     { printf("struct %s *,", $2); }
+	| CHAR AST                                  { printf("char *,"); }
+	| CONST CHAR AST                            { printf("const char *,"); }
+	| SIGNED CHAR AST                           { printf("signed char *,"); }
+	| UNSIGNED CHAR AST                         { printf("unsigned char *,"); }
+	| SHORT AST                                 { printf("short *,"); }
+	| SHORT INT AST                             { printf("short int *,"); }
+	| SIGNED SHORT AST                          { printf("signed short *,"); }
+	| SIGNED SHORT INT AST                      { printf("signed shot int *,"); }
+	| UNSIGNED SHORT AST                        { printf("unsigned short *,"); }
+	| UNSIGNED SHORT INT AST                    { printf("unsigned short int *,"); }
+	| INT AST                                   { printf("int *,"); }
+	| SIGNED AST                                { printf("signed *,"); }
+	| SIGNED INT AST                            { printf("signed int *,"); }
+	| UNSIGNED AST                              { printf("unsigned *,"); }
+	| UNSIGNED INT AST                          { printf("unsigned int *,"); }
+	| LONG AST                                  { printf("long *,"); }
+	| LONG INT AST                              { printf("long int *,"); }
+	| SIGNED LONG AST                           { printf("signed long *,"); }
+	| SIGNED LONG INT AST                       { printf("signed long int *,"); }
+	| UNSIGNED LONG AST                         { printf("unsigned long *,"); }
+	| UNSIGNED LONG INT AST                     { printf("unsigned long int *,"); }
+	| LONG LONG AST                             { printf("long long *,"); }
+	| LONG LONG INT AST                         { printf("long long int *,"); }  
+	| SIGNED LONG LONG AST                      { printf("signed long long *,"); }
+	| SIGNED LONG LONG INT AST                  { printf("signed long long int *,"); }
+	| UNSIGNED LONG LONG AST                    { printf("unsigned long long *,"); }
+	| UNSIGNED LONG LONG INT AST                { printf("unsigned long long int *,"); }
+	| CONST VOID AST                            { printf("const void *,"); }
+	| VOID AST                                  { printf("void *,"); }
+	| IDENTIFIER AST AST                        { printf("%s **,", $1); }
+	| CONST IDENTIFIER AST AST                  { printf("const struct %s,", $2); }
+	| CONST STRUCT IDENTIFIER AST AST           { printf("const struct %s **,", $3); }
+	| STRUCT IDENTIFIER AST AST                 { printf("struct %s **,", $2); }
+	| CHAR AST AST                              { printf("char **,"); }
+	| CONST CHAR AST AST                        { printf("const char **,"); }
+	| SIGNED CHAR AST AST                       { printf("signed char **,"); }
+	| UNSIGNED CHAR AST AST                     { printf("unsigned char **,"); }
+	| SHORT AST AST                             { printf("short **,"); }
+	| SHORT INT AST AST                         { printf("short int **,"); }
+	| SIGNED SHORT AST AST                      { printf("signed short **,"); }
+	| SIGNED SHORT INT AST AST                  { printf("signed shot int **,"); }
+	| UNSIGNED SHORT AST AST                    { printf("unsigned short **,"); }
+	| UNSIGNED SHORT INT AST AST                { printf("unsigned short int **,"); }
+	| INT AST AST                               { printf("int **,"); }
+	| SIGNED AST AST                            { printf("signed **,"); }
+	| SIGNED INT AST AST                        { printf("signed int *,"); }
+	| UNSIGNED AST AST                          { printf("unsigned **,"); }
+	| UNSIGNED INT AST AST                      { printf("unsigned int **,"); }
+	| LONG AST AST                              { printf("long **,"); }
+	| LONG INT AST AST                          { printf("long int **,"); }
+	| SIGNED LONG AST AST                       { printf("signed long **,"); }
+	| SIGNED LONG INT AST AST                   { printf("signed long int **,"); }
+	| UNSIGNED LONG AST AST                     { printf("unsigned long **,"); }
+	| UNSIGNED LONG INT AST AST                 { printf("unsigned long int **,"); }
+	| LONG LONG AST AST                         { printf("long long **,"); }
+	| LONG LONG INT AST AST                     { printf("long long int **,"); }  
+	| SIGNED LONG LONG AST AST                  { printf("signed long long **,"); }
+	| SIGNED LONG LONG INT AST AST              { printf("signed long long int **,"); }
+	| UNSIGNED LONG LONG AST AST                { printf("unsigned long long **,"); }
+	| UNSIGNED LONG LONG INT AST AST            { printf("unsigned long long int **,"); }
+	| CONST VOID AST AST                        { printf("const void **,"); }
+	| VOID AST AST                              { printf("void **,"); }
+	;
+%%
+int main() {
+	yyin = stdin;
+	yyparse();
+	return 0;
+}
+
+void yyerror(const char* s) {
+	fprintf(stderr, "Parse error: %s %s,", yylval.sval, s);
+	exit(1);
+}
--- a/scripts/exein/HeaderParser/HeaderParser.l
+++ b/scripts/exein/HeaderParser/HeaderParser.l
@@ -0,0 +1,128 @@
+%option noyywrap
+
+%{
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "HeaderParser.tab.h"
+
+#define YY_DECL int yylex()
+
+int collect=0, typename=0;
+
+char *buffer;
+
+%}
+
+
+
+%%
+
+"union security_list_options {"	{
+				 collect=1;
+				}
+"struct"			{
+				 if (collect) {
+					 return STRUCT;
+					}
+				}
+"unsigned"			{
+				 if (collect) {
+					 return UNSIGNED;
+					}
+				}
+"long"				{
+				 if (collect) {
+					 return LONG;
+					}
+				}
+"int"				{
+				 if (collect) {
+					 return INT;
+					}
+				}
+"signed"			{
+				 if (collect) {
+					 return SIGNED;
+					}
+				}
+"short"				{
+				 if (collect) {
+					 return SHORT;
+					}
+				}
+"char"				{
+				 if (collect) {
+					 return CHAR;
+					}
+				}
+"void"				{
+				 if (collect) {
+					 return VOID;
+					}
+				}
+"const"                        {
+                                 if (collect) {
+					 return CONST;
+                                        }
+                                }
+"enum"                        {
+                                 if (collect) {
+					 return ENUM;
+                                        }
+                                }
+"union"                        {
+                                 if (collect) {
+					 return UNION;
+                                        }
+                                }
+
+"#ifdef "[A-Z_]+		;//{printf("ifdef skipped\n");}
+"#endif"			;//{printf("endif skipped\n");}
+"__"[a-z]+			;//{printf("annotation skipped\n");}
+"/*"[A-Za-z0-9_ ]*"*/"		;//{printf("skip comments skipped\n");}
+[A-Za-z0-9_]+			{
+				 if (collect) {
+					 yylval.sval=(char *) malloc(256);
+					 strcpy(yylval.sval,yytext);
+					 return IDENTIFIER; 
+					}
+                                }
+"{"				{
+				 if (collect) { 
+					}
+				}
+"}"				{
+				 if (collect) {
+					 collect=0;
+					}
+				}
+"("				{
+				 if (collect) {
+					 return PO; 
+					}
+				}
+")"				{
+				 if (collect) {
+					 return PC;
+					}
+				}
+"*"				{
+				 if (collect) {
+					 return AST;
+					}
+				}
+","				{
+				 if (collect) {
+					 return COMMA;
+					}
+				}
+";"				{
+				 if (collect) { 
+					 return COLON;
+					}
+				}
+[ \t\r\n]			;
+.				;
+
+%%
--- a/scripts/exein/data/lookup
+++ b/scripts/exein/data/lookup
@@ -0,0 +1,237 @@
+Audit:audit_rule_free
+Audit:audit_rule_init
+Audit:audit_rule_known
+Audit:audit_rule_match
+Audit:inode_getsecctx
+Audit:inode_invalidate_secctx
+Audit:inode_notifysecctx
+Audit:inode_setsecctx
+eBPF:bpf
+eBPF:bpf_map
+eBPF:bpf_map_alloc_security
+eBPF:bpf_map_free_security
+eBPF:bpf_prog
+eBPF:bpf_prog_alloc_security
+eBPF:bpf_prog_free_security
+Exec:bprm_check_security
+Exec:bprm_committed_creds
+Exec:bprm_committing_creds
+Exec:bprm_secureexec
+Exec:bprm_set_creds
+Files:dentry_open
+Files:file_alloc_security
+Files:file_fcntl
+Files:file_free_security
+Files:file_ioctl
+Files:file_lock
+Files:file_mmap
+Files:file_mprotect
+Files:file_open
+Files:file_permission
+Files:file_receive
+Files:file_send_sigiotask
+Files:file_set_fowner
+Files:mmap_addr
+Files:mmap_file
+Filesystems:d_instantiate
+Filesystems:dentry_create_files_as
+Filesystems:dentry_init_security
+Filesystems:move_mount
+Filesystems:sb_alloc_security
+Filesystems:sb_clone_mnt_opts
+Filesystems:sb_copy_data
+Filesystems:sb_free_security
+Filesystems:sb_mount
+Filesystems:sb_parse_opts_str
+Filesystems:sb_pivotroot
+Filesystems:sb_remount
+Filesystems:sb_set_mnt_opts
+Filesystems:sb_statfs
+Filesystems:sb_umount
+Filesystems:quotactl
+Filesystems:quota_on
+Filesystems:sb_free_mnt_opts
+Filesystems:sb_eat_lsm_opts
+Filesystems:sb_kern_mount
+Filesystems:sb_show_options
+Filesystems:sb_add_mnt_opt
+Infiniband:ib_alloc_security
+Infiniband:ib_endport_manage_subnet
+Infiniband:ib_free_security
+Infiniband:ib_pkey_access
+Inodes:inode_alloc_security
+Inodes:inode_copy_up
+Inodes:inode_copy_up_xattr
+Inodes:inode_create
+Inodes:inode_follow_link
+Inodes:inode_free_security
+Inodes:inode_getattr
+Inodes:inode_getsecid
+Inodes:inode_getsecurity
+Inodes:inode_getxattr
+Inodes:inode_init_security
+Inodes:inode_killpriv
+Inodes:inode_link
+Inodes:inode_listsecurity
+Inodes:inode_listxattr
+Inodes:inode_mkdir
+Inodes:inode_mknod
+Inodes:inode_need_killpriv
+Inodes:inode_permission
+Inodes:inode_post_setxattr
+Inodes:inode_readlink
+Inodes:inode_removexattr
+Inodes:inode_rename
+Inodes:inode_rmdir
+Inodes:inode_setattr
+Inodes:inode_setsecurity
+Inodes:inode_setxattr
+Inodes:inode_symlink
+Inodes:inode_unlink
+Inodes:path_chmod
+Inodes:path_chown
+Inodes:path_chroot
+Inodes:path_link
+Inodes:path_mkdir
+Inodes:path_mknod
+Inodes:path_rename
+Inodes:path_rmdir
+Inodes:path_symlink
+Inodes:path_truncate
+Inodes:path_unlink
+Kernfs:kernfs_init_security
+KeyManagement:key_alloc
+KeyManagement:key_free
+KeyManagement:key_getsecurity
+KeyManagement:key_permission
+Mountfs_context:fs_context_dup
+Mountfs_context:fs_context_parse_param
+Netlink.messaging:netlink_recv
+Netlink.messaging:netlink_send
+Others:binder_set_context_mgr
+Others:binder_transaction
+Others:binder_transfer_binder
+Others:binder_transfer_file
+Others:capable
+Others:capget
+Others:capset
+Others:ismaclabel
+Others:ptrace_access_check
+Others:ptrace_traceme
+Others:release_secctx
+Others:secctx_to_secid
+Others:secid_to_secctx
+Others:settime
+Others:syslog
+Others:vm_enough_memory
+SCTP:sctp_assoc_request
+SCTP:sctp_bind_connect
+SCTP:sctp_sk_clone
+Sockets:inet_conn_established
+Sockets:inet_conn_request
+Sockets:inet_csk_clone
+Sockets:req_classify_flow
+Sockets:secmark_refcount_dec
+Sockets:secmark_refcount_inc
+Sockets:secmark_relabel_packet
+Sockets:security_secmark_refcount_dec
+Sockets:security_secmark_refcount_inc
+Sockets:sk_alloc_security
+Sockets:skb_owned_by
+Sockets:sk_clone_security
+Sockets:sk_free_security
+Sockets:sk_getsecid
+Sockets:socket_accept
+Sockets:socket_bind
+Sockets:socket_connect
+Sockets:socket_create
+Sockets:socket_getpeername
+Sockets:socket_getpeersec_dgram
+Sockets:socket_getpeersec_stream
+Sockets:socket_getsockname
+Sockets:socket_getsockopt
+Sockets:socket_listen
+Sockets:socket_post_create
+Sockets:socket_recvmsg
+Sockets:socket_sendmsg
+Sockets:socket_setsockopt
+Sockets:socket_shutdown
+Sockets:socket_socketpair
+Sockets:socket_sock_rcv_skb
+Sockets:sock_graft
+Sockets:tun_dev_alloc_security
+Sockets:tun_dev_attach
+Sockets:tun_dev_attach_queue
+Sockets:tun_dev_create
+Sockets:tun_dev_free_security
+Sockets:tun_dev_open
+Sockets:tun_dev_post_create
+SystemVAll:ipc_getsecid
+SystemVAll:ipc_permission
+SystemVMessageQueues:msg_msg_alloc_security
+SystemVMessageQueues:msg_msg_free_security
+SystemVMessageQueues:msg_queue_alloc_security
+SystemVMessageQueues:msg_queue_associate
+SystemVMessageQueues:msg_queue_free_security
+SystemVMessageQueues:msg_queue_msgctl
+SystemVMessageQueues:msg_queue_msgrcv
+SystemVMessageQueues:msg_queue_msgsnd
+SystemVSemaphores:sem_alloc_security
+SystemVSemaphores:sem_associate
+SystemVSemaphores:sem_free_security
+SystemVSemaphores:sem_semctl
+SystemVSemaphores:sem_semop
+SystemVSHM:shm_alloc_security
+SystemVSHM:shm_associate
+SystemVSHM:shm_free_security
+SystemVSHM:shm_shmat
+SystemVSHM:shm_shmctl
+Tasks:getprocattr
+Tasks:setprocattr
+Tasks:cred_alloc_blank
+Tasks:cred_free
+Tasks:cred_getsecid
+Tasks:cred_prepare
+Tasks:cred_transfer
+Tasks:kernel_act_as
+Tasks:kernel_create_files_as
+Tasks:kernel_fw_from_file
+Tasks:kernel_load_data
+Tasks:kernel_module_from_file
+Tasks:kernel_module_request
+Tasks:kernel_post_read_file
+Tasks:kernel_read_file
+Tasks:task_alloc
+Tasks:task_create
+Tasks:task_fix_setuid
+Tasks:task_free
+Tasks:task_getioprio
+Tasks:task_getpgid
+Tasks:task_getscheduler
+Tasks:task_getsecid
+Tasks:task_getsid
+Tasks:task_kill
+Tasks:task_movememory
+Tasks:task_prctl
+Tasks:task_prlimit
+Tasks:task_setioprio
+Tasks:task_setnice
+Tasks:task_setpgid
+Tasks:task_setrlimit
+Tasks:task_setscheduler
+Tasks:task_to_inode
+Tasks:task_wait
+UnixSocket:unix_may_send
+UnixSocket:unix_stream_connect
+XFRM:xfrm_decode_session
+XFRM:xfrm_policy_alloc_security
+XFRM:xfrm_policy_clone_security
+XFRM:xfrm_policy_delete_security
+XFRM:xfrm_policy_free_security
+XFRM:xfrm_policy_lookup
+XFRM:xfrm_state_alloc
+XFRM:xfrm_state_alloc_acquire
+XFRM:xfrm_state_alloc_security
+XFRM:xfrm_state_delete_security
+XFRM:xfrm_state_free_security
+XFRM:xfrm_state_pol_flow_match
--- a/include/exein.h
+++ b/include/exein.h
@@ -0,0 +1,3 @@
+void exein_delete_pids(void);
+void do_exit_push_pid(pid_t pid);
+void do_fork_push_pid(pid_t pid, void *addr);
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -1512,6 +1512,10 @@
 #endif
 	int on_rq;
 
+#ifdef CONFIG_SECURITY_EXEIN
+	uint16_t                        process_tag;
+#endif
+
 	int prio, static_prio, normal_prio;
 	unsigned int rt_priority;
 	const struct sched_class *sched_class;
--- a/docs/GeneralDiagram.svg
+++ b/docs/GeneralDiagram.svg
@@ -0,0 +1,3 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
+<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="654px" height="444px" viewBox="-0.5 -0.5 654 444" content="&lt;mxfile host=&quot;app.diagrams.net&quot; modified=&quot;2020-05-19T10:30:12.158Z&quot; agent=&quot;5.0 (X11)&quot; etag=&quot;wJsR3v6sjBHt92BrfcgQ&quot; version=&quot;13.1.1&quot; type=&quot;device&quot;&gt;&lt;diagram id=&quot;2CBHIzs9DMrx8Qk8myeK&quot; name=&quot;Page-1&quot;&gt;7Vxtd6I6EP41fpQDhCB81Gq7e9a9t3fd1097EKJyF42F2Gp//U0kIJCgoPhyt9ueY2EIQ5h5ZvJMEtsCd/P1Q+gsZx+xh4KWrnrrFui3dN22NPrJBJtYANkZE0xD34tF2k4w8l8RF6pcuvI9FOUaEowD4i/zQhcvFsglOZkThvgl32yCg/xTl84UCYKR6wSi9JvvkVkstaC6k79D/nSWPFlT+ZW5kzTmgmjmePglIwKDFrgLMSbx0Xx9hwJmu8Qu8X33JVfTjoVoQarc4L2uzNngy8vCB++9u+/vOv2fRhsYsZpnJ1jxN+a9JZvEBCFeLTzEtGgt0HuZ+QSNlo7Lrr5Qn1PZjMwDfjkiIf6VmsqgkglekBHXJuk0Fz2jkKB1RsRf4gHhOSLhhjZJIGUrwIpv4pgCJjfxy85DZuKhWcY7eocLHY6Kaap9Zzh6wG1Xw46JkzN2HKyRv6Ci4ehj4yb1g+AOBzjcagMeRJZnpC0zVyx9DEzzDE6gIVD0AjREL2i6xAvmuZwANMEJLd0M6GN7nv9MD6fsMBGNw6KEPlTS7qhbC/5GHk0q/BSHZIaneOEEg520t0OESs92bYYYLzkO/kWEbHiGdFYE51FCfRluvrP7lQ5Mzn9kL/bXXHt8tuFnBTBNLBe5rgxMYwsaUBXABHqBM0ZBz3F/TbdvkdyywAv2Zmjtk2y/6OmPpCP0eNcrdpJ0qhSizJJVAKoqOlDzAG1rKlcSosAh/nM+xcvgyNU/Yp92I9UNNJqCOvkUZBVAHeFV6CJ+YzYrH9alw4Iu4oRTRPboShriySRCRIij1DonhJZ+eJy4AMgjagrSZcP6Dl9b2b3P3oej20tauIETRb4bC3kTLQvJLB4VuBeRaXy1VUXVswFGgW3AawcZe9ojCn3qaBTWDCJKqbYIOzi+lUYbs4kBYSPRRUd4RbeMjqnZ6vZTz0WHoR0ZaQf0QgsqLIxtyD8rxSBFmrPJNFuyBlH5y2mGLX2bsk4X29NeFsI77sHFE4IujrUp4flwbsJTO3waIDwACLTTujbh0UX2/gGFi20F9g7jX9FViYiWT5J1UyRkvzIfm9uf2inyeEpxYkKDqlCxQGgeSReMw7oaSlWGWfqost4dviWfsBpLRkCIg6G/WK2pKImH8+ajaljNyOOfM+QpqAqFmSxPpZpz5TE4W6IyBQeNNpHrBKJnLlsq5SoltWaGmkx0+SjkmWMTNpih4uywz76wKo8DTee803ABBVw8hthFkThyNRyx9X3nBP50QY9d6h1GscvdVSNaoaVY+Wil7PTarMISWYW/ve3xff+WGEXnEKXIlYu7YjBbMWr5ijEtp7xsRZnOYKhqbgpDsWxjf9FIT4pV2amTdzfNc3IFVp4IWIaSqa7ACQRoz0Ns8wJFnIyE7avLGpuEEWnOdYfPfDjqtcLxsrM3xaBzkDWRpn/TtdB4csGhO+Fch4fu84TxETMYRfALK0+HbwH2JeKlfFHm43BwZoZRG2INzFHogp2vzyaASPE+DD79NRhS2eixeyf6gb4tkRm7EHJZe3ORQNGY7XxaZnT5hbnvedskKPNuPjE2FP/VvQdsTTELqwodifdUKHpPP5v3xMLty2jw6Y/vDvsOXNB39pfp8vWh/RNp35aPrqGOJ96Ptrhk87n70GTW05oxnpnknmQ40UTLAdlqfgOGmwyGsPvP18ln8+kr+Pn9aTRv2+1ay8gMazmLmk8rnFxoR1sS1aUNNHW53l1MtKTVrrp3bTl+yJGr1af18B45ZBUi1sV7RHFSr1M3mR5CTChBwuyutr1bKBMQK8F1+dhrFUAsGXg7tmLaF8Rxpw6Of9/tEDe1G0LK4esA7ZwbG/RCJj56V0NR0ZW3NEijQ5zl+hMd146OihN2tx1Elq0kC7Mnx5Go6xZDyS4NpdO4x1/oJZl1LmEdb4dfaLfHLzRxfuVsNLSPAkTQATS8dQ5q3CBGyoupceKi7gLPnYC9SJ/62CW5KmP8Bh1ZZE+yjUbS/e1n86I4l9D3qbVXEQvpsiXb39dBhWLP4Ks/hVlWpaNf0key1aEzZePPzrSl025ud5nRPywnsxkMZ87sH3/+L+Y0fquBpKlhBFZAN9QU86Lolk1mFBwSzZwlO3Q3gU8tFJbYL+OwcWzK4TgVpJXJ3ytCtSRlSwNmBXbBrJLvy5iSpF6sHZozqawCLtaisuXYbCGZbo2o/t2OsvXjzoHis1Wx6quyX0qy6LoHdqJPMz6TDcSJ7NQdFXoBMsXar2odCTsFRWq1IrLu4rBe2Mxk2M3u/pT7SFZ+HovjLIoVUBHH9SZRGp7kyMN9b/KsuMfgD9yrwt0G+eeYxvnhLvmqqYQofUJPKxSRqDKzYos70V7C9ha5ENCKkATioK0pCQ4uQoUku935lz3KnJfxXN8hTmVM9FaTCQobBEV1Z1N27r86460q5kseilQv7LVgn+laERwT/eYYGiyEs0h896W/Gp6mp7tv/seZYffvE8DgPw==&lt;/diagram&gt;&lt;/mxfile&gt;"><defs/><g><rect x="1.38" y="172" width="650" height="270" rx="40.5" ry="40.5" fill="#ffffff" stroke="#000000" stroke-width="4" pointer-events="all"/><rect x="130.38" y="352" width="120" height="60" rx="9" ry="9" fill="#d5e8d4" stroke="#82b366" stroke-width="4" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 382px; margin-left: 131px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; font-weight: bold; white-space: normal; word-wrap: normal; ">Exein LSM</div></div></div></foreignObject><text x="190" y="386" fill="#000000" font-family="Helvetica" font-size="12px" text-anchor="middle" font-weight="bold">Exein LSM</text></switch></g><path d="M 221.37 192 L 221.37 68.37" fill="none" stroke="#b85450" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 221.37 63.12 L 224.87 70.12 L 221.37 68.37 L 217.87 70.12 Z" fill="#b85450" stroke="#b85450" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 112px; margin-left: 322px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; font-weight: bold; white-space: nowrap; "><div><br /></div><div><br /></div></div></div></div></foreignObject><text x="322" y="115" fill="#000000" font-family="Helvetica" font-size="11px" text-anchor="middle" font-weight="bold">&#xa;</text></switch></g><path d="M 131.28 222 L 51 222 L 51 396.69 L 121.61 396.7" fill="none" stroke="#b85450" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 126.86 396.7 L 119.86 400.2 L 121.61 396.7 L 119.86 393.2 Z" fill="#b85450" stroke="#b85450" stroke-miterlimit="10" pointer-events="all"/><rect x="135.38" y="192" width="120" height="60" rx="9" ry="9" fill="#f8cecc" stroke="#b85450" stroke-width="4" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 222px; margin-left: 136px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; font-weight: bold; white-space: normal; word-wrap: normal; ">Exein LKM</div></div></div></foreignObject><text x="195" y="226" fill="#000000" font-family="Helvetica" font-size="12px" text-anchor="middle" font-weight="bold">Exein LKM</text></switch></g><path d="M 411.38 368 L 371.41 368 L 257.75 368" fill="none" stroke="#666666" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 252.5 368 L 259.5 364.5 L 257.75 368 L 259.5 371.5 Z" fill="#666666" stroke="#666666" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 368px; margin-left: 331px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; font-weight: bold; white-space: nowrap; ">Kernel Hooks</div></div></div></foreignObject><text x="331" y="371" fill="#000000" font-family="Helvetica" font-size="11px" text-anchor="middle" font-weight="bold">Kernel Hooks</text></switch></g><rect x="410.38" y="192" width="221" height="230" rx="33.15" ry="33.15" fill="#f5f5f5" stroke="#666666" stroke-width="4" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 219px; height: 1px; padding-top: 307px; margin-left: 411px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: #333333; line-height: 1.2; pointer-events: all; font-weight: bold; white-space: normal; word-wrap: normal; ">Linux Kernel</div></div></div></foreignObject><text x="521" y="311" fill="#333333" font-family="Helvetica" font-size="12px" text-anchor="middle" font-weight="bold">Linux Kernel</text></switch></g><path d="M 520.88 62 L 520.88 185.63" fill="none" stroke="#d6b656" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 520.88 190.88 L 517.38 183.88 L 520.88 185.63 L 524.38 183.88 Z" fill="#d6b656" stroke="#d6b656" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 127px; margin-left: 521px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; font-weight: bold; white-space: nowrap; ">Syscall</div></div></div></foreignObject><text x="521" y="130" fill="#000000" font-family="Helvetica" font-size="11px" text-anchor="middle" font-weight="bold">Syscall</text></switch></g><rect x="460.88" y="2" width="120" height="60" rx="9" ry="9" fill="#fff2cc" stroke="#d6b656" stroke-width="4" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 32px; margin-left: 462px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; font-weight: bold; white-space: normal; word-wrap: normal; ">Process</div></div></div></foreignObject><text x="521" y="36" fill="#000000" font-family="Helvetica" font-size="12px" text-anchor="middle" font-weight="bold">Process</text></switch></g><path d="M 404.92 396.81 L 251.28 396.83 L 251.28 408.24" fill="none" stroke="#82b366" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 410.17 396.81 L 403.17 400.31 L 404.92 396.81 L 403.17 393.31 Z" fill="#82b366" stroke="#82b366" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 397px; margin-left: 326px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; font-weight: bold; white-space: nowrap; ">Kill PID</div></div></div></foreignObject><text x="326" y="400" fill="#000000" font-family="Helvetica" font-size="11px" text-anchor="middle" font-weight="bold">Kill PID</text></switch></g><path d="M 131.38 32 L 51.41 32 L 51.41 206.97 L 129.01 207" fill="none" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 134.26 207 L 127.26 210.5 L 129.01 207 L 127.26 203.5 Z" fill="#6c8ebf" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="all"/><rect x="131.38" y="2" width="120" height="60" rx="9" ry="9" fill="#dae8fc" stroke="#6c8ebf" stroke-width="4" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 32px; margin-left: 132px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; font-weight: bold; white-space: normal; word-wrap: normal; ">Exein MLE</div></div></div></foreignObject><text x="191" y="36" fill="#000000" font-family="Helvetica" font-size="12px" text-anchor="middle" font-weight="bold">Exein MLE</text></switch></g><rect x="293.67" y="182" width="105" height="20" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 103px; height: 1px; padding-top: 192px; margin-left: 295px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; font-weight: bold; white-space: normal; word-wrap: normal; ">KERNEL SPACE</div></div></div></foreignObject><text x="346" y="196" fill="#000000" font-family="Helvetica" font-size="12px" text-anchor="middle" font-weight="bold">KERNEL SPACE</text></switch></g><rect x="293.67" y="142" width="105" height="20" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 103px; height: 1px; padding-top: 152px; margin-left: 295px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; font-weight: bold; white-space: normal; word-wrap: normal; ">USER SPACE</div></div></div></foreignObject><text x="346" y="156" fill="#000000" font-family="Helvetica" font-size="12px" text-anchor="middle" font-weight="bold">USER SPACE</text></switch></g><rect x="562" y="22" width="30" height="20" rx="3" ry="3" fill="#ffffff" stroke="#000000" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 28px; height: 1px; padding-top: 32px; margin-left: 563px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; white-space: normal; word-wrap: normal; ">TAG</div></div></div></foreignObject><text x="577" y="36" fill="#000000" font-family="Helvetica" font-size="12px" text-anchor="middle">TAG</text></switch></g><rect x="182" y="102" width="79.69" height="20" fill="none" stroke="none" transform="rotate(-90,221.85,112)" pointer-events="all"/><g transform="translate(-0.5 -0.5)rotate(-90 221.84500000000003 111.99999999999989)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 78px; height: 1px; padding-top: 112px; margin-left: 183px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; white-space: normal; word-wrap: normal; "><div><font style="font-size: 10px">Process <br /></font></div><div><font style="font-size: 10px">Features Feed</font></div></div></div></div></foreignObject><text x="222" y="116" fill="#000000" font-family="Helvetica" font-size="12px" text-anchor="middle">Process...</text></switch></g><path d="M 162 192 L 162 68.37" fill="none" stroke="#b85450" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 162 63.12 L 165.5 70.12 L 162 68.37 L 158.5 70.12 Z" fill="#b85450" stroke="#b85450" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 112px; margin-left: 263px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; font-weight: bold; white-space: nowrap; "><div><br /></div><div><br /></div></div></div></div></foreignObject><text x="263" y="115" fill="#000000" font-family="Helvetica" font-size="11px" text-anchor="middle" font-weight="bold">&#xa;</text></switch></g><path d="M 191.24 185.63 L 191.24 68.37" fill="none" stroke="#b85450" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 191.24 190.88 L 187.74 183.88 L 191.24 185.63 L 194.74 183.88 Z" fill="#b85450" stroke="#b85450" stroke-miterlimit="10" pointer-events="all"/><path d="M 191.24 63.12 L 194.74 70.12 L 191.24 68.37 L 187.74 70.12 Z" fill="#b85450" stroke="#b85450" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 112px; margin-left: 292px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; font-weight: bold; white-space: nowrap; "><div><br /></div><div><br /></div></div></div></div></foreignObject><text x="292" y="115" fill="#000000" font-family="Helvetica" font-size="11px" text-anchor="middle" font-weight="bold">&#xa;</text></switch></g><rect x="112" y="102" width="79.69" height="20" fill="none" stroke="none" transform="rotate(-90,151.85,112)" pointer-events="all"/><g transform="translate(-0.5 -0.5)rotate(-90 151.84500000000003 111.99999999999989)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 78px; height: 1px; padding-top: 112px; margin-left: 113px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; white-space: normal; word-wrap: normal; "><font style="font-size: 10px">New PID</font></div></div></div></foreignObject><text x="152" y="116" fill="#000000" font-family="Helvetica" font-size="12px" text-anchor="middle">New PID</text></switch></g><rect x="142" y="102" width="79.69" height="20" fill="none" stroke="none" transform="rotate(-90,181.85,112)" pointer-events="all"/><g transform="translate(-0.5 -0.5)rotate(-90 181.84500000000003 111.99999999999989)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 78px; height: 1px; padding-top: 112px; margin-left: 143px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; white-space: normal; word-wrap: normal; "><div><font style="font-size: 10px">Delete PID</font></div></div></div></div></foreignObject><text x="182" y="116" fill="#000000" font-family="Helvetica" font-size="12px" text-anchor="middle">Delete PID</text></switch></g><rect x="-38" y="92" width="150" height="20" fill="none" stroke="none" transform="rotate(-90,37,102)" pointer-events="all"/><g transform="translate(-0.5 -0.5)rotate(-90 37 101.99999999999989)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 148px; height: 1px; padding-top: 102px; margin-left: -37px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; white-space: normal; word-wrap: normal; "><b>Anomaly Detected</b></div></div></div></foreignObject><text x="37" y="106" fill="#000000" font-family="Helvetica" font-size="12px" text-anchor="middle">Anomaly Detected</text></switch></g><rect x="-18" y="297" width="120.72" height="20" fill="none" stroke="none" transform="rotate(-90,42.36,307)" pointer-events="all"/><g transform="translate(-0.5 -0.5)rotate(-90 42.36000000000013 306.9999999999999)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 119px; height: 1px; padding-top: 307px; margin-left: -17px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; white-space: normal; word-wrap: normal; ">Distrust Process</div></div></div></foreignObject><text x="42" y="311" fill="#000000" font-family="Helvetica" font-size="12px" text-anchor="middle">Distrust Process</text></switch></g><rect x="152" y="297" width="151.62" height="20" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 150px; height: 1px; padding-top: 307px; margin-left: 153px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; white-space: normal; word-wrap: normal; "><div><font style="font-size: 10px">Tag, Hook ID &amp; <br /></font></div><div><font style="font-size: 10px">Features</font></div></div></div></div></foreignObject><text x="228" y="311" fill="#000000" font-family="Helvetica" font-size="12px" text-anchor="middle">Tag, Hook ID &amp;...</text></switch></g><path d="M 292 268 C 292 246.67 352 246.67 352 268 L 352 316 C 352 337.33 292 337.33 292 316 Z" fill="#ffffff" stroke="#000000" stroke-miterlimit="10" pointer-events="all"/><path d="M 292 268 C 292 284 352 284 352 268" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="all"/><path d="M 190.38 352 L 190.09 318 Q 190 308 200 308 L 285.63 308" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 290.88 308 L 283.88 311.5 L 285.63 308 L 283.88 304.5 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="all"/><path d="M 285.63 276 L 205 276 Q 195 276 195.14 267.18 L 195.28 258.37" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 290.88 276 L 283.88 279.5 L 285.63 276 L 283.88 272.5 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="all"/><path d="M 195.36 253.12 L 198.75 260.17 L 195.28 258.37 L 191.75 260.06 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="all"/><rect x="212" y="265" width="61.93" height="20" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 60px; height: 1px; padding-top: 275px; margin-left: 213px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; white-space: normal; word-wrap: normal; "><div>Requests</div><div>Feeds<br /></div></div></div></div></foreignObject><text x="243" y="279" fill="#000000" font-family="Helvetica" font-size="12px" text-anchor="middle">Requests...</text></switch></g><rect x="297" y="277" width="50" height="50" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 302px; margin-left: 322px;"><div style="box-sizing: border-box; font-size: 0; text-align: center; "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: #000000; line-height: 1.2; pointer-events: all; white-space: nowrap; ">Hooks<br /><div>Data</div><div>Buffer<br /></div></div></div></div></foreignObject><text x="322" y="306" fill="#000000" font-family="Helvetica" font-size="12px" text-anchor="middle">Hooks...</text></switch></g></g><switch><g requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"/><a transform="translate(0,-5)" xlink:href="https://desk.draw.io/support/solutions/articles/16000042487" target="_blank"><text text-anchor="middle" font-size="10px" x="50%" y="100%">Viewer does not support full SVG 1.1</text></a></switch></svg>
\ No newline at end of file
--- a/docs/GeneralDiagram.drawio
+++ b/docs/GeneralDiagram.drawio
@@ -0,0 +1 @@
+<mxfile host="app.diagrams.net" modified="2020-05-19T10:29:39.167Z" agent="5.0 (X11)" etag="XiY3apEiKd-4f5y2xZ6T" version="13.1.1" type="device"><diagram id="2CBHIzs9DMrx8Qk8myeK" name="Page-1">7Vxtd6I6EP41fpQDhCB81Gq7e9a9t3fd1097EKJyF42F2Gp//U0kIJCgoPhyt9ueY2EIQ5h5ZvJMEtsCd/P1Q+gsZx+xh4KWrnrrFui3dN22NPrJBJtYANkZE0xD34tF2k4w8l8RF6pcuvI9FOUaEowD4i/zQhcvFsglOZkThvgl32yCg/xTl84UCYKR6wSi9JvvkVkstaC6k79D/nSWPFlT+ZW5kzTmgmjmePglIwKDFrgLMSbx0Xx9hwJmu8Qu8X33JVfTjoVoQarc4L2uzNngy8vCB++9u+/vOv2fRhsYsZpnJ1jxN+a9JZvEBCFeLTzEtGgt0HuZ+QSNlo7Lrr5Qn1PZjMwDfjkiIf6VmsqgkglekBHXJuk0Fz2jkKB1RsRf4gHhOSLhhjZJIGUrwIpv4pgCJjfxy85DZuKhWcY7eocLHY6Kaap9Zzh6wG1Xw46JkzN2HKyRv6Ci4ehj4yb1g+AOBzjcagMeRJZnpC0zVyx9DEzzDE6gIVD0AjREL2i6xAvmuZwANMEJLd0M6GN7nv9MD6fsMBGNw6KEPlTS7qhbC/5GHk0q/BSHZIaneOEEg520t0OESs92bYYYLzkO/kWEbHiGdFYE51FCfRluvrP7lQ5Mzn9kL/bXXHt8tuFnBTBNLBe5rgxMYwsaUBXABHqBM0ZBz3F/TbdvkdyywAv2Zmjtk2y/6OmPpCP0eNcrdpJ0qhSizJJVAKoqOlDzAG1rKlcSosAh/nM+xcvgyNU/Yp92I9UNNJqCOvkUZBVAHeFV6CJ+YzYrH9alw4Iu4oRTRPboShriySRCRIij1DonhJZ+eJy4AMgjagrSZcP6Dl9b2b3P3oej20tauIETRb4bC3kTLQvJLB4VuBeRaXy1VUXVswFGgW3AawcZe9ojCn3qaBTWDCJKqbYIOzi+lUYbs4kBYSPRRUd4RbeMjqnZ6vZTz0WHoR0ZaQf0QgsqLIxtyD8rxSBFmrPJNFuyBlH5y2mGLX2bsk4X29NeFsI77sHFE4IujrUp4flwbsJTO3waIDwACLTTujbh0UX2/gGFi20F9g7jX9FViYiWT5J1UyRkvzIfm9uf2inyeEpxYkKDqlCxQGgeSReMw7oaSlWGWfqost4dviWfsBpLRkCIg6G/WK2pKImH8+ajaljNyOOfM+QpqAqFmSxPpZpz5TE4W6IyBQeNNpHrBKJnLlsq5SoltWaGmkx0+SjkmWMTNpih4uywz76wKo8DTee803ABBVw8hthFkThyNRyx9X3nBP50QY9d6h1GscvdVSNaoaVY+Wil7PTarMISWYW/ve3xff+WGEXnEKXIlYu7YjBbMWr5ijEtp7xsRZnOYKhqbgpDsWxjf9FIT4pV2amTdzfNc3IFVp4IWIaSqa7ACQRoz0Ns8wJFnIyE7avLGpuEEWnOdYfPfDjqtcLxsrM3xaBzkDWRpn/TtdB4csGhO+Fch4fu84TxETMYRfALK0+HbwH2JeKlfFHm43BwZoZRG2INzFHogp2vzyaASPE+DD79NRhS2eixeyf6gb4tkRm7EHJZe3ORQNGY7XxaZnT5hbnvedskKPNuPjE2FP/VvQdsTTELqwodifdUKHpPP5v3xMLty2jw6Y/vDvsOXNB39pfp8vWh/RNp35aPrqGOJ96Ptrhk87n70GTW05oxnpnknmQ40UTLAdlqfgOGmwyGsPvP18ln8+kr+Pn9aTRv2+1ay8gMazmLmk8rnFxoR1sS1aUNNHW53l1MtKTVrrp3bTl+yJGr1af18B45ZBUi1sV7RHFSr1M3mR5CTChBwuyutr1bKBMQK8F1+dhrFUAsGXg7tmLaF8Rxpw6Of9/tEDe1G0LK4esA7ZwbG/RCJj56V0NR0ZW3NEijQ5zl+hMd146OihN2tx1Elq0kC7Mnx5Go6xZDyS4NpdO4x1/oJZl1LmEdb4dfaLfHLzRxfuVsNLSPAkTQATS8dQ5q3CBGyoupceKi7gLPnYC9SJ/62CW5KmP8Bh1ZZE+yjUbS/e1n86I4l9D3qbVXEQvpsiXb39dBhWLP4Ks/hVlWpaNf0key1aEzZePPzrSl025ud5nRPywnsxkMZ87sH3/+L+Y0fquBpKlhBFZAN9QU86Lolk1mFBwSzZwlO3Q3gU8tFJbYL+OwcWzK4TgVpJXJ3ytCtSRlSwNmBXbBrJLvy5iSpF6sHZozqawCLtaisuXYbCGZbo2o/t2OsvXjzoHis1Wx6quyX0qy6LoHdqJPMz6TDcSJ7NQdFXoBMsXar2odCTsFRWq1IrLu4rBe2Mxk2M3u/pT7SFZ+HovjLIoVUBHH9SZRGp7kyMN9b/KsuMfgD9yrwt0G+eeYxvnhLvmqqYQofUJPKxSRqDKzYos70V7C9ha5ENCKkATioK0pCQ4uQoUku935lz3KnJfxXN8hTmVM9FaTCQobBEV1Z1N27r86460q5kseilQv7LVgn+laERwT/eYYGiyEs0h896W/Gp6mp7tv/seZYffvE8DgPw==</diagram></mxfile>
\ No newline at end of file
--- a/docs/GeneralDiagram.png
+++ b/docs/GeneralDiagram.png
@@ -0,0 +1,155 @@
+PNG
+
+   IHDR       PT$  tEXtmxfile %3Cmxfile%20host%3D%22app.diagrams.net%22%20modified%3D%222020-05-19T10%3A30%3A29.084Z%22%20agent%3D%225.0%20(X11)%22%20etag%3D%22eMYYK1FrMU7KxfFST_A2%22%20version%3D%2213.1.1%22%20type%3D%22device%22%3E%3Cdiagram%20id%3D%222CBHIzs9DMrx8Qk8myeK%22%20name%3D%22Page-1%22%3E7Vxtd6I6EP41fpQDhCB81Gq7e9a9t3fd1097EKJyF42F2Gp%2F%2FU0kIJCgoPhyt9ueY2EIQ5h5ZvJMEtsCd%2FP1Q%2BgsZx%2Bxh4KWrnrrFui3dN22NPrJBJtYANkZE0xD34tF2k4w8l8RF6pcuvI9FOUaEowD4i%2FzQhcvFsglOZkThvgl32yCg%2FxTl84UCYKR6wSi9JvvkVkstaC6k79D%2FnSWPFlT%2BZW5kzTmgmjmePglIwKDFrgLMSbx0Xx9hwJmu8Qu8X33JVfTjoVoQarc4L2uzNngy8vCB%2B%2B9u%2B%2FvOv2fRhsYsZpnJ1jxN%2Ba9JZvEBCFeLTzEtGgt0HuZ%2BQSNlo7Lrr5Qn1PZjMwDfjkiIf6VmsqgkglekBHXJuk0Fz2jkKB1RsRf4gHhOSLhhjZJIGUrwIpv4pgCJjfxy85DZuKhWcY7eocLHY6Kaap9Zzh6wG1Xw46JkzN2HKyRv6Ci4ehj4yb1g%2BAOBzjcagMeRJZnpC0zVyx9DEzzDE6gIVD0AjREL2i6xAvmuZwANMEJLd0M6GN7nv9MD6fsMBGNw6KEPlTS7qhbC%2F5GHk0q%2FBSHZIaneOEEg520t0OESs92bYYYLzkO%2FkWEbHiGdFYE51FCfRluvrP7lQ5Mzn9kL%2FbXXHt8tuFnBTBNLBe5rgxMYwsaUBXABHqBM0ZBz3F%2FTbdvkdyywAv2Zmjtk2y%2F6OmPpCP0eNcrdpJ0qhSizJJVAKoqOlDzAG1rKlcSosAh%2FnM%2BxcvgyNU%2FYp92I9UNNJqCOvkUZBVAHeFV6CJ%2BYzYrH9alw4Iu4oRTRPboShriySRCRIij1DonhJZ%2BeJy4AMgjagrSZcP6Dl9b2b3P3oej20tauIETRb4bC3kTLQvJLB4VuBeRaXy1VUXVswFGgW3AawcZe9ojCn3qaBTWDCJKqbYIOzi%2BlUYbs4kBYSPRRUd4RbeMjqnZ6vZTz0WHoR0ZaQf0QgsqLIxtyD8rxSBFmrPJNFuyBlH5y2mGLX2bsk4X29NeFsI77sHFE4IujrUp4flwbsJTO3waIDwACLTTujbh0UX2%2FgGFi20F9g7jX9FViYiWT5J1UyRkvzIfm9uf2inyeEpxYkKDqlCxQGgeSReMw7oaSlWGWfqost4dviWfsBpLRkCIg6G%2FWK2pKImH8%2BajaljNyOOfM%2BQpqAqFmSxPpZpz5TE4W6IyBQeNNpHrBKJnLlsq5SoltWaGmkx0%2BSjkmWMTNpih4uywz76wKo8DTee803ABBVw8hthFkThyNRyx9X3nBP50QY9d6h1GscvdVSNaoaVY%2BWil7PTarMISWYW%2Fve3xff%2BWGEXnEKXIlYu7YjBbMWr5ijEtp7xsRZnOYKhqbgpDsWxjf9FIT4pV2amTdzfNc3IFVp4IWIaSqa7ACQRoz0Ns8wJFnIyE7avLGpuEEWnOdYfPfDjqtcLxsrM3xaBzkDWRpn%2FTtdB4csGhO%2BFch4fu84TxETMYRfALK0%2BHbwH2JeKlfFHm43BwZoZRG2INzFHogp2vzyaASPE%2BDD79NRhS2eixeyf6gb4tkRm7EHJZe3ORQNGY7XxaZnT5hbnvedskKPNuPjE2FP%2FVvQdsTTELqwodifdUKHpPP5v3xMLty2jw6Y%2FvDvsOXNB39pfp8vWh%2FRNp35aPrqGOJ96Ptrhk87n70GTW05oxnpnknmQ40UTLAdlqfgOGmwyGsPvP18ln8%2Bkr%2BPn9aTRv2%2B1ay8gMazmLmk8rnFxoR1sS1aUNNHW53l1MtKTVrrp3bTl%2ByJGr1af18B45ZBUi1sV7RHFSr1M3mR5CTChBwuyutr1bKBMQK8F1%2BdhrFUAsGXg7tmLaF8Rxpw6Of9%2FtEDe1G0LK4esA7ZwbG%2FRCJj56V0NR0ZW3NEijQ5zl%2BhMd146OihN2tx1Elq0kC7Mnx5Go6xZDyS4NpdO4x1%2FoJZl1LmEdb4dfaLfHLzRxfuVsNLSPAkTQATS8dQ5q3CBGyoupceKi7gLPnYC9SJ%2F62CW5KmP8Bh1ZZE%2ByjUbS%2Fe1n86I4l9D3qbVXEQvpsiXb39dBhWLP4Ks%2FhVlWpaNf0key1aEzZePPzrSl025ud5nRPywnsxkMZ87sH3%2F%2BL%2BY0fquBpKlhBFZAN9QU86Lolk1mFBwSzZwlO3Q3gU8tFJbYL%2BOwcWzK4TgVpJXJ3ytCtSRlSwNmBXbBrJLvy5iSpF6sHZozqawCLtaisuXYbCGZbo2o%2Ft2OsvXjzoHis1Wx6quyX0qy6LoHdqJPMz6TDcSJ7NQdFXoBMsXar2odCTsFRWq1IrLu4rBe2Mxk2M3u%2FpT7SFZ%2BHovjLIoVUBHH9SZRGp7kyMN9b%2FKsuMfgD9yrwt0G%2BeeYxvnhLvmqqYQofUJPKxSRqDKzYos70V7C9ha5ENCKkATioK0pCQ4uQoUku935lz3KnJfxXN8hTmVM9FaTCQobBEV1Z1N27r86460q5kseilQv7LVgn%2BlaERwT%2FeYYGiyEs0h896W%2FGp6mp7tv%2FseZYffvE8DgPw%3D%3D%3C%2Fdiagram%3E%3C%2Fmxfile%3EY    IDATxy|LWQV^*X[jMU(Z-ERKXFBQ[(	;3f&3$x{9757u
+d7zM2Ux!qXd4<z8slMH>f9zL2hnn8	7dw_xc;E80c>	M}(Y i}<kl[|&L`ne\zDSg+B|jq!7t <rHH7Mv%ce2b9E9+i<c`zx2H~_Ky"PM0:Nd 9|>Q&.u&7zL28#8xzsFV4c:@L#0GS\%*J
+y78#(Gj.ALvQ
+y<!DSgG0^\~e)dkZi.?LI5BtOhi\|x&C'j}b4"B9L&|n]!'a6N[CM>1Gek@Hpy|x&):nFh=V,\vP~TqGe\Oulq<Fp'k.;r1z8Ft#DP};_7BsdKGh}k(#!8N(#!8N(#!8N(#!8N(#!8N(#!8N(#!8N(#!8N(#!8N(#!]!-IuR\3^zG!:89(ZW%..N#	G8CqP	G&e3CH	Cq$$sPF*/V8v(d~@q5k )T |O5X@AY`wT~},[W*Wv~GTTE H9Vr"!Y^iXr- xR2xDm&}l Yf{%JaP	1zGKr)5WysKrI49-SNRvmWTXQr%zIb2n8BxEyhB^yHZ;uP Z-ocqw\I[}LBwkvHy,]n+W )i
+ y|vNH8hY|yEnE?KY,7Ni!/_HjHf)RL.w4o\wNq$8sJ?kamci)i/PP 3~CiG1b!Y!H18hU wO-Dxs4H,X  v2W/i]
+S	8(Uk^+7<y^	iT&UkZ[O }dE-{v Mj%7k!9rT*7k! MDB<]O1qYUi8y"U(]b{|7i}fu3#UypsL__(+J~|chIG~[-)u^6%)-<^XQZS^//gaRfe^4}Tmh~`)_4WC!?8(HUe1v-ZTft;G@q$3jc<yLR\E;qRF %L mMNueMNdt8 Eq	2px -tLSWo>( O?+_ CFgZ=g\GBqi%K%lXsmS<|D5CjV_ a"w|5C[2ndo !-_-\%dY%KiTh- 7-sJ_EnEc%Kyu9g2j(;vQ;wY{	X-ZO$$%[l%KyrU/'ew('%{@LN*	l bidR:`~9z-<Y-cJzV5/WN.zf<_ ?|.r+Z~K )]\Vu>n5jsmt{ ]DnEa@:wx[V, 7*&WWw=
+ #tRV.7or!SNH||d8Z4nk7FD+q<~9Ib\uVq<_.RL
+*"]q@\-q@pVGBtRc,1Wvh/hxnA6(]
+xZV "[SJ9y_:Z,j^]X?~=z"E3Rlj*)^88f2DB<|QjP?S@ 7?.	9n|8Kr% d/S7dE.~Wn8c.e<S8:_n,t
+ A@kwK"rY:+y+r69Z.F~z q#{"c-;vTVgLq|\8fgV1{U;m;G >+1'	R'9\.r^	J>GKZ*snaP	1&Si	_-+ M"-RlIsyl! R~u2). r+Z~3:X/{EnEKA$66n#GuWJ~1b<sG_q& /R%BT%s#'JJ,Y.S^Vn]G.Is%koHo]r"~Tu%j5s%/PPiPI H\e|OVm:x}\	?& ToJu*Q	9zG	/WL[giRDQe[_{ps| Q~d{d}bRJ+v_8{T\N_(+-@>m*_2).-~M.sqUVZTb/8\R#O>uj3gJ"E[nvvMVZrQ& 4mTZh!7.]6(qjqd	7qd\Zh|(89(($P3Cq$$sPFj"?qI2	1P};GB2Qi9rDUi<x.\8Rf;+Q3Cq$$sPsqFCTF |\It#1P};GB2Q9ZZj*/_!q(#!zx}"Z#9PwLtgGCqP	G\Paw68foHH8v(<3  
+`& pgcc8v(doh\yq(#!87e)89()!l1P};GB2Cq4.4
+($P)89(qYE\2/+`;S3Cq$$sP};G@i6q(#!8P6p@q  wgcc8nONF8v.Fc!>{x118DE_qhqY(	j.;rzs8F7#Q X@aw68fn)x&soq7-x#h]V,w|0VTRMcb jCT6nZn+,;0w9\6x#hETs0s1q, ;S3Nh86$Si7BxVK<]~_c5>,)#tx[6hp3BGj.?L1~GE-Ff9l[m^&6(a&%|QlJi&[	q:rEq?.p(GL#l$m"	1&;p#3"gf2b^pM0j}|btE-}tMZNn*?ft]ckh}0#@s< e^BMs\chqEq.1YSZ[$TG:qx	)>l!qx"!)e66?oelLq,=&Jx[ {O 3"'lPU.XyM'Fd!!^XDHgg'."d9'6>qXV2w68zIF&:M4tf>2e=AX2iiNg*3liDq_M76iGnx	^L9FqGJi=)."{
+{,2[}.sgc1
+H
+D
+
+(QTQA"DjvZBHz9xAHjg 'h<>.s]PoQM. Lo]0*8x5%@q$F`&O;SZmZEVGrH/Gb{i\Gcap"k.KAJY-
+
+x(k7{L^UoYoK!HD1 MFGcx528"ox1*(`wdPVG$Df^dp?k<gTP]:BX@U	8D6
+smp ( 6EkQA{Z
+
+<0\m!-_
+phM<]& }<QA'	8/2(!U"6E,F(K	 rKw688E-hY3\8Z	r	!$P8` N,_GqT\q$=Bq$F`cA48#!#1L' 8GBq$}Aq$F%H9cw68cx%!HB] XR E~TbbvPIq8 b,7" Qv@q$F`e]ugcq8 ~|wkD!)8=9Gm[q	P!8H`wg'GBq;(l@$TBl8=s68 ezh\(vd' TVbIh\()UYyvB$Gb` GBqc(#h`*#(Tr  ]PIq8aC\%BI  o^*w68c{( ^5ll%q*BH
+(\mosgcq8^ mylq$KX`*#(0 `&lLq4.y r;,'u,  8^BQ#1C|h\<(_X8rT5!DS(<_q  llLq%Ox@V8p|#GUB4H|x c9`xP$:I:G&h zo N(C  (j~^z:[8:f:G&h\ v}(b&[J+d
+|t|Pr&#+#5 PF5?n~m;;8Q.w} 0\? sT5!DS(DA9: J#+fxI;[G8~u?Tqb!$U(D\FKdq4"@sV>S  fP.Qb!$U(Dqc+XBJkE	b D-#lOy\[$WP^Ip3$#(bV4wP6\ *o-8^_4.B78j4c+837oS[Qq@}( L Rt]'oBq$z8p+8m;86IK}Rt]'oBq$z['N(a:<^
+8J_nB4H|p{
+Qq
++
+8 1 P	!H|p{
+Qq|9GPuT `i 	5Nq*y(uYG]1qT 9P.rO[t46!	s  ;+80&	-8M!jBq$Fw(3& _!w8
+ ^G?({vJ-uV#8:M!jBq$F  0+xE_p@ >p\Aq` v %NGcBPh  c.8~)<L
+*n-	!HM ,` 2t)8g* ] %d46!	0@a"RG(Qe^I;TuAsd46!	x(\?(v
+Q^ K yWPAtx>p#0BH@)1Ql0-V Tqq5 "C [S&582(Y
+ VXl%/Y Lr\A1M 68:M!jBq$zELPuI  @GAqe3 lqEM(YM[x"T8ri;;8 byPryJ r:8
+Jkj({#Pf 88gl 
+>zQ3t!$-(HMbK/	 l%sc<D(- nxv
+Gb*C}}[P
+N.[;rk(w=rwT(+KXGBq
+u 1b~&G];+crBQTt!$-(r[-6*|8P527}1WTKQn8!kS=Bq\,&ClLqeA{    IDAT%|yD s5 qaP~w :Gb@S,oLpgc..^UmKK*P= ,g#!Du(r?P&ne$SBq%A7@6 :["WTACImV-q|&2BT%XN(?f:eYKZ8~h1 (%"t2N(}}SL8^x ^2clHq-2tM ^^(-ER8
+g2!8#1LyO>6x(S8~b<=[=B@2 j^^?OC \`5G#Z:*8
+(w A6u8Uo v)"m6le KmRP.K>n;Mxr48(Yw|o[dsV>}M0/e x}5?8U:[z1QWtvxi(+& P Uql_m_tB	!I(7ld~=) 1/?i^~JbJZy6eXK@ c8UxwdlLq%9%to& O8	p{T5!df6sC"xsSP.3[(E$w_/R>R# T|y=,(G
+h7(`?/lccnrI :B|94<z+m z-@io^nG7\o+^aycg+{A'TyiP~^zB|/U\
+e> }e<?[\v	 3yK<[x4i Mh[NCHIy;9YHr'o'IG2ixq^!)^}*s1\^GJ	%G]leP:GK_$Hp&t> x.)8>rq{Pg:)#VH;t,3j0TT!@q$F@%lLq4.Q.w\cq*\!8HPF:)-/;tu,96PLcD!HDI(CKg#q8`s\Q8W  q$h gq%RRq8weBjP9m @q42^1Mt,A>R1BH@,X 1Ph2_	!D5(lT1P(6a~@-OBQ#1 r48# e@Ln j!#1M"c2	P<NN(8DBP1GBq`;6[#BI		Dq4.G (#BkyVB #1eJFK1P [qfjG!
+Gbb|Gh\( W\l7c`	(d^x(S~2l~xzMNP><Np@y 
+Ryw}P=` XvBq$>LIM1PI"@y<YB hMt#z' 7?-zfjx4X0fYe;)''1 =mw4/{EY:HPX-h\($+R@_d2R# t5?+zfesBi|{0r+GJs(,pb(}-)H2xF 3E,8SgF?h^6<UmE*m$Kr|1HPIqWgycPZ~pc(}K)"s{y E3@V}7/J]}1H? >vslLq4.GA"82`1<h=-G-(}S#=[Bg ,3?G1i-$M(X;SdePhP:m;W`P<n9=@\5?f;<PQy);;h\($Tv .a~J xQLy#P.G"3[XG}m2me`<jt$@4}1HD> C_yPdP# xP?@Ko+z:<x9#3@)<Lm!L,'>r;{%9GwC2[Gt881H2A O[rw6)Q(2l @Q- N g 2Dw}R \<7x9
+eP^	8RP@ h7Kq4.GBGWle.)42Ym8#!#+#U!@C#q8B8S& @oc;;8#!#1
+O x%5 A&GBq$}Aq$FI V+M(H!HiBq42GBGPB<GBq$}Aq$>P	!D_PCq4.GBGPB<GBq$}Aq$F 5 Z{kc8ZM5)]jNz+v0Z1P x@Y yAR@  @2F.fqT5^Z5%Kh;gI--fy=p PZS#0Bqm  /2)aF_8"I 6? e,YR#gO6l><|<g\_U/sQ2a;{20rx2d4o\U&EH PZ44&}Y,[L>,]pqvb'zUCS&-U/BMc%::Zf%AAAO+#T2 >p.LY~2f9tGGBq$}AqIIIb2?^x!-y< @uL7-[6\pkPq8B8}o@nPQ}-LHE?9wGBq$}Aq4v&Ic6 KO<{r~qGBq$}Aq4mW_}<> &h&mYJUFGBq$jK*UJ&M$"":u???sB
+:uXSL:ujuj%Ka""2w\)[ w}>&M%KJ2ed*N:rmw8$w%B*QUJ8X;4EQMUUEDBCCW^Ce	 /gS:]+RP! SLn3o<Y7~x={v%PI<._c%+'gDq4.G6C;z#ro^ H-'e ;wn8U.!Zz! <mi,o6l(8{*RE{t=grV^=~nZ wyygT\Y+";$c}Lq:$w& 42']:td'"Bq42jWdEE8^;+sx"G`Giz9+J%W\
+%_|7O#&zr	,M=V^;q~6B~_E<qIFIHH5k:}WZ8Zw ;@]	M]:v!r\*u886o*q5kVRdU+'vEEDn.?>[.H]Vo&'MawuZWdKPP3yiiO?TqQKo:e(?e!/Bq}GmuLva-NRRmV H%))8>x@5j$ $o)K]Zi-vR~F#.jR^=gS8qM4u(E>}b@Yj"G8:88X 3<c7+9KHH6qsIlQDe5 VWW3!9xtMk9"%J8= 2+AXR% Bq4.jSd]6Vq;|jeP8}[A+l+/ jY95k$K,ncZtE>_!""r)GQIybB `ryK(EQVG[E(zN[]N]R%O]N}y# 5j3lRD	7n]}>c;qLmPBG)l[DEE9 ;-O*G+\4mSz$Q;92[jJj-T)=rwq"D\vMN<)u+tdAF6y]$g7(=2XN~g[P+W7_6A:JrN#{s_~)n1LoO?T'K,8Xyw;Tr@qW0>\?K$%%cd_h.K%**J;KEqvC???5{3x66m"$$''_~>|9rDi>iIc(#jvQ7^(.cG_aW7+{8J`ZRrei|?K%O</6n( d.dRfMUjJ.],0|DGG:/I&3_~K2*7oL>]&L 0m.KNN2e8icWeQP==
+%1&1H.?IwrELwQC7onhRR%1cu>} 	S
+ '?{	 XbrN8!s[&%%In$O<.SB=+GNDW/<ylA>}ZVX!_~e9k,qy9c2VTpf8z-=[6th###4!&c;u?tne2w3ED3TJR@w;w`.)]1/OU{{qCs!`+b2$<<qwo9xj?(?gmW3\~]zic
+HXTsa2c''NsgwXQniDDdE2qDyWkBiYc,+))I7''Ovz"lYd|*'NHe}YbV<Fh9b#i.=g1~J7,+V+t]}$27tPME<((H._,? "EHrrTd)+oRbEXO]e2e9sF<x+2l0{|}YGyv&glWZx*$G8[}'1Fk}./O=gnXd./ [1yS HTTe+CIXXXQ#FsGL&5/{heMf;JcmfzpywvL:6DM$%%%  @ H%whaRR%i4lP
+*$ wKsMe=|PowVXeF\~]cllW?kq8v7xG(ZtgK%''K9L2eio!w>df&M RX1}vesK7hi=zg$w8}oZe	sP};_
+ 5ku,5qOqoK9/"|:GZn-}M!C?ISu'mCn-3fH!}W1lQY/]xcH~W}kG92tPUTVMj-?<XE/Kx2}t~*r RhQED K.RD	Y][>3IJJrY%78^tIzo>O,\f,Mf"/TZ+PcXYf<B )#;w'|DFqhkoLZb@! hm+Wc	7IXI>z@R};G%2v'h~bf=[2j%KxZtiV Czp5Xl>p^MzfK;y<p7C7+>7Q}8G%kIq0a}[3=W\qZ9V(m`iy`=AL,}>d{=^K>AqPVsGBCCNxCK2%ON9;v?AAAbDe<^0/+SlZn+v)>##/^D0F={R:x(a}(n#kzg>Ox3;zhGqBHR2V-P};GO;8&pBL&>NYd'YdF|wSoHs).m]/=g\cs;]Q7cB<R1>G3NnC0/K=SS	bcc8,Y#CqP<x@>C={4?2dv/O(()GNjD0O}BCC=H85YhImh2` Ylll?G6G6W;M    IDATANhv$0~s6Lv)m-G&5_xz/'K*RbEi._Sy9s
+ )UJ	 5/oMfJE'5jHbL/e R)QW#1<.];u]nIa|-0 _#q5ZM<gWzDC 2*h,fR\YhK'=C+R85i85;?^,b3{j#q-trxQ,WnVU](K9[ u/FoEq$>-VZ	a|5HF+q}Y-;uYZ//\X*%1;{wR\YyZUW]$DIE[-+=o-olKCw8[@*)#.v<rsI/Rx"'WvL}~)mR>+JOcbL +-A--z+7_+B[%1&Zc'1'W. zh%K9ry1{lR|+g|w-X@ /F%dGs5DvqOYjm8>4	q?.-7vn<W\ H%d	,R-1n] 3>8Z@VLiq|2O_N-u( ad{ep#I>S4?2d2}f#OC+qmn#? T<h3
+TbR@8_RcjUfT+lXgKrgnW*SFMq$>Ihh#{wmRh98}iM*W mzeK^,iu07m[dq)11&Zv+9s(R}{-u*e$DSdw'V}0xgn]_ceA2=s$1&Z! s`$D}{vpTdu g|58FNVW8)0s}01	-,yr> R@1b[t*zIWY%vTuo7??? M"$OQYT)9tIz:N n[I]M - 3GyRSjW;elR	/p5~a|980Sa#q5ZBq$j@qduCqL'<zoH0NxGa19(#Q#c:	sP};GGQ7t8v(D(n('@AqPPFP	O85828 =Cq$j@qduCqL'<zoH0NxGa19(#Q#c:	sP};GGQ7t8v(D(n('@AqPPFP	O85828 =wssF]>BqduCqL'G(wwn\x{p#>
+a1P="aRLMh7Z(GQ7tBq1F436~J7PFP	s\pVGckcTprE(GQ7tBq,{tX6FJ)Zf828ggw
+
+_O\swviH
+a1P=Y3cTpG-0?.C][8GQ7tBqSiy828_2=GW~j<yRo~IvnRJ)S.\X#5<yHL2RJ[kN'M(9uoPPFP	rEbNYl|ES0u$a5dgIQFR\9iJxxDDD;%66VN>-W\;;w+ri;w%<<\z%M6eJFAg$))Iw_(n(6_Dd	)Uud-pKN'#e-^-w-2rHi<S'^-hPFP	d-[
+ ydZW[SN5kVWGv*~~~S'uGQ7tBq$'OjZW &&F5k&9sh]3G/7)GQ7GtDGGwe_Kbbbu)$#4iO.]H5o]t{Jkj]M828o-=zH
+]vsRIz9x<@k,WO36mzJfuU2? zK=BqduCq%O<r2HHHHu)$;wn-/_^*U$y>K^Aoi]U828HmEDdRn]vXHC||/_^/""[dKK}5yUVZWlRu5T0("W_}U++VW_}%M6M.du;_amo+y={h]U828k{drQIfUa^2<???U h]U828:aVtH2C=qmA yj;=V{w>}*M^zi]CqduCq$b?i$#<s2aRIfv9rXwO)#}G$o=[s]E9t*GQ7G	Jrr+VLVZ%oXH2?/>QDsN-qq'hR?aQD:u$""QQQRLyt!G+''O>c>c}{yd._,M4uJVCR\9dqRH2$-WZ%5w}WZj%/_7oJHHtQ{""2a)RT^]$**C2|_O;W}]U(oj?)7lCft3IEIJE*Bj&"#[+mn]%u^?)\:uu\su=]!IJ!!!055Edd$D".^(nDupttUdeeqy{{ *]v8< 	NTXXmr'/sfff\8fdd@OOu 9s  D"$MjtR>WkWQP8zpPPPpY%%%(((-3-#Qjjc,,,_> )SK&Lp8`}999`XfLMM1K?geCC}M_
+GTx)nR}V4Du>|W~H$9sQ# <x0<==	kkk ++1{{g+>>>022;w7PRRH W9+V0p{'Ojiy(IRR8CQTT333LKHT+VPsJU]\\[c cg}/^p[[Rz!Ci&g###.+srQQJKKQPP HH8p"U51,ZF}#,,$IJq #yp$C||<LwpLDDk};j(? 22uT }%q7oDpDV+<}fffx-&O}^ZZmr>|86lGa9Njc~6l#I*8
+&j],9hiiw x-Z-;"
+
+Bii) 0` z#FO"`nnWWW033%RSS 0rHp~Xd	XU%11ci~/6oLHJp`oo< =kU5BFFFHXC)Zt)&OI&!""_z$+#a022CU+LKHOmrQQQEQ#,R/=!??}Ahh(w#Iy!!!sq-Q8";;033Cdd$9G1EEEC	k+}7|@yF&N<	===C(4,^8}}$IR
+G9~sQ8+Xp!o5DVQ---utt[aH;7	Orddd[CH*p0ep_?;'3-#Q)((o_pm;cu1cS-6DDD^~aii]"88;']o#I@~+,3-#Q#U gO^>eXEC%tuuwajb2Xp!M&MoW|
+G$U)#$OS///(pLKK7oT|cf#e(R/^@ll,BBB0x`|/F Z
+w;w ''(.. >9{~~>rrrp{7VZ 1Gv0x` ../_)IT  H@|GB1j(:}prrQ0p@^={=z5f%pww#GTzB*??O;@:u.6>`llN:DDD~w>}*'#I	6mvAWW:tep$j3:::;`eeCCC e@OOu`18p  pu|x%^zVZ!&& p%hkks9s F+M)i4}~)IRR8_#))	[nc*T1$$ncO>ERR7nm;b}HHH}:tq5055EBBBg*P7RhR8zp%%%HNNd:H{  >>>022'<==;u+4i	ssslQQQ2tKJJ}mzjlT%F?{, | nFeHHH@ {*U@H*p;_|eK4h ;wwep$j30:tmEEE(--cE^zGtcAAD"D"/)2!%vq4kL%c};P8zpo%w/\]e#Th={@2633o *"==000qW'OK  h)(5
+GTOAAO2<x# K'''xyywGcs~XdZ2j2<x{{w_ff&1j(888 11|8npttW
+'''^{W$IR
+G 2'@~- QQ6nee333p><y ?:ux 5k, j*_{^{{{=z 6AH-ZFAA__#_
+G8::r?@[[HJJBM%?-ZqM:u:rJP8$Z)GFFBBBs[rp$MMF-1M-b2<<<0qD paggK>}G]TS8$J)!BR8Dq2[4hd;vL~IlqN>k,n+#,,7S
+G$U)# }}}xBi)	vSSY>eG>| ]>oFM
+ @u-Z#IW
+G nnnp$MUO ^hx<u;aoo///8;;KU59sssj
+K.Ett4i###O{{{.>kb~k#$^)L83ffcGi)	v!%/#IW
+G 7e455 j7RhR8zp?? j7RhR8z)S`pBp$4>$^l8FFFq/zmmm$$$qQnHZZZ/aii	???<zHET$I:uSRRQ83`kknapss={T5jLLLp`cc}Q~?7=
+S9so_<c
+DXfZn{)xGGGDEEd,AH*XDeH_2P8"77;O?' u=*s=P,\P455}9M_W[n oA JWj"0` )U#I:...2yzzJ, #Q5# ]X`o#	3}{8pV$sby,8na|]y3~yS5;v@+>>>3+,[ZBJ$I:ZZZP6---Q8UA::qA @=-qqqzs=zG`` g=pLHHCUx; ;w`)qpwwy<EE    IDATlZZC#p<scDnn.L;vp?Koq|BH*o_;wRmlldGHTpLJJBPPaccCF3 @zzXL2oiXxqp3fuP-EII	777|M{Os(SN:u*7t8kzep{ 5j_in[[[,[q.[vvvPm
+%Kx'0h 3}c>Vq( 71((@#8p w#>\8?H7N7I_UQ}vhkkWy3 <<<wM,uXYY?>> >>>3<< m111;v,x=nQ:BH(Jzz:gO8q !C`/'Oppp@hh(`mm=O.]d:t .]K `YQG}+Wh9&O
+_eMT999Dhh(_c	4hl:X5}poq$Vi8kzep+?}!##qJctt4'O;
+)IXE((.. RXCua{MO?-[ yDD>6lG0gwN,u1''4hBqC `e>|8,,,0m4C(bBWF=!p'wq}FkQFV!
+akk@ @?z9(($zzzbpwwGll,wU	~7?;v,<x  xJJJx]"**
+h15j$8`ccC ?8>0442[nppp@bb;W
+8HP(D@@ PTTSB `
+G+
+HJJ@ @>}? 88/_pehkk
+2_Qx@7s[XX@ `isNw P9s@ K
+)IXE(	>7oh|HIK(!
+b
+nkPX8
+B5 <,G=W@@ ^|M@CB(ptt)OC(daa;iP(?,R8B|N5iF%KNHTcpvvamm-*PKKKgj|HIK(cUVA  <<BxJYd|Xf7!W/xxx`aPPP [y4i
+)I' 9Zqs%Czc_k|HIK(1))	=R*<yaAKKKp\b&L @s"S~{f`=mShh(BCC<{<PH(:c1cr_w.
+GBo>Q'(cY0GCJM_
+GVk
+GP@ vyex51$
+)t<eZZZ"==?0LLL(g/**P(DDD~7Ht27n({DU122{NPfhtttdeKt	...F(BQQ#Ywww6=zk4@Xw2gr={by3 0x`9rCLLB]C o~E8 {eY	1rHm!55<x0N`dggC("((_}<==
+P<:u*/_/^H s'`2?vcw|?~<BCC
+www=zUi4#GTz2!eoop+WBOOXnF@f0`  *IQ(IT B,_k'3-#(/^nB\_{EwUjCPE8:u
+1(`K0Z
+#G8$IUJ`o;v|||dp$31>> s~mM,,,3.]1cp[&o&M 44'mM _s0{lt?xb|PRRI&a>}:6lPT'g/@ii):;c1 ]vs pttDN'IIIDXh\]]@y/_>}@[[dMom$+##F o!j	_ pwwPQF~sXXXpuuEtt4`ggM_x9N: W_}M#nnnqgO @vv6n[W ^n>|N:!// (]v' %%?22G f-+Wes'{wwwK{A3gvZNH*p_w^]P{{{\rZQ~ODDD#qQ|!!!Xp!-ZsSp, .^vvv_UT'([O8#33@O>s'tgO &(IRR8BO>P\\LKH(Iz1dDdggcU2e
+   `hhP 077### L={kOukW\zJ;w.!z	OOOxzz1..Jc+WMP8zpN+7nPAUkJ``(--7aee h9 7nf1fO?={G{?Z1118q"%KP)ooolJw Xz7cR8ZZZb5_m$ k"$^)+lP
+GBQZlH?DDD ((JoC[[; )..`@qq1>*/~pOOO~eqX|yWp$IJep$u{W\{9:u*Zj/nnn2dl2d'c1cDEE;vc333knnn(--H$Bxx8///nkyEXXX`mUWGGG`?M$+#GFGGsn?i|I~zQ]|p$IJT/cFH(JmCAT&F$^z|C-P8zpOB NH(Jq=AT@JJJM8;;KgRp$IJ
+h!~Gi)	E122wQ	vx<xGP8zp`eeK.q^zrp$Eq$ja{#66a
+GT f%(	En08u5j$qtmbErr2CQ;$^)hkk3
+MKH(7o=BAJKK.]\}s&NHpx$+#q|FH(JN0*r5899W^eA$a-+^U(IRR8Xl8Ni)	E/5g1~x00n8B&''cWg:
+GT tttgO[h!3-#(]vW~1+++7.jJKKq17VVV`a_kj3$^)!>}<'s#(wbN8_~!DDD 66NlFff&._SN!&&C}{_~X`N8,P8zp#'rq|a7"((F%w;M6hfM6#wKKKx{{#((6mBRR4P8zp"s0p@)	E177Ah4$^t8fee!++vvvy:8={Ah4$^t86iM4A/uX`c(	EJ5#I:e(<-#(}Ah4$^)RIu)	E/N<0Bp$IJ666 +WBGGmedp${P8zpjH ..%%%pttP~c| 4
+GT  HHH1D" `2R8bggDA#IW
+G 		)"##!pEP8booA#IW
+G 5kPRRL<2R8=h(IRR8V~P8=h(IRp{.^~ +]98p  $kGccc ={EQ8*ww T#I:oir9sm:{P8zXW^!33nBqqqR82l0aFCHNwp!Cp=p$ $ke;p>}o-ZnG<P///aFCH/__k5,Nfiv9qT=B$^l8ZZZsrLR)Fai| 4N35	W'}q(~#cDq(IRptvv~4CQ5Xqt@{P8zo_;wRicp 5!U|:
+#I:ZZZT---Q8V?*'eJ>C_Fn*/BH;qssQy2rS-HFd`pqi| 
+^=cF1(IRp,((Pj
+GYDh,>G3be1&5Qp$IZgQY(d8y;!-2+mu$	#IW
+*B\\/[=zH(I|:#IW
+*BV?.V|b}P5$^)r%;!U#u
+GTUQ9!U$Iq#$^)rP8j/A
+GTUQ9(5[
+G/(IRR8V
+GplL5~o<y^z1LMMyCup$IJXE(Q}W8fffb4i222x_>c4hrssq|'Xz]i8.X [cHJJBtt4to+WVk$I*,cpT
+Gp,@!,,O!I0C @DD&Oo2w# 8::1sEFF11cT{$IVE
+*B+~~~:u*o[(,l+--Ehh(z777.] |g\`M<zzzpvv!cptt77o 76yyy T@ #W_!$$7 GGGX[[c +ZhOOO|}tcA;wn5BHP8*f+N4IDD| >#4lw`~~~h!4i___31W1b0` 0c	'1~]v`y0006m
+:v???6ZZZOKKK0 0n84m||}}	i???n5kqC:t(
+tcy'L@HjP8*f+fdd ,,L"-FcFFF8p ?v
+SSSu2g`` e[ cH$B`jjoFtR00a @RRc;.\ :t  ())q];X[[K.(.. deeqmdd)S|Tmq$IJXE(QhG\p!B}&3={ [ry!JKK+P:q(--E{  "/U%Kc=pyy7oc8q"Z/_F`` LLL_~p$IJXE(Q}QeQd8`!`/l20 @_!
+G prrc{ _7nCp~:4h [[[ ?P\\###4n_[C~y,?_{.KJJY3nZ7p$IJXE(QU<|F;|0];xzzbHII;l)E/1tiiia`bbcbxce\<x #qpaooKKKxyyq(5qE<==1x`t111x$+cpT
+GC#IW
+*B-#$^)rP8j_P8zp"AR8|AHP8*:qHQ~}tm1g~^8z)Q5j$>	m0;l4I`f3|f:`_^?NC]@cG-s_tNP8	#IW
+*B&jQ/ZJSG0e=OgS0Fc4t	-q=t)w4iM3e4\mZsI5P8zp"w88#W{ _5I)G0aF"XM;^|*^K/#QO  [IDAT'p$IJXE(puw\i?yw.6he
+&8p2W]yt;z}!qfz`aq*$6j=T)Zgq_zb%v0LV-D$+cpTu>3gFh!U0vcq96. q31L9	smha\s`ei30P^==T6e_gFRF1C" M;+G`a%?As"P8zp"lqLiQ;ZWvpMHJQC}?Ng=%o1qJ=^CTWbr.0nX0up$$^)r;sxb0T8O?igS>CL!p,x~.XGWuZZ&zt4GW(:#IW
+*B|s	KbZuXXnk
+?Q;kok</s+|#ZU4c4t7G4
+G@HP8*ef.-8x&:8\uc`d3rKFQqb#Qp$IJXE(w4Fq#.!h0gLDvmgK#Qo-CaV2O ^6/|;';o_~.' e? QF;o1:8P8zp"Al)	p$IJXE(Qp$$+cpT
+G"3y_&{}e.$$Z0#!
+GH$/y_zu-""Z0#!
+GK?~$5dmZ~)	P8j,X@bEvmW$&$$H,o;wKXx9_NGp<z({n /c055 [5c|s'+VXr%IMuC\S8AN(/0 )5[M{K.`W qpssCnn.}M p 33
+Qu	YYYy&_rI&~=<<P~}00h ;vDPP?ILE&aeS\IRS_$OWkp0&# DFF/8~<  ++vvvttW5Nhh(c K`DqM4c> DEE1
+o}`_gl]\IRSX]VeNc''#a+gY@Q~>.zX%-c#Fco7.rIE^AEy:c	=cvo[8G:#16En$?("i87iR/ r
+A+-2sTm=$D@nE$5<xZ]x7z./]LJyjDpL#N> n'TIC%5M1X:'`UD6CZ161X8apM'&0'-dN#m0d6.Wl:PejON)O'Hx_y	,,,]HG<`Lx	7fMZB?Cxx4`@666wo_U@U;x}b +c%IMsMYttti
+:-?#c`,Qp?~<]1&q2Uc>(\IS$J[J$5/_b2.u7op<R.eP8ju!3hk. W8n1k1/m@`,C2hx+[o!M:"5cpl51+:CAB^86m+W8;_W~EOcaa:`YY}%_oK_AlIRS>U\3?CQpl51[%Vle{K,K,_Wr.Ll$j$qy?nDEj???$$$%k%7*Yn;&dG*y1 WSxR5M'q#0_M6xI)3glwpLIIQxvC=)[$3Ku|L4I!||Ixb)44T/_\:W07VD%q)WbE7qDdff&#Gd6ty
+
+Y1]_~E/J\y,u5muJnmGa W6mnx	+b-^~]H/F11^I	;6]j0;&d%tnGTG*_V1F100P/LdFX^"Jv
+Y">.D|*:+VYm2Iay2NMfXvr1o'aq~pbv^%C]~MEz
+?
+}L6lYf[Wcvh|f1X^=oW  4
+A\_t"|I}s2Y>#+Gv;Q;87I=dsuR0=Drw^W$>+W,#OGaaa-8|8(kz(
+Z`E!#PGf&I|!BBBdoYYY5L@OOO:Gw6n6}{O3pA2Nd-z rq}NkY&&OWxqh`Rg(66FEAe,SC(**}eN5m^^KCO6McY[~"__AA1c8{,+v	 EH-t8oOI<{L-$ 2
+
+
+0|+#Io$U/q	Uq#}(7r]~'eAQ_cH?x%@ZPP._3+j[D">3p\SQ42XXL  seW6007ngq:||	222(I\z5<P?t4d,?f=/ :5A7OZ`5};Gj1**
+/GHHH,Vdxx8neL(?RBr2]y ?~Hk|-X@:1(=zmF <%%%HKK;*=$wCCC]'V'Oq8Ch,Nz%Kx) F$BB$#""x) 6661*c1^zj=  !??>DFF._SN!>>$+WQ9JPPt416cc"]]]ddd=AAD5{hL`S&cly%  $55:::U6X,Gii)LAAT'O@:cFF+JcPPMAAT7o\:Kc622.Jcxx8OAA(@qq1"o*zGQ>b%^lx5  {wy&/;p577G^^  B/e11Sc]c_M6~:  <cLOch1bbbAAiD"#cc2tcI^z>|8]$ 9su(;S1M#??AAW%309ek  'G+knb%3~cCCC"/AADWX`tuu+
+bX0Cb6m`k={  pm_hiE)1Mc6+3NBII	AA{/'P,1SHX>{1?:t7|A%I$I8CBB0i$>vvv022B?o33j&>S@$I$IVl	cl?ci0c?c2$I$Iccl]
+ccA#W7$I$I}	c&6:.FO    IENDB`
\ No newline at end of file
--- a/docs/GeneralDiagram.xml
+++ b/docs/GeneralDiagram.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<mxfile host="app.diagrams.net" modified="2020-05-19T10:34:09.352Z" agent="5.0 (X11)" etag="Iwx7x3ZgGJV1WBx6e0Da" version="13.1.1" type="device"><diagram id="2CBHIzs9DMrx8Qk8myeK" name="Page-1">7Vxtd6I6EP41fpQDhCB81Gq7e9a9t3fd1097EKJyF42F2Gp//U0kIJCgoPhyt9ueY2EIQ5h5ZvJMEtsCd/P1Q+gsZx+xh4KWrnrrFui3dN22NPrJBJtYANkZE0xD34tF2k4w8l8RF6pcuvI9FOUaEowD4i/zQhcvFsglOZkThvgl32yCg/xTl84UCYKR6wSi9JvvkVkstaC6k79D/nSWPFlT+ZW5kzTmgmjmePglIwKDFrgLMSbx0Xx9hwJmu8Qu8X33JVfTjoVoQarc4L2uzNngy8vCB++9u+/vOv2fRhsYsZpnJ1jxN+a9JZvEBCFeLTzEtGgt0HuZ+QSNlo7Lrr5Qn1PZjMwDfjkiIf6VmsqgkglekBHXJuk0Fz2jkKB1RsRf4gHhOSLhhjZJIGUrwIpv4pgCJjfxy85DZuKhWcY7eocLHY6Kaap9Zzh6wG1Xw46JkzN2HKyRv6Ci4ehj4yb1g+AOBzjcagMeRJZnpC0zVyx9DEzzDE6gIVD0AjREL2i6xAvmuZwANMEJLd0M6GN7nv9MD6fsMBGNw6KEPlTS7qhbC/5GHk0q/BSHZIaneOEEg520t0OESs92bYYYLzkO/kWEbHiGdFYE51FCfRluvrP7lQ5Mzn9kL/bXXHt8tuFnBTBNLBe5rgxMYwsaUBXABHqBM0ZBz3F/TbdvkdyywAv2Zmjtk2y/6OmPpCP0eNcrdpJ0qhSizJJVAKoqOlDzAG1rKlcSosAh/nM+xcvgyNU/Yp92I9UNNJqCOvkUZBVAHeFV6CJ+YzYrH9alw4Iu4oRTRPboShriySRCRIij1DonhJZ+eJy4AMgjagrSZcP6Dl9b2b3P3oej20tauIETRb4bC3kTLQvJLB4VuBeRaXy1VUXVswFGgW3AawcZe9ojCn3qaBTWDCJKqbYIOzi+lUYbs4kBYSPRRUd4RbeMjqnZ6vZTz0WHoR0ZaQf0QgsqLIxtyD8rxSBFmrPJNFuyBlH5y2mGLX2bsk4X29NeFsI77sHFE4IujrUp4flwbsJTO3waIDwACLTTujbh0UX2/gGFi20F9g7jX9FViYiWT5J1UyRkvzIfm9uf2inyeEpxYkKDqlCxQGgeSReMw7oaSlWGWfqost4dviWfsBpLRkCIg6G/WK2pKImH8+ajaljNyOOfM+QpqAqFmSxPpZpz5TE4W6IyBQeNNpHrBKJnLlsq5SoltWaGmkx0+SjkmWMTNpih4uywz76wKo8DTee803ABBVw8hthFkThyNRyx9X3nBP50QY9d6h1GscvdVSNaoaVY+Wil7PTarMISWYW/ve3xff+WGEXnEKXIlYu7YjBbMWr5ijEtp7xsRZnOYKhqbgpDsWxjf9FIT4pV2amTdzfNc3IFVp4IWIaSqa7ACQRoz0Ns8wJFnIyE7avLGpuEEWnOdYfPfDjqtcLxsrM3xaBzkDWRpn/TtdB4csGhO+Fch4fu84TxETMYRfALK0+HbwH2JeKlfFHm43BwZoZRG2INzFHogp2vzyaASPE+DD79NRhS2eixeyf6gb4tkRm7EHJZe3ORQNGY7XxaZnT5hbnvedskKPNuPjE2FP/VvQdsTTELqwodifdUKHpPP5v3xMLty2jw6Y/vDvsOXNB39pfp8vWh/RNp35aPrqGOJ96Ptrhk87n70GTW05oxnpnknmQ40UTLAdlqfgOGmwyGsPvP18ln8+kr+Pn9aTRv2+1ay8gMazmLmk8rnFxoR1sS1aUNNHW53l1MtKTVrrp3bTl+yJGr1af18B45ZBUi1sV7RHFSr1M3mR5CTChBwuyutr1bKBMQK8F1+dhrFUAsGXg7tmLaF8Rxpw6Of9/tEDe1G0LK4esA7ZwbG/RCJj56V0NR0ZW3NEijQ5zl+hMd146OihN2tx1Elq0kC7Mnx5Go6xZDyS4NpdO4x1/oJZl1LmEdb4dfaLfHLzRxfuVsNLSPAkTQATS8dQ5q3CBGyoupceKi7gLPnYC9SJ/62CW5KmP8Bh1ZZE+yjUbS/e1n86I4l9D3qbVXEQvpsiXb39dBhWLP4Ks/hVlWpaNf0key1aEzZePPzrSl025ud5nRPywnsxkMZ87sH3/+L+Y0fquBpKlhBFZAN9QU86Lolk1mFBwSzZwlO3Q3gU8tFJbYL+OwcWzK4TgVpJXJ3ytCtSRlSwNmBXbBrJLvy5iSpF6sHZozqawCLtaisuXYbCGZbo2o/t2OsvXjzoHis1Wx6quyX0qy6LoHdqJPMz6TDcSJ7NQdFXoBMsXar2odCTsFRWq1IrLu4rBe2Mxk2M3u/pT7SFZ+HovjLIoVUBHH9SZRGp7kyMN9b/KsuMfgD9yrwt0G+eeYxvnhLvmqqYQofUJPKxSRqDKzYos70V7C9ha5ENCKkATioK0pCQ4uQoUku935lz3KnJfxXN8hTmVM9FaTCQobBEV1Z1N27r86460q5kseilQv7LVgn+laERwT/eYYGiyEs0h896W/Gp6mp7tv/seZYffvE8DgPw==</diagram></mxfile>
\ No newline at end of file
